<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++高级程序设计笔记（C1-C4）</title>
      <link href="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1>C++高级程序设计（C1-C4)</h1><h1>C1</h1><h2 id="introduction">introduction</h2><h1>C2</h1><h2 id="static-cast">static_cast</h2><ol><li><strong>基本类型之间的转换</strong></li></ol><p><code>static_cast&lt;&gt;</code> 通常用于转换基本数据类型（如 <code>int</code>、<code>float</code>、<code>double</code>、<code>char</code> 等）之间的转换。在这种情况下，<strong>它的行为与 C 语言的强制类型转换很相似。</strong></p><p><strong>注意：</strong> 当不同基本类型之间的转换可能会导致信息丢失或精度损失时，<code>static_cast&lt;&gt;</code> 并不会发出警告。例如，将一个 <code>double</code> 转换为 <code>int</code> 时，小数部分会被截断。</p><ol start="2"><li><strong>指针类型的转换</strong></li></ol><p><code>static_cast&lt;&gt;</code> 也可以用来在不同类型的指针之间进行转换，但只允许类型之间存在合法转换关系（例如，父类与子类之间的转换）。它不能用于将完全不相关的指针类型相互转换（如 <code>int*</code> 转换为 <code>char*</code> ）。如果你需要进行这种不安全的转换，应该使用 <code>reinterpret_cast&lt;&gt;</code>。</p><ol start="3"><li><strong>类层次之间的转换</strong></li></ol><p><code>static_cast&lt;&gt;</code> 可以在类的继承层次结构中进行上下转换（即子类指针和父类指针之间的转换）。</p><ul><li><strong>从子类到父类的转换</strong> 是安全的，因为每个子类对象也都是父类对象，这种转换不需要特别的检查。</li><li><strong>从父类到子类的转换</strong> 可能存在危险，因为父类对象不一定包含子类的部分。为了保证程序的正确性，开发者在使用这种转换时应确保父类对象实际上是子类对象。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Animal* a = <span class="keyword">new</span> <span class="built_in">Dog</span>();           <span class="comment">// 安全的向上转换</span></span><br><span class="line">Dog* d = <span class="built_in">static_cast</span>&lt;Dog*&gt;(a);   <span class="comment">// 可能不安全的向下转换</span></span><br></pre></td></tr></table></figure><p>上面的代码中，向上转换（从子类 <code>Dog</code> 到父类 <code>Animal</code>）总是安全的；向下转换（从 <code>Animal*</code> 到 <code>Dog*</code>）只有在 <strong><code>a</code> 实际上指向 <code>Dog</code> 对象时才安全。</strong></p><ol start="4"><li><strong>避免隐式类型转换</strong></li></ol><p>有时候我们想要避免隐式类型转换所带来的困扰，例如当我们从 <code>int</code> 转换到 <code>float</code> 时，程序会自动完成转换。但如果你希望明确控制类型转换，可以使用 <code>static_cast&lt;&gt;</code> 来提高代码的可读性，并表明你有意识地进行类型转换。</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> y = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(x); <span class="comment">// 比直接写为 float y = x; 更加显式和清晰</span></span><br></pre></td></tr></table></figure><ol start="5"><li><strong>禁止不安全的转换</strong></li></ol><p>虽然 <code>static_cast&lt;&gt;</code> 能够进行一些比较灵活的转换，但它是有一些限制的，它不能做完全不安全的类型转换。例如，将两个完全不相关的类型（比如 <code>int*</code> 和 <code>float*</code>）之间相互转换是非法的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int* pInt = nullptr;</span><br><span class="line">float* pFloat = static_cast&lt;float*&gt;(pInt); // 错误：编译器会报错</span><br></pre></td></tr></table></figure><p>如果你需要进行这样不安全的转换，你应该使用 <code>reinterpret_cast&lt;&gt;</code>，不过通常这类转换可能隐藏较大的风险。</p><ol start="6"><li><strong>转换常量</strong></li></ol><p><code>static_cast&lt;&gt;</code> 不能移除对象的常量性（即不能去掉 <code>const</code> 限定符）。如果需要进行这种操作，需要使用 <code>const_cast&lt;&gt;</code>。<code>static_cast&lt;&gt;</code> 是一个更“安全”的转换，它只进行类型之间的转换，而不涉及对象的权限或常量性修改。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int a = 10;</span><br><span class="line">// int* p = static_cast&lt;int*&gt;(&amp;a); // 错误：不能通过static_cast移除const</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li><code>static_cast&lt;&gt;</code> 是一种编译时的类型转换方式。</li><li>它用于基本类型之间的转换、类继承体系中的上下转换、指针类型之间的转换等。</li><li>它在类型检查上比传统的强制类型转换更严格，但它<strong>并不进行运行时的类型安全检查，所以错误的转换在编译时不一定会被捕获。</strong></li><li><code>static_cast&lt;&gt;</code> 强调明确性和可读性，在进行数据类型转换时，能够减少潜在的隐式错误。</li></ul><p>你可以把 <code>static_cast&lt;&gt;</code> 理解为一种更安全、可控的类型转换工具，比传统的C风格转换更容易读懂，也更不容易出错。</p><h3 id="案例">案例</h3><img src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241009093102614.png" class="" title="image-20241009093102614"><p>这张PPT展示的是关于C++中使用 <code>static_cast&lt;&gt;</code> 进行类型转换的实验和结果。我们一步步详细解析里面的内容：</p><p><strong>左上角部分：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">123456789</span>;</span><br><span class="line"><span class="type">short</span> s = <span class="built_in">static_cast</span>&lt;<span class="type">short</span>&gt;(i);</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">int2B</span>(i) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">short2B</span>(s) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><ol><li><code>int i = 123456789;</code>：这是一个32位整数，其二进制形式如下：<ul><li>二进制: <code>000001110110111101111001101000101</code></li></ul></li><li><code>short s = static_cast&lt;short&gt;(i);</code>：将 <code>int</code> 类型的 <code>i</code> 转换成 <code>short</code> 类型。由于 <code>short</code> 是16位的，它无法容纳32位的整数。这个操作会丢弃高位，保留低16位，得到一个 <code>short</code> 类型的值：<ul><li>高位丢失后: <code>110011010010101</code></li><li>这实际上是 <code>-13035</code>，因为最左边是1，表示负数（采用二进制补码形式）。</li></ul></li></ol><p><strong>总结</strong>：从32位到16位的强制类型转换会导致数据截断（高位数据丢失），可能导致数值变化很大，如从正数变成负数。</p><p><strong>左中间部分：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;testing from int to float:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span> y = ~(<span class="number">1</span> &lt;&lt; <span class="number">23</span>);</span><br><span class="line"><span class="type">float</span> y1 = <span class="built_in">float</span>(y);</span><br></pre></td></tr></table></figure><p>这段代码测试从一个特殊的整数转换为浮点数的过程：</p><ol><li><p><strong><code>int y = ~(1 &lt;&lt; 23);</code></strong>:</p><ul><li>这段代码通过位运算生成了一个较大的负数。</li><li><code>1 &lt;&lt; 23</code> 表示将1左移23位，结果是：<code>100000000000000000000000</code>，即2的23次方。</li><li><code>~</code> 是按位取反操作，将这个数的所有位取反，即把高位1变成0，低位0变成1，得到的结果为：<code>-8388609</code>。</li></ul></li><li><p><strong>将 <code>y</code> 转换为 <code>float</code></strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> y1 = <span class="built_in">float</span>(y);</span><br></pre></td></tr></table></figure><ul><li>通过 <code>float(y)</code> 将 <code>int</code> 类型的 <code>y</code> 转换为 <code>float</code> 类型。</li><li>因为浮点数和整数的表示方式不同，特别是在处理较大数值时，可能会出现精度损失。这里 <code>-8388609</code> 转换为 <code>float</code> 后，它的精度可能会有所变化。</li></ul></li><li><p><strong>输出结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">testing from int to float:</span><br><span class="line">before : -8388609 11111111111111111111111111111111</span><br><span class="line">after  : -8388609 11001011010000000000000000000001</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><strong>整数表示</strong>：<code>-8388609</code> 的二进制表示为 <code>11111111111111111111111111111111</code>，是32位补码形式，表示负数。</li><li><strong>浮点数表示</strong>：<code>-8388609</code> 被转换为浮点数时，**虽然输出的值没有变化，但其二进制形式发生了变化。**浮点数的二进制形式遵循 IEEE 754 标准，由符号位、指数位和尾数位组成。由于浮点数存储精度的原因，特别是当整数的绝对值较大时，可能会发生精度损失。</li></ul></li><li><p><strong>总结：</strong></p><ol><li>整数转换为浮点数时，<strong>即使数值保持不变，其底层存储结构会发生较大的变化</strong>（从补码形式转变为浮点数的表示方式）。</li><li>此外，浮点数的存储可能会因精度问题丢失部分细节，尤其是在处理较大或较小的数字时。</li></ol></li></ol><p><strong>左下角部分：</strong></p><p>类似的测试再次执行，不过这次的整数 <code>y</code> 是 <code>~(1 &lt;&lt; 24)</code>，它会生成一个更大的负数 <code>-16777217</code>，再次验证了整数到浮点数转换时的精度损失。</p><p><strong>总结：</strong></p><ol><li>float尾数只有23位，他只能精确存储23位有效的二进制位。当一个数超出这个范围（如1&lt;&lt;24的24位）</li></ol><p><strong>右上角部分：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> f = <span class="number">1.25</span>;</span><br><span class="line"><span class="type">short</span> s = <span class="built_in">static_cast</span>&lt;<span class="type">short</span>&gt;(f);</span><br><span class="line">cout &lt;&lt; f &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">float2B</span>(f) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">short2B</span>(s) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>这段代码演示了将浮点数 <code>float</code> 转换为 <code>short</code> 类型：</p><ol><li><code>float f = 1.25;</code>：1.25 作为浮点数存储在内存中，浮点数的二进制表示较为复杂，这里使用IEEE 754标准来表示它。<ul><li><code>float</code> 的二进制形式: <code>00111111101000000000000000000000</code></li></ul></li><li><code>short s = static_cast&lt;short&gt;(f);</code>这里<code>float</code>转换为<code>short</code>，即将小数部分去除，只保留整数部分 1<ul><li><code>short</code> 的二进制形式: <code>0000000000000001</code></li></ul></li></ol><p><strong>总结</strong>：将 <code>float</code> 转换为 <code>short</code> 时，浮点数的小数部分被丢弃，只保留整数部分。</p><p><strong>右中间部分：</strong></p><p><strong>总结：</strong></p><ol><li><p><strong>浮点数 <code>7.25</code> 的二进制表示</strong>：浮点数在内存中是按照 IEEE 754 标准存储的，它的二进制形式相当复杂，包括符号位、指数位和尾数位。<code>7.25</code> 的二进制形式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01000000111010000000000000000000</span><br></pre></td></tr></table></figure></li><li><p><strong><code>float</code> 转换为 <code>short</code> 时的截断</strong>：当将浮点数 <code>7.25</code> 转换为 <code>short</code> 时，小数部分被截断，留下整数部分 <code>7</code>。<code>7</code> 的二进制表示为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000000000000111</span><br></pre></td></tr></table></figure></li><li><p><strong>类型转换中的截断</strong>：<code>static_cast&lt;short&gt;(f)</code> 将浮点数的精度降低，只保留整数部分，展示了数值类型之间的转换如何影响数据的表示方式。</p></li></ol><p><strong>右下角部分：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> s = <span class="number">45</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(s);</span><br></pre></td></tr></table></figure><p>这里测试了从 <code>short</code> 类型转换为 <code>float</code>：</p><ol><li><code>short s = 45;</code>：一个16位的短整型数 <code>45</code>。</li><li><code>float f = static_cast&lt;float&gt;(s);</code>：将 <code>short</code> 转换为 <code>float</code>，结果依然是45，因为45可以准确地表示为浮点数，不会有精度损失。</li></ol><p><strong>总结</strong>：对于较小的整数，转换为浮点数不会有精度问题。</p><p><strong>总结：</strong></p><p>PPT中的内容展示了 <code>static_cast</code> 类型转换在不同类型数据之间的效果，尤其是在 <code>int</code> 和 <code>float</code>，以及 <code>int</code> 和 <code>short</code> 之间的转换。需要注意的是：</p><ul><li><code>int</code> 转换为 <code>short</code> 可能会丢失高位数据，导致数值变化。</li><li><code>int</code> 转换为 <code>float</code> 时可能会因浮点数的精度（23位，十进制7位左右）限制导致精度损失。</li><li>小的整数转换为 <code>float</code> 不会出现问题，但较大的整数可能会受到浮点数精度的影响。</li></ul><h2 id="const-cast">const_cast</h2><p><code>const_cast&lt;&gt;</code> 专门用于<strong>移除或者添加对象的 <code>const</code> 或者 <code>volatile</code> 属性</strong>。<code>const_cast</code> 只能用于调整 <code>const</code> 和 <code>volatile</code> 属性，<strong>不能改变对象的实际类型。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">const_cast</span>&lt;new_type&gt;(expression)</span><br></pre></td></tr></table></figure><ul><li><strong><code>new_type</code></strong>：表示要转换成的新类型。通常是移除了 <code>const</code> 或者 <code>volatile</code> 限定符的类型。</li><li><strong><code>expression</code></strong>：表示要进行转换的表达式。</li></ul><p><strong>使用场景</strong>：</p><ol><li><strong>移除 <code>const</code> 限定符</strong>：<code>const_cast&lt;&gt;</code> 常用于将一个常量指针或引用转换为非常量（非 <code>const</code>）的类型，这样我们就可以修改本来是 <code>const</code> 的对象了。</li><li><strong>添加 <code>const</code> 限定符</strong>：虽然较少见，但 <code>const_cast&lt;&gt;</code> 也可以用来为非 <code>const</code> 的对象添加 <code>const</code> 限定符。</li></ol><p><strong>示例 1：移除 <code>const</code> 限定符</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span>* p)</span> </span>&#123;</span><br><span class="line">    *p = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">modify</span>(<span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;x));  <span class="comment">// 移除 const 限定符，使其可以被修改</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这个例子中，<code>x</code> 被声明为 <code>const int</code>，表示 <code>x</code> 是一个常量，不能被修改。</li><li>使用 <code>const_cast&lt;int*&gt;</code> 移除了 <code>const</code> 限定符后，我们将 <code>x</code> 传递给 <code>modify</code> 函数，在该函数中可以对 <code>x</code> 进行修改。</li></ul><p><strong>注意</strong>：修改一个 <code>const</code> 对象可能导致未定义行为。如果对象本来是 <code>const</code>，修改它的行为在标准中没有定义，通常是不可预测的。这个例子仅仅说明 <code>const_cast</code> 的工作原理。</p><p><strong>示例 2：添加 <code>const</code> 限定符</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* p)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">const_cast</span>&lt;<span class="type">const</span> <span class="type">int</span>*&gt;(&amp;y));  <span class="comment">// 将非const的指针转换为const指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这个例子中，<code>y</code> 是一个非常量整数，但我们使用 <code>const_cast</code> 将它转换为一个 <code>const int*</code>，这样就可以将其传递给接受 <code>const</code> 参数的 <code>print</code> 函数。</li></ul><p><strong>关键点：</strong></p><ol><li><strong>只能用于 <code>const</code> 和 <code>volatile</code> 的转换</strong>：<code>const_cast&lt;&gt;</code> 只能用于添加或移除 <code>const</code> 或 <code>volatile</code> 限定符，不能用于其他类型的转换。它不会影响对象的底层类型，也不会改变对象的值。</li><li><strong>避免未定义行为</strong>：尽管你可以通过 <code>const_cast</code> 移除 <code>const</code>，但如果你修改的是一个本来声明为 <code>const</code> 的对象，这种行为是 <strong>未定义行为</strong>，尽量避免这种操作。</li><li><strong>不进行其他类型的转换</strong>：<code>const_cast&lt;&gt;</code> 不能用于将 <code>int</code> 类型转换为 <code>float</code> 或者进行指针的重新解释（这是 <code>reinterpret_cast&lt;&gt;</code> 的作用）。它只能处理与 <code>const</code> 或 <code>volatile</code> 有关的限定符。</li></ol><p><strong>示例 3：移除 <code>volatile</code> 限定符</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>* p)</span> </span>&#123;</span><br><span class="line">    *p = <span class="number">100</span>;  <span class="comment">// 修改变量的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> z = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">func</span>(<span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;z));  <span class="comment">// 移除 volatile 限定符后对 z 进行修改</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>z</code> 被声明为 <code>volatile</code>，表示编译器不能对其进行优化，但通过 <code>const_cast</code>，我们可以移除 <code>volatile</code> 限定符并修改它。</li></ul><p><strong>常见的应用场景：</strong></p><ol><li><strong>接口设计</strong>：有时候你可能拥有一个只能返回 <code>const</code> 类型指针的接口，但实际使用中你希望能够修改它。这时可以使用 <code>const_cast</code> 来移除 <code>const</code> 限定符，达到修改的目的。</li><li><strong>遗留代码兼容</strong>：在需要兼容一些旧代码时，你可能遇到非 <code>const</code> 的 API，但你需要强制转换成 <code>const</code> 类型，这时也可以使用 <code>const_cast</code>。</li></ol><p><strong>总结：</strong></p><ul><li><strong><code>const_cast&lt;&gt;</code> 主要用于移除或者添加 <code>const</code> 和 <code>volatile</code> 限定符</strong>，不能用于其他类型的转换。</li><li><strong>使用 <code>const_cast&lt;&gt;</code> 修改常量对象可能会导致未定义行为</strong>，要谨慎使用。</li><li>它是 C++ 类型转换家族中一种非常有针对性的转换操作符，只处理类型的 <code>const</code> 和 <code>volatile</code> 限定符。</li></ul><h2 id="reinterpret-cast">reinterpret_cast</h2><p><code>reinterpret_cast&lt;&gt;</code> 是 C++ 中的一种类型转换操作符，它用于 <strong>强制重新解释</strong> 一个指针、引用或类型的位模式，而不改变位模式本身的内容。<code>reinterpret_cast&lt;&gt;</code> 是 C++ 中<strong>最危险的类型转换操作符之一</strong>，因为它允许几乎任意类型之间的转换，因此需要格外小心使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reinterpret_cast</span>&lt;new_type&gt;(expression)</span><br></pre></td></tr></table></figure><ul><li><strong><code>new_type</code></strong>：转换后的新类型，可以是指针、引用或其他类型。</li><li><strong><code>expression</code></strong>：要转换的对象，它的类型将被强制重新解释为 <code>new_type</code>。</li></ul><p><strong>使用场景</strong>：</p><p><code>reinterpret_cast&lt;&gt;</code> 通常用于两种情况下：</p><ol><li><strong>指针类型之间的转换</strong>：它可以将一个指针转换为其他不相关类型的指针（例如，将 <code>int*</code> 转换为 <code>float*</code>），即使这两个类型在内存中的位模式不同。它不会对数据进行任何修改，只是简单地重新解释内存中的位模式。</li><li><strong>整数和指针之间的转换</strong>：它可以在整数类型和指针类型之间进行转换。</li></ol><p><strong>行为</strong>：</p><ul><li>它不会改变数据本身的内容，只是将它的类型信息进行了强制转换。你可以将一块内存从一种类型转换成另一种类型进行访问。</li><li>它可以用于指针之间的转换，也可以用于整数与指针之间的转换。</li><li><code>reinterpret_cast&lt;&gt;</code> <strong>不会</strong>执行任何类型检查或者类型安全性验证，因此需要非常小心使用，错误的使用可能导致运行时错误或者未定义行为。</li></ul><p><strong>示例 1：指针类型之间的转换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">float</span> *f = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">float</span>*&gt;(&amp;i);</span><br><span class="line">std::cout &lt;&lt; *f &lt;&lt; std::endl; <span class="comment">// 输出的是reinterpret后的浮点数解释，而不是42</span></span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>int</code> 类型的变量 <code>i</code> 被转换为指向 <code>float</code> 的指针 <code>f</code>。</li><li>当我们通过 <code>*f</code> 访问内存时，内存中的位模式被重新解释为浮点数，这样就输出了一个与 <code>42</code> 无关的浮点数值。</li></ul><p><strong>注意</strong>：这个操作很危险，因为 <code>int</code> 和 <code>float</code> 在内存中的表示方式是不同的。这种转换是低级的强制解释内存的操作，可能导致不可预见的结果。</p><p><strong>示例 2：整数和指针之间的转换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span>* ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;x); <span class="comment">// 将int指针转换为void指针</span></span><br><span class="line"><span class="type">int</span>* p = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(ptr);    <span class="comment">// 将void指针再转换为int指针</span></span><br><span class="line">std::cout &lt;&lt; *p &lt;&lt; std::endl;            <span class="comment">// 输出 10</span></span><br></pre></td></tr></table></figure><ul><li>在这个例子中，<code>reinterpret_cast&lt;&gt;</code> 被用来将一个 <code>int*</code> 转换为 <code>void*</code>，然后再将 <code>void*</code> 转换回 <code>int*</code>。</li><li>这是一种常见的用法，尤其是在需要进行低级别的内存操作时。</li></ul><p><strong>示例 3：类指针之间的转换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Base* b = <span class="keyword">new</span> Base;</span><br><span class="line">Derived* d = <span class="built_in">reinterpret_cast</span>&lt;Derived*&gt;(b);</span><br></pre></td></tr></table></figure><ul><li>在这个例子中，<code>Base*</code> 类型的指针 <code>b</code> 被强制转换为 <code>Derived*</code> 类型的指针 <code>d</code>。这种转换没有检查 <code>b</code> 是否实际上指向一个 <code>Derived</code> 类型的对象，这可能导致后续的运行时错误。</li><li>如果 <code>d</code> 被用于访问 <code>Derived</code> 的特定成员，结果可能是未定义行为。</li></ul><p><strong>示例 4：与 <code>const_cast&lt;&gt;</code> 和 <code>static_cast&lt;&gt;</code> 的对比</strong></p><ul><li><p><strong><code>static_cast&lt;&gt;</code></strong>：用于安全的、编译时检查的类型转换，例如父类与子类之间的转换。它会确保类型之间有一定的关系。</p></li><li><p><strong><code>const_cast&lt;&gt;</code></strong>：用于移除或添加 <code>const</code> 或 <code>volatile</code> 限定符，不能改变类型本身。</p></li><li><p><strong><code>reinterpret_cast&lt;&gt;</code></strong>：是最危险的转换操作符，允许你几乎将任何类型强制转换为任何其他类型，但它不会检查类型是否兼容，因此可能导致严重的未定义行为。</p></li><li><p><code>reinterpret_cast&lt;&gt;</code> 不能用于类型之间的跨越式转换，例如从浮点数转换为整数。要做到这种转换，需要使用 <code>static_cast&lt;&gt;</code> 或者先进行其他转换操作。</p></li><li><p>它的效果取决于底层平台和编译器的实现，因此在不同的系统中表现可能不一致，特别是在跨平台开发中。</p></li></ul><p><strong>总结：</strong></p><ul><li><strong><code>reinterpret_cast&lt;&gt;</code></strong> 是 C++ 中用于强制类型转换的工具，允许你将一个类型重新解释为另一种不相关的类型，但它不会进行类型安全检查。</li><li>它最常用于指针之间的转换，或在需要与底层内存直接交互时使用（如设备驱动程序、操作系统开发等场景）。</li><li><strong>使用时需格外小心</strong>，因为错误的使用会导致未定义行为，破坏内存，或者导致程序崩溃。</li></ul><h3 id="案例-2">案例</h3><img src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241009144538021.png" class="" title="image-20241009144538021"><p><strong>右上方</strong></p><p>这个好理解，不赘述了</p><p><strong>右下方</strong></p><p>这里通过<code>const&lt;cast&gt;</code>去掉了c的const属性，通过*q修改了<code>const int c</code>的值，是UB行为。</p><p><strong>结果分析：</strong></p><ul><li>在内存中，<code>c</code> 的值被修改为 111（通过 <code>q</code> 指针），但直接访问 <code>c</code> 时，仍然显示原来的 128。这种行为是由于编译器对 <code>const</code> 对象的优化导致的未定义行为。尽管通过 <code>q</code> 可以修改 <code>c</code> 的值，但从 <code>c</code> 本身来访问时可能无法看到修改结果。</li><li><strong>为什么 <code>*q</code> 是 111？</strong>：<code>*q</code> 是 111，因为我们通过 <code>const_cast&lt;&gt;</code> 修改了 <code>c</code> 的值。然而，这种操作在标准中是未定义行为，不能保证所有平台都表现一致。</li></ul><h1>C3</h1><h2 id="dynamic-cast">dynamic_cast</h2><p><code>dynamic_cast</code> 是 C++ 中的一种类型转换操作符，专门用于在继承体系中进行 <strong>安全的向下转换（downcasting）</strong>。与 <code>static_cast</code> 相比，<code>dynamic_cast</code> 会在运行时检查类型的转换是否安全，确保类型之间的转换是合法的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic_cast</span>&lt;new_type&gt;(expression)</span><br></pre></td></tr></table></figure><ul><li><strong><code>new_type</code></strong>：目标类型，通常是指针类型或者引用类型，必须是从某个基类到派生类的转换。</li><li><strong><code>expression</code></strong>：要进行转换的表达式，通常是一个指向基类对象的指针或者引用。</li></ul><p><strong>1.2 使用场景</strong></p><p><code>dynamic_cast</code> 主要用于 <strong>多态类型</strong>，即在<strong>有虚函数</strong>的类体系中，用于从基类指针或引用<strong>向下转换</strong>到派生类指针或引用。它会在运行时检查类型是否正确。</p><p><strong>1.3 示例：向下转换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello from Derived!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();  <span class="comment">// 基类指针指向派生类对象</span></span><br><span class="line">    Derived* derivedPtr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);  <span class="comment">// 向下转换</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (derivedPtr) &#123;</span><br><span class="line">        derivedPtr-&gt;<span class="built_in">sayHello</span>();  <span class="comment">// 安全调用派生类方法</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Conversion failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><strong><code>Base* basePtr = new Derived();</code></strong>：一个基类指针指向派生类对象。这是一个 <strong>向上转换（upcasting）</strong>，总是安全的。</li><li><strong><code>Derived* derivedPtr = dynamic_cast&lt;Derived*&gt;(basePtr);</code></strong>：尝试将基类指针转换为派生类指针。这个操作只有在运行时确认 <code>basePtr</code> 实际上指向的是 <code>Derived</code> 类型的对象时才成功，否则会返回 <code>nullptr</code>。</li><li><strong>运行时类型检查</strong>：如果转换成功，可以安全地使用 <code>derivedPtr</code> 调用派生类特有的方法。如果转换失败，<code>derivedPtr</code> 将为 <code>nullptr</code>，以避免访问无效对象。</li></ul><p><strong>1.4 动态转换失败</strong></p><p>当使用 <code>dynamic_cast</code> 进行向下转换时，如果对象的实际类型与目标类型不匹配，<code>dynamic_cast</code> 将返回 <code>nullptr</code>（对于指针类型）或抛出 <code>std::bad_cast</code> 异常（对于引用类型）。</p><p><strong>1.5 需要虚函数</strong></p><p>为了能够使用 <code>dynamic_cast</code> 进行向下转换，<strong>基类中必须包含至少一个 虚函数（<code>virtual</code></strong>）。这是因为 <code>dynamic_cast</code> <strong>依赖于运行时类型信息（RTTI），而 RTTI 只有在类包含虚函数时才会生成。</strong></p><p><code>virtual</code> 是 C++ 中用于定义 <strong>虚函数</strong> 的关键字，它是实现 <strong>多态性</strong> 的核心机制之一。虚函数允许派生类<strong>重写</strong>基类的方法，并通过基类指针或引用调用派生类的方法。</p><h2 id="virtual">virtual</h2><p><strong>2.1 虚函数的作用</strong></p><p>当一个基类中的方法被声明为虚函数时，即使使用基类指针或引用调用该方法，C++ 仍然会根据对象的实际类型决定调用哪个版本的方法。这种行为称为 <strong>动态绑定</strong>，是多态性的一种体现。</p><p><strong>2.2 基本语法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;  <span class="comment">// 重写虚函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>2.3 使用虚函数实现多态性</strong></p><p>当基类的函数被声明为虚函数时，派生类可以重写该函数。即使通过基类指针调用该函数，实际运行时将会调用派生类中重写的函数，这就是 <strong>多态性</strong> 的核心。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">basePtr-&gt;<span class="built_in">show</span>();  <span class="comment">// 输出: &quot;Derived class&quot;</span></span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><code>show()</code> 被声明为虚函数，因此当 <code>basePtr</code> 指向派生类对象时，即使使用基类指针调用 <code>show()</code>，它仍然会调用 <code>Derived</code> 类中的 <code>show()</code> 函数。</li></ul><p><strong>2.4 纯虚函数（抽象类）</strong></p><p>你可以将虚函数声明为 <strong>纯虚函数</strong>，这会使得类变为<strong>抽象类</strong>，无法实例化。纯虚函数的作用是强制派生类提供自己的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>2.5 虚析构函数</strong></p><p><strong>如果一个类中包含虚函数，那么它的析构函数也应该是虚的</strong>。这是为了确保通过基类指针删除对象时能够正确调用派生类的析构函数，防止内存泄漏。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() <span class="keyword">override</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"><span class="keyword">delete</span> basePtr;  <span class="comment">// 调用Derived和Base的析构函数</span></span><br></pre></td></tr></table></figure><p><strong>3. <code>dynamic_cast</code> 和 <code>virtual</code> 的关系</strong></p><ul><li><code>dynamic_cast</code> 依赖于虚函数表（vtable）和运行时类型信息（RTTI），而这些信息只有在类中存在虚函数时才会生成。</li><li><strong>没有虚函数的类不能使用 <code>dynamic_cast</code> 进行安全的向下转换。</strong></li><li><code>virtual</code> 关键字定义了虚函数，使得派生类能够重写基类的函数，<code>dynamic_cast</code> 则用于在运行时安全地判断对象的实际类型，并进行转换。</li></ul><p><strong>4. <code>dynamic_cast</code> 和 <code>static_cast</code> 的对比</strong></p><ul><li><strong><code>dynamic_cast&lt;&gt;</code></strong>：只能用于有虚函数的多态类型，用于在运行时安全地进行向下转换。如果转换失败，返回 <code>nullptr</code>（指针）或抛出异常（引用）。</li><li><strong><code>static_cast&lt;&gt;</code></strong>：用于编译时的类型转换，不进行运行时类型检查，适用于父类和子类之间的转换。如果类型不匹配，转换结果可能会出错或导致未定义行为。</li></ul><p><strong>总结：</strong></p><ul><li><strong><code>virtual</code> 关键字</strong> 用于声明虚函数，是实现多态性和动态绑定的核心机制。</li><li><strong><code>dynamic_cast</code></strong> 是用于运行时安全类型转换的操作符，依赖于虚函数表（vtable）和运行时类型信息（RTTI），用于基类和派生类之间的向下转换。</li><li>虚函数使得派生类可以重写基类的方法，而通过基类指针或引用调用虚函数时，会根据对象的实际类型来决定调用哪个函数。这使得 <code>dynamic_cast</code> 在判断类型时能够安全地进行转换。</li></ul><h3 id="案例-3">案例</h3><img src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241009151028768.png" class="" title="image-20241009151028768"><ul><li>注意，这里PPT是有误解的</li></ul><p><strong>对于左侧，都是F都是没有virtual修饰的</strong></p><p><strong>左1代码father：</strong></p><p>注意：此时父类F是没有virtual修饰的，即不是虚函数，virtual是后面动画加上去的</p><ul><li>在这段代码中，<strong><code>foo()</code> 不是虚函数</strong>，所以它的调用是<strong>静态绑定</strong>的。</li><li>在 <code>F* obj = new S1();</code> 这行代码中，<code>obj</code> 是一个指向 <code>F</code> 类的指针，尽管它指向 <code>S1</code> 的对象，<strong>但由于 <code>foo()</code> 是 <code>F</code> 类中的非虚函数，编译器在编译时就决定了调用 <code>F::foo()</code>，输出的是 <code>&quot;father&quot;</code>。</strong></li></ul><p><strong>左2代码son1</strong></p><p><strong>左3代码unsafe</strong></p><p>会导致UB</p><p><strong>左4代码compile error</strong></p><p><code>F* obj = new S1;</code></p><ul><li>这里，<code>obj</code> 是一个指向 <code>S1</code> 类型对象的基类指针 <code>F*</code>。它实际上指向的是 <code>S1</code> 类的实例。</li></ul><p><code>dynamic_cast&lt;S1*&gt;(obj)</code></p><ul><li>使用 <code>dynamic_cast&lt;&gt;</code> 进行类型转换。与 <code>static_cast&lt;&gt;</code> 不同，<code>dynamic_cast&lt;&gt;</code> 会在运行时进行类型检查，以确保类型转换的安全性。</li><li>由于 <code>dynamic_cast&lt;&gt;</code> 是针对 <strong>多态类型</strong> 设计的（即有虚函数的类），所以它依赖于虚函数表（vtable）来判断对象的实际类型。</li><li>如果 <code>F</code> 中没有虚函数，使用 <code>dynamic_cast&lt;&gt;</code> 进行类型转换会<strong>导致编译错误</strong>。也就是说，<strong><code>dynamic_cast&lt;&gt;</code> 只能应用于具有虚函数的类</strong>。如果基类没有虚函数，编译器无法判断派生类的类型，转换会失败。</li></ul><p><strong>3. 编译错误的原因</strong></p><ul><li>如果 <code>F</code> 类中<strong>没有声明任何虚函数，那么 <code>dynamic_cast&lt;&gt;</code> 将无法使用</strong>，因为没有虚函数表可以供 <code>dynamic_cast&lt;&gt;</code> 在运行时检查类型。编译器会直接报错，提示无法进行转换。</li></ul><p><strong>总结：</strong></p><p>注意，对于左4的compile error，错误原因不是因为调用的foo函数没有加virtual，本质原因是F中没有声明虚函数。比如如下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">F</span></span><br><span class="line">&#123;  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;father&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">F</span>()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F* obj = <span class="keyword">new</span> S1;</span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;S1*&gt;(obj)-&gt;<span class="built_in">foo</span>();</span><br></pre></td></tr></table></figure><ul><li>此时输出Son1，就是正确的</li></ul><p><strong>对于右侧，与PPT一样，都是有virtual修饰的</strong></p><p><strong>右2代码</strong></p><p><code>F* obj = new F; dynamic_cast&lt;S1*&gt;(obj)-&gt;foo();</code></p><ul><li>在这个例子中，<code>obj</code> 实际上指向的是一个 <code>F</code> 对象，而我们尝试将其转换为 <code>S1*</code>。</li><li>由于 <code>obj</code> 并不是 <code>S1</code> 类型的对象，<code>dynamic_cast&lt;&gt;</code> 会失败，并返回 <code>nullptr</code>。因此，调用 <code>-&gt;foo()</code> 会抛出异常或导致程序崩溃。</li><li><strong>这表明 <code>dynamic_cast&lt;&gt;</code> 提供了运行时的安全检查，避免了像 <code>static_cast&lt;&gt;</code> 那样的未定义行为。</strong></li></ul><h2 id="auto">auto</h2><ul><li>自动推导类型，根据表达式进行推导，即auto x = 10，那么根据10，推导x的类型为int</li></ul><h2 id="decltype">decltype</h2><p><strong>基本语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(expression)</span><br></pre></td></tr></table></figure><ul><li><strong><code>expression</code></strong>：这是一个有效的C++表达式，**<code>decltype</code> 将根据这个表达式的类型（即expression的类型）**来推导出返回值的类型。</li></ul><p><strong>示例 1：基本使用</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x) y = <span class="number">20</span>;  <span class="comment">// y 的类型是 int，因为 x 的类型是 int</span></span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>x</code> 是 <code>int</code> 类型的变量，<code>decltype(x)</code> 也返回 <code>int</code>，所以 <code>y</code> 也被推导为 <code>int</code> 类型。</li></ul><p><strong>示例 2：推导引用类型</strong></p><p>如果表达式是一个引用，<code>decltype</code> 会推导出引用类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = x;</span><br><span class="line"><span class="keyword">decltype</span>(ref) y = x;  <span class="comment">// y 的类型是 int&amp;（引用类型），因为 ref 是 int&amp;</span></span><br><span class="line">y = <span class="number">20</span>;</span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; std::endl;  <span class="comment">// 输出 20，y 实际上是 x 的引用</span></span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>ref</code> 是 <code>int&amp;</code> 类型（对 <code>x</code> 的引用）。</li><li><code>decltype(ref)</code> 返回 <code>int&amp;</code>，因此 <code>y</code> 也是 <code>int&amp;</code> 类型，即 <code>y</code> 成为 <code>x</code> 的引用。</li></ul><p><strong>示例 3：推导复杂表达式的类型</strong></p><p><code>decltype</code> 的强大之处在于它可以<strong>推导出复杂表达式的类型</strong>，而不仅仅是变量的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x + y) z = <span class="number">30</span>;  <span class="comment">// z 的类型是 int，推导自 x + y 的类型</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>x + y</code> 是 <code>int</code> 类型的加法运算结果，因此 <code>decltype(x + y)</code> 的类型是 <code>int</code>，推导出的 <code>z</code> 也是 <code>int</code> 类型。</p><p><strong><code>decltype</code> 与 <code>auto</code> 的区别：</strong></p><ul><li><strong><code>auto</code></strong> 关键字用来根据初始化表达式来推导变量的类型。</li><li><strong><code>decltype</code></strong> 关键字用来推导一个表达式的类型，而不进行任何赋值或初始化操作。<code>decltype</code> 能保留变量的引用性、常量性等属性。</li></ul><h2 id="Range-for">Range-for</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : vec) &#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要避免元素拷贝，或是想修改容器中的元素，可以使用<strong>引用 int&amp;</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : vec) &#123;</span><br><span class="line">    i += <span class="number">1</span>;  <span class="comment">// 修改容器内的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Uniform-Initialization">Uniform Initialization</h2><p>统一初始化是 C++11 引入的新特性，允许我们使用大括号 <code>&#123;&#125;</code> 来初始化变量。它适用于<strong>内置类型</strong>和<strong>用户定义类型</strong>，提供了更加一致的初始化语法，解决了传统构造函数初始化和 <code>=</code> 初始化的混淆。</p><p><strong>传统初始化：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">7</span>, <span class="number">8</span>&#125;;    <span class="comment">// OK</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">7</span>, <span class="number">8</span>&#125;; <span class="comment">// 编译失败（旧版本中不支持）</span></span><br></pre></td></tr></table></figure><p><strong>统一初始化：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">7</span>, <span class="number">8</span>&#125;;    <span class="comment">// OK</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">7</span>, <span class="number">8</span>&#125;;   <span class="comment">// OK，在C++11中可以使用大括号进行初始化</span></span><br></pre></td></tr></table></figure><ul><li><strong>统一初始化的好处</strong>：不仅可以用于内置类型，也可以用于类对象的初始化。它使初始化更加直观且不易出错。</li><li>这种方式避免了传统C++中使用构造函数、拷贝初始化等不同初始化方式带来的歧义。</li></ul><h3 id="案例-4">案例</h3><img src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241009184655638.png" class="" title="image-20241009184655638"><p>对于其中的Uniform Intialization部分的vector初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">7</span>, <span class="number">8</span>&#125;;                <span class="comment">// OK</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">7</span>, <span class="number">8</span>&#125;;          <span class="comment">// should work (obviously, but it did not)</span></span><br></pre></td></tr></table></figure><p>这段代码的注释中提到：这看起来应该是可行的（“should work”），但却没有工作。问题是，为什么 <code>vector&lt;int&gt; v = &#123;7, 8&#125;;</code> 不像数组那样成功初始化呢？</p><p>在 <strong>C++11 之前</strong>，使用 <code>&#123;&#125;</code> 大括号直接初始化 <code>std::vector</code> 会引发问题，甚至会导致编译错误。这是因为：</p><ul><li>在早期的 C++ 标准中，<strong>容器类如 <code>std::vector</code> 的初始化主要依赖于构造函数</strong>，而大括号 <code>&#123;&#125;</code> 初始化并未用于用户定义类型。</li><li><code>std::vector</code> 的初始化方式依赖于构造函数，<strong>例如 <code>vector&lt;int&gt; v(2, 10);</code> 会初始化一个大小为2，所有元素值为10的 <code>vector</code></strong>。使用 <code>&#123;&#125;</code> 初始化的语法是新标准引入的特性，而非传统的构造函数调用。</li></ul><p>在 <strong>C++11 中，引入了统一初始化规则</strong>，使得大括号 <code>&#123;&#125;</code> 可以用于初始化标准库中的容器，如 <code>std::vector</code>。实际上，<code>vector&lt;int&gt; v = &#123;7, 8&#125;;</code> 是合法的，它使用了 <code>std::initializer_list</code> 特性来初始化 <code>std::vector</code>。</p><p><code>std::initializer_list</code> 是 C++11 引入的一个模板类，允许你通过大括号 <code>&#123;&#125;</code> 初始化容器，如 <code>std::vector</code> 和 <code>std::array</code>。这使得初始化容器的方式与初始化内置数组的方式更加一致。</p><p>注释 “should work (obviously, but it did not)” 表达了旧版本编译器可能不支持此特性的情况。在支持 C++11 的现代编译器中，这种初始化是完全合法的。</p><p>其中<code>vector&lt;int&gt; a&#123;1,2&#125;</code>和<code>vector&lt;int&gt; a = &#123;1,2&#125;</code>是等价的，都可以，数组也是</p><h2 id="Union">Union</h2><p><code>union</code> 是C++中一种特殊的结构，它<strong>允许多个成员变量共享同一块内存</strong>。<code>union</code> 中的所有成员都占用同一个内存空间，但<strong>一次只能保存一个成员的值</strong>。也就是说，<strong>在一个 <code>union</code> 中，当一个成员被赋值时，其他成员的值都会被覆盖，因为它们共享相同的内存空间。</strong></p><p><code>union</code> 占用的内存大小等于其所有成员中<strong>占用内存最大的成员</strong>的大小。因此，在任何时刻，<code>union</code> 只能存储其中的一个成员。</p><h3 id="案例-5">案例</h3><img src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241009190014846.png" class="" title="image-20241009190014846"><p>上半部分代码：尝试将浮点数 <code>f</code> 的位表示转换为二进制字符串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">float2B</span><span class="params">(<span class="type">float</span> f)</span> </span>&#123;</span><br><span class="line">    std::string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        s += (f &amp; (<span class="number">1</span> &lt;&lt; i)) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码标红色问号的地方是有问题的， <code>f &amp; (1 &lt;&lt; i)</code> 处会报错：<code>error: invalid operands of types 'float' and 'int' to binary 'operator&amp;'</code></p><ul><li><strong><code>float</code> 类型的位运算问题</strong>：<code>float</code> 是一种浮点数，而位运算符（如 <code>&amp;</code> 和 <code>&lt;&lt;</code>）通常只适用于整型数据（如 <code>int</code>、<code>long</code> 等）。<strong>直接对浮点数 <code>f</code> 执行位运算是非法的</strong>，因为 <code>float</code> 类型不是按位存储整数值，而是遵循 IEEE 754 标准存储二进制浮点数（即包括符号位、指数位和尾数位）。</li><li><strong>如何解决这个问题？</strong> 为了对浮点数进行位操作，我们需要找到一种方法，将浮点数的<strong>位表示</strong>解释为整型，然后才能进行按位操作。</li></ul><p><strong>下半部分代码（使用 <code>union</code>）：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">float2B</span><span class="params">(<span class="type">float</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">float</span> f;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">    &#125; u;</span><br><span class="line">    </span><br><span class="line">    u.f = f;</span><br><span class="line">    std::string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        s += (u.i &amp; (<span class="number">1</span> &lt;&lt; i)) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>union</code> 来解决浮点数和整型之间的类型转换问题。</p><p><strong><code>union</code> 的作用</strong>：<code>union</code> 定义了两个成员：<code>float f</code> 和 <code>int i</code>，它们共享同一块内存。这意味着当你对 <code>u.f</code> 赋值时，<code>u.i</code> 也能反映这块内存的二进制表示，但以 <code>int</code> 类型来解释。也就是说，当我们给 <code>u.f</code> 赋值一个浮点数 <code>f</code> 时，<strong><code>u.i</code> 会包含 <code>f</code> 的位级表示（即浮点数在内存中的 32 位表示，但解释为整数）。</strong></p><p><code>u.f=f</code>：由于 <code>f</code> 和 <code>i</code> 共用内存，现在 <code>u.i</code> 实际上包含了 <code>f</code> 的 32 位二进制表示</p><p>现在即可用u.i来进行按位运算了</p><img src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241009191109053.png" class="" title="image-20241009191109053"><p><strong>内存共享</strong>：在 <code>union</code> 中，多个成员共用同一段内存。在这个例子中，无论你通过结构体的方式（<code>_a11</code>, <code>_a12</code>, 等）还是通过数组的方式（<code>_element[0][0]</code>, <code>_element[1][1]</code>，等）来访问数据，访问的都是同一段内存。</p><p>因此，当你对 <code>m._a11</code> 赋值时，实际上也影响了 <code>m._element[0][0]</code>，因为它们指向的是同一块内存。</p><img src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241009191315771.png" class="" title="image-20241009191315771"><ul><li>FIGURE_TYPE，Line，Rectangle，Ellipse共享同一个union</li></ul><img src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241009195029523.png" class="" title="image-20241009195029523"><ul><li>最上方的绿色图的每一行即为union相同的空间内存放的变量</li><li>比如<strong>line.t</strong>, <strong>rect.t</strong>, <strong>ellipse.t</strong>, 和 <strong>t</strong> 占据的是同一块内存空间。这表示 <strong><code>line.t</code>、<code>rect.t</code>、<code>ellipse.t</code> 和 <code>union FIGURE</code> 中的 <code>t</code> 共享同一个 4 字节的存储位置</strong>。无论是 <code>line</code> 的类型字段、<code>rect</code> 的类型字段，还是 <code>ellipse</code> 的类型字段，它们都映射到 <code>union</code> 中的 <code>t</code>。</li></ul><img src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241009195403085.png" class="" title="image-20241009195403085"><ul><li><p>这张PPT的重点是通过 <strong><code>union</code></strong> 实现的简单 <strong>“多态性”（polymorphism）</strong>，</p></li><li><p><strong>多态性</strong>：尽管这不是传统的面向对象编程中的多态（通过虚函数实现的动态绑定），但这也是一种简单的“多态性”，即程序可以根据图形的类型 <code>t</code> 来决定调用哪个绘制函数。这种方式依赖于 <code>switch</code> 语句和枚举类型。<strong>图形的类型判断</strong>：程序通过检查 <code>figure.t</code> 来知道 <code>union</code> 中当前存储的是什么类型的图形（直线、矩形或圆形）。</p></li></ul><img src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241009195944336.png" class="" title="image-20241009195944336"><ul><li>类似的延伸，把color和width也作为共享的部分。即在设置FIGURE figure; figure.line = {xxx}后，figure本身的t，color和width也被设定</li></ul><h1>C4</h1><h2 id="struct">struct</h2><h3 id="alignment">alignment</h3><p><strong>对齐（alignment）</strong> 是指数据在内存中的存储地址必须是某个类型的对齐要求的倍数。不同的数据类型有不同的对齐要求。例如：</p><ul><li><code>char</code> 通常对齐到 1 字节（因为 <code>char</code> 通常只占 1 字节）。</li><li><code>short</code> 通常对齐到 2 字节。</li><li><code>int</code> 和 <code>float</code> 通常对齐到 4 字节。</li></ul><p>现代处理器通常要求数据以某种对齐方式存储，以提高读取内存的效率。如果数据没有正确对齐，处理器可能需要执行多次内存访问，导致性能下降。因此，<strong>编译器会在必要时在数据之间插入填充字节（padding）以确保数据对齐到正确的内存地址。</strong></p><p><strong>结构体的对齐规则</strong></p><p><strong>规则1：每个成员的地址必须是该成员类型的对齐要求的倍数</strong></p><ul><li>例如，如果一个 <code>int</code> 类型的成员需要 4 字节对齐，它的起始地址必须是 4 的倍数。如果它前面是一个占 1 字节的 <code>char</code> 类型成员，编译器会插入 3 个填充字节来确保 <code>int</code> 成员的地址是 4 的倍数。</li></ul><p><strong>规则2：结构体的整体大小必须是其最大对齐要求的倍数</strong></p><ul><li>例如，如果结构体中最大的对齐需求是 4 字节，那么整个结构体的大小也必须是 4 的倍数。如果结构体的总大小不能被 4 整除，编译器会在结构体的末尾插入填充字节，使其大小符合要求。</li></ul><p><strong>规则3：成员顺序影响结构体的对齐和大小</strong></p><ul><li>如果结构体中的小类型（如 <code>char</code>）放在大类型（如 <code>int</code>）前面，可能会导致大量的填充字节，从而增加结构体的整体大小。</li></ul><p><strong>示例：有填充的结构体</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">char</span> c;    <span class="comment">// 1字节，1字节对齐</span></span><br><span class="line">    <span class="type">short</span> s;   <span class="comment">// 2字节，2字节对齐</span></span><br><span class="line">    <span class="type">int</span> i;     <span class="comment">// 4字节，4字节对齐</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>char</code> 占 1 字节，需要 1 字节对齐。</li><li><code>short</code> 占 2 字节，需要 2 字节对齐，但在 <code>char</code> 后需要 1 字节的填充。</li><li><code>int</code> 需要 4 字节对齐，紧跟在 <code>short</code> 之后。</li></ul><p>内存布局如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| c (1字节) | padding (1字节) | s (2字节) | i (4字节) |</span><br></pre></td></tr></table></figure><h3 id="Padding">Padding</h3><ul><li>为了确保结构体成员按对齐要求存储在内存中，编译器插入的填充字节</li></ul><h3 id="Little-Endian">Little Endian</h3><p>Little Endian （小端序）是一种内存存储方式，在这种方式下，数据的<strong>低字节存储在低地址，而高字节存储在高地址。</strong></p><h3 id="案例-6">案例</h3><img src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241009200900213.png" class="" title="image-20241009200900213"><p>其中红框标记的地方即为padding</p><p>虽然结构体A,B存储的数据一样，但是因为成员顺序不同，B中添加了更多的padding，同时占的内存空间也变大了</p><p>其中数据的存储使用little endian小端序，数据的低字节存储在低地址，而高字节存储在高地址。（即反着排）</p><p>比如<code>B</code> 的 <code>int i = 259</code>，其二进制表示为：<code>00000000 00000000 00000001 00000011</code></p><p>在小端序系统中，低位字节（00000011）存储在内存的低地址，而高位字节（00000001）存储在高地址。因此在PPT中结构体B的第二行，可以看到以小端序方式存储的数据。</p><img src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241009205748950.png" class="" title="image-20241009205748950"><p><strong>用于打印q的前n个字节</strong></p><p>比如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">259</span>;</span><br><span class="line"><span class="built_in">showBytes</span>(&amp;x, <span class="built_in">sizeof</span>(x));</span><br></pre></td></tr></table></figure><p><strong>绿色记框中的扩展功能</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; hex &lt;&lt; (<span class="type">int</span>)*(p + i) &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line"><span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">4</span> == <span class="number">0</span>) cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><strong>功能：</strong></p><ul><li>这个扩展功能将内存中的字节值输出为 <strong>十六进制</strong> 格式，并且每四个字节换行输出。</li></ul><p><strong>工作原理：</strong></p><ol><li><strong><code>cout &lt;&lt; setw(2) &lt;&lt; hex &lt;&lt; (int)*(p + i)</code></strong>：<ul><li><code>setw(2)</code>：设置输出的宽度为 2 个字符（用于保持输出整齐）。</li><li><code>hex</code>：将数值按十六进制格式输出。</li><li><code>(int)*(p + i)</code>：将当前字节的值转换为整型，然后以十六进制格式输出。</li></ul></li><li><strong><code>if ((i + 1) % 4 == 0)</code></strong>：每 4 个字节换行输出。这个条件确保我们按 4 字节分组显示数据，以更好地查看内存布局。</li></ol><h2 id="tuple-Structed-Binding">tuple &amp; Structed Binding</h2><h3 id="案例-7">案例</h3><img src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241009210311939.png" class="" title="image-20241009210311939"><p>该PPT演示了三种方式来让<strong>函数实现多输出参数</strong>（即多个“返回值”）</p><p>M1：引用传参，直接修改</p><p>M2：结构体返回</p><p>M3：使用<strong>tuple和结构化绑定</strong></p><p><strong>函数定义：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tuple&lt;<span class="type">int</span>, <span class="type">float</span>&gt; <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="number">1</span>, <span class="number">3.0f</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用方式：</strong></p><ul><li><p><strong>方法 1</strong>：使用 <code>std::get&lt;&gt;</code> 访问元组中的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> r = <span class="built_in">foo</span>();</span><br><span class="line">cout &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(r) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(r);</span><br></pre></td></tr></table></figure></li><li><p><strong>方法 2</strong>：使用**结构化绑定（Structured Binding）**直接解构元组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> r = <span class="built_in">foo</span>();</span><br><span class="line"><span class="keyword">auto</span> [i,f] = r;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; f;</span><br></pre></td></tr></table></figure></li><li><p><strong>方法 3</strong>：结构化绑定和引用结合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto r = foo();</span><br><span class="line">auto&amp; [i,f] = r;</span><br><span class="line">i = 1;</span><br><span class="line">f = 2.3;</span><br></pre></td></tr></table></figure></li></ul><p>重点即为这里<strong>结构化绑定的表达方式</strong>，即元组如何<strong>构建与访问</strong></p><p><strong>解释：</strong></p><ul><li><strong><code>std::tuple</code></strong>：<code>tuple</code> 是 C++ 标准库提供的工具，用于打包多个不同类型的值并作为一个整体返回。这里的 <code>tuple&lt;int, float&gt;</code> 表示一个包含 <code>int</code> 和 <code>float</code> 的元组。</li><li><strong><code>get&lt;&gt;</code> 函数</strong>：<code>get&lt;0&gt;(r)</code> 用于访问元组的第一个值，<code>get&lt;1&gt;(r)</code> 用于访问元组的第二个值。元组是基于索引的，因此通过 <code>get&lt;索引&gt;(元组)</code> 来获取对应的值。</li><li><strong>结构化绑定（Structured Binding）</strong>：C++17 引入了结构化绑定，使得我们可以轻松地将<strong>元组中的值解包为多个独立的变量</strong>。<code>auto [i, f] = foo();</code> 直接将元组中的第一个值赋给 <code>i</code>，第二个值赋给 <code>f</code>，然后可以像普通变量一样使用 <code>i</code> 和 <code>f</code>。</li></ul><h2 id="optional">optional</h2><p>在 C++ 中，<code>std::optional</code> 是 C++17 引入的标准库类型，<strong>用于表示一个可能存在或者不存在的值</strong>。它是一个非常有用的工具，<strong>尤其是在函数返回值的场景下</strong>，可以避免使用指针或其他形式来表示“无效值”或“空值”。</p><p><strong>1. <code>std::optional</code> 的定义和作用</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br></pre></td></tr></table></figure><p><code>std::optional&lt;T&gt;</code> 是一个模板类，它可以存储一个类型为 <code>T</code> 的值，或者表示没有值。<strong>这个类的主要作用是让你能够在一个变量中安全地表达“有值”或“无值”的状态</strong>，而无需使用指针或特殊的返回值。</p><p><strong>主要功能：</strong></p><ul><li><strong>有值状态</strong>：<code>optional&lt;T&gt;</code> 包含一个类型为 <code>T</code> 的值。</li><li><strong>无值状态</strong>：<code>optional</code> 是“空”的，表示不包含任何值。</li></ul><p><strong>2. 使用场景</strong></p><p><code>std::optional</code> 常用于以下场景：</p><ul><li><strong>函数的返回值</strong>：当函数可能无法返回有效的结果时，<code>optional</code> 可以用来表示“没有值”而不是返回一个无效的值（如返回 <code>nullptr</code> 或 <code>-1</code>）。</li><li><strong>替代指针</strong>：它可以用来替代指针，表示一个对象要么有效，要么无效，但不会像裸指针那样产生悬空指针的风险。</li></ul><p><strong>3. <code>std::optional</code> 的基本使用</strong></p><p><strong>例子：可能返回值的函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">findName</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="literal">nullopt</span>;  <span class="comment">// 返回 &quot;无值&quot; 的状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> name = <span class="built_in">findName</span>(<span class="number">1</span>);  <span class="comment">// id 为 1 时有值</span></span><br><span class="line">    <span class="keyword">if</span> (name) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; *name &lt;&lt; std::endl;  <span class="comment">// 通过解引用访问值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No name found&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> noName = <span class="built_in">findName</span>(<span class="number">3</span>);  <span class="comment">// id 为 3 时无值</span></span><br><span class="line">    <span class="keyword">if</span> (noName) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; *noName &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No name found&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><strong><code>std::nullopt</code></strong>：这是一个常量，用来表示 <code>optional</code> 处于“无值”的状态。在 <code>findName</code> 函数中，如果传入的 <code>id</code> 无法匹配到有效的名字，<strong>返回 <code>std::nullopt</code></strong>，表示没有找到名字。</li><li><strong><code>name</code> 的检查</strong>：使用 <code>if (name)</code> 来检查 <code>optional</code> 是否有值。<code>optional</code> 类支持类似于布尔值的转换操作，如果它包含值，则为 <code>true</code>，否则为 <code>false</code>。</li><li><strong>解引用访问值</strong>：如果 <code>optional</code> 包含值，可以使用 <code>*name</code> 解引用访问它内部的值。</li></ul><p><strong>4. <code>std::optional</code> 的成员函数</strong></p><p><code>std::optional</code> 提供了多个有用的成员函数来检查和操作内部的值：</p><p><strong>1. <code>has_value()</code> 或 <code>operator bool()</code></strong></p><ul><li>用于检查 <code>optional</code> 是否包含值。</li><li><code>bool hasValue = opt.has_value();</code> 或者直接用 <code>if (opt)</code> 来检查是否有值。</li></ul><p><strong>2. <code>value()</code></strong></p><ul><li>返回存储的值。如果 <code>optional</code> 没有值，调用这个方法会抛出异常 <code>std::bad_optional_access</code>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> name = <span class="built_in">findName</span>(<span class="number">1</span>);</span><br><span class="line">std::cout &lt;&lt; name.<span class="built_in">value</span>() &lt;&lt; std::endl;  <span class="comment">// 直接获取值</span></span><br></pre></td></tr></table></figure><ul><li>为了避免异常，可以使用 <code>value_or()</code> 方法。</li></ul><p><strong>3. <code>value_or()</code></strong></p><ul><li>如果 <code>optional</code> 有值，返回该值；如果没有值，返回一个默认值。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> name = <span class="built_in">findName</span>(<span class="number">3</span>);</span><br><span class="line">std::cout &lt;&lt; name.<span class="built_in">value_or</span>(<span class="string">&quot;Unknown&quot;</span>) &lt;&lt; std::endl;  <span class="comment">// 没有值时返回 &quot;Unknown&quot;</span></span><br></pre></td></tr></table></figure><p><strong>4. <code>emplace()</code></strong></p><ul><li><code>emplace()</code> 方法可以在 <code>optional</code> 中直接构造一个新的值，避免不必要的拷贝或赋值。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::optional&lt;<span class="type">int</span>&gt; opt;</span><br><span class="line">opt.<span class="built_in">emplace</span>(<span class="number">42</span>);  <span class="comment">// 直接在 optional 中构造 42</span></span><br></pre></td></tr></table></figure><p><strong>5. <code>reset()</code></strong></p><ul><li><code>reset()</code> 会将 <code>optional</code> 重置为无值状态。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opt.<span class="built_in">reset</span>();  <span class="comment">// opt 现在是无值的</span></span><br></pre></td></tr></table></figure><h3 id="案例-8">案例</h3><img src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241009211053083.png" class="" title="image-20241009211053083"><p><strong>右上角：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">getNameByID</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::vector&lt;std::pair&lt;<span class="type">int</span>, std::string&gt;&gt;&amp; v, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> id)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : v) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.first == id) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>std::nullopt</code></strong>：这是一个特殊的值，表示 <code>optional</code> 处于“无值”的状态。它在这里用于表明找不到对应的学生时返回“无值”。</p></li><li><p>相比传统的指针或特殊的返回值，<code>std::optional</code> 提供了一种更加安全、直观的方式来表示“<strong>值的存在或不存在</strong>”。调用者可以通过 <code>optional</code> 检查返回值是否存在。</p></li></ul><p><strong>左下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::pair&lt;<span class="type">int</span>, std::string&gt;&gt; students&#123;&#123;<span class="number">1</span>, <span class="string">&quot;AAA&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;BBB&quot;</span>&#125;, &#123;<span class="number">3</span>, <span class="string">&quot;CC&quot;</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> student_id;</span><br><span class="line">std::cin &gt;&gt; student_id;</span><br><span class="line"><span class="keyword">auto</span> id = <span class="built_in">getNameByID</span>(students, student_id);</span><br></pre></td></tr></table></figure><ul><li><code>id</code> 的类型是 <code>std::optional&lt;std::string&gt;</code>，表示查找结果可以有值，也可以没有值。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id.<span class="built_in">has_value</span>() ? cout &lt;&lt; id.<span class="built_in">value</span>() : cout &lt;&lt; <span class="string">&quot;Not Found&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; id.<span class="built_in">value_or</span>(<span class="string">&quot;Not Found&quot;</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><strong><code>id.has_value()</code></strong>：用于检查 <code>optional</code> 是否包含有效值。如果 <code>optional</code> 有值，则返回 <code>true</code>，否则返回 <code>false</code>。</li><li><strong><code>id.value()</code></strong>：如果 <code>optional</code> 有值，<code>value()</code> 返回存储的值。在这里，如果找到了学生名字，它会返回这个名字。</li><li><strong><code>value_or(&quot;Not Found&quot;)</code></strong>：这是一个更简洁的方式，如果 <code>optional</code> 有值，则返回该值；如果没有值，则返回 <code>value_or()</code> 中的默认值 <code>&quot;Not Found&quot;</code>。这减少了手动检查和输出“无值”的情况。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> op1 = std::make_optional&lt;std::vector&lt;<span class="type">char</span>&gt;&gt;(&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : *op1) </span><br><span class="line">    cout &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// optional set construction</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>std::make_optional</code></strong>：它是一个简化构造 <code>optional</code> 对象的函数，可以方便地构造 <code>optional</code> 包含的值。</li><li><strong>解引用 <code>optional</code></strong>：<code>optional</code> 可以像指针一样被解引用，<code>*op1</code> 会返回存储在 <code>optional</code> 中的值。</li></ul><h2 id="varient">varient</h2><p><strong>1. 定义</strong></p><p><code>std::variant</code> 是一个可以<strong>存储多个不同类型的对象的容器，但每次只能存储其中的一种类型</strong>。与 C++ 的 <code>union</code> 不同，<code>std::variant</code> 是类型安全的，这意味着你可以知道当前存储的值的类型，并安全地获取它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::variant&lt;<span class="type">int</span>, <span class="type">float</span>, std::string&gt; var;</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个 <code>std::variant</code>，它可以存储 <code>int</code>、<code>float</code> 或 <code>std::string</code> 类型的值。每次只能存储其中一个类型。</p><p><strong>2. 如何使用 <code>std::variant**</code></strong></p><p><strong>2.1 创建 <code>std::variant</code> 对象</strong></p><p>你可以通过直接赋值或者构造函数来初始化 <code>std::variant</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 variant，存储一个 int 类型的值</span></span><br><span class="line">    std::variant&lt;<span class="type">int</span>, <span class="type">float</span>, std::string&gt; var = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 现在 var 存储了 int 类型的值 10</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(var) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改 var 的值，存储一个 float</span></span><br><span class="line">    var = <span class="number">3.14f</span>;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">float</span>&gt;(var) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改 var 的值，存储一个 std::string</span></span><br><span class="line">    var = std::<span class="built_in">string</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;std::string&gt;(var) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><strong><code>std::get&lt;T&gt;(variant)</code></strong>：使用 <code>std::get&lt;T&gt;</code> 来获取存储在 <code>variant</code> 中的值，<code>T</code> 是当前存储的类型。如果你尝试获取与当前存储类型不符的值，会抛出 <code>std::bad_variant_access</code> 异常。</li><li><strong>类型安全</strong>：与 C++ 中的 <code>union</code> 不同，<code>std::variant</code> 可以安全地检测并返回当前存储的类型。</li></ul><p><strong>2.2 索引访问</strong></p><p>除了使用 <code>std::get&lt;T&gt;</code> 访问 <code>variant</code> 中存储的值，你还可以使用 <code>std::get&lt;index&gt;</code> 通过索引来访问它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::variant&lt;<span class="type">int</span>, <span class="type">float</span>, std::string&gt; var = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过索引 0 获取 int 类型的值</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(var) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过索引 1 存储 float 类型的值</span></span><br><span class="line">    var = <span class="number">3.14f</span>;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(var) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过索引 2 存储 string 类型的值</span></span><br><span class="line">    var = std::<span class="built_in">string</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(var) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><code>std::get&lt;index&gt;(variant)</code>：索引从 0 开始，<code>std::get&lt;0&gt;(var)</code> 表示 <code>variant</code> 的第一个类型（在这个例子中是 <code>int</code>）。</li></ul><p><strong>3. 检测当前存储的类型</strong></p><p>在使用 <code>std::variant</code> 时，你可以使用 <code>std::holds_alternative&lt;T&gt;</code> 来检查 <code>variant</code> 当前是否存储了某种类型的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::variant&lt;<span class="type">int</span>, <span class="type">float</span>, std::string&gt; var = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (std::<span class="built_in">holds_alternative</span>&lt;<span class="type">int</span>&gt;(var)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;variant contains an int.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::holds_alternative&lt;T&gt;(variant)</code> 检查 <code>variant</code> 是否包含类型 <code>T</code>，如果包含，返回 <code>true</code>，否则返回 <code>false</code>。</p><p><strong>4. 访问错误处理</strong></p><p>如果你试图获取的类型与 <code>variant</code> 当前存储的类型不符，<code>std::get</code> 会抛出 <code>std::bad_variant_access</code> 异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    std::variant&lt;<span class="type">int</span>, std::string&gt; var = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;std::string&gt;(var);  <span class="comment">// 这里会抛出异常，因为当前是 int 类型</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_variant_access&amp; e) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. <code>std::visit</code>：处理 <code>variant</code> 的类型</strong></p><p>在很多情况下，你可能需要根据 <code>variant</code> 的类型来执行不同的操作。<code>std::visit</code> 可以帮你做这件事：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::variant&lt;<span class="type">int</span>, <span class="type">float</span>, std::string&gt; var = std::<span class="built_in">string</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> visitor = [](<span class="type">const</span> <span class="keyword">auto</span>&amp; value) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">visit</span>(visitor, var);  <span class="comment">// 根据 var 的当前类型调用合适的 lambda</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><strong><code>std::visit</code></strong>：它用于访问 <code>variant</code> 中存储的值，并根据存储的类型执行相应的操作。它的参数是一个函数对象或 lambda 表达式，以及一个或多个 <code>variant</code>。</li><li><strong>通用 lambda 表达式</strong>：使用 <code>auto</code> 作为参数类型，意味着 lambda 表达式可以接受任意类型的参数。在上面的例子中，无论 <code>variant</code> 是 <code>int</code>、<code>float</code> 还是 <code>std::string</code>，这个 lambda 都可以处理。</li></ul><p><strong>6. <code>std::monostate</code>：表示空状态</strong></p><p>有时，可能需要 <code>variant</code> 有一个“无效”状态。<code>std::monostate</code> 提供了这样一个工具，它通常用作 <code>variant</code> 的第一个类型，表示一个“无值”状态：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::variant&lt;std::monostate, <span class="type">int</span>, std::string&gt; var;</span><br><span class="line"><span class="keyword">if</span> (std::<span class="built_in">holds_alternative</span>&lt;std::monostate&gt;(var)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;variant is empty.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><strong><code>std::monostate</code></strong>：这是一个没有任何成员的类型，通常用作 <code>variant</code> 的占位类型，表示一种默认的空状态。</li><li>当 <code>variant</code> 被默认构造时，如果它包含 <code>std::monostate</code>，就相当于处于一种空状态。</li></ul><h3 id="案例-9">案例</h3><img src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241010210228947.png" class="" title="image-20241010210228947"><p><strong>上方：</strong></p><p><strong>1. <code>std::variant</code> 基本介绍</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::variant&lt;<span class="type">int</span>, <span class="type">float</span>, std::string&gt; v;</span><br></pre></td></tr></table></figure><p>这是一个声明了 <code>std::variant</code> 类型的变量 <code>v</code>，它可以存储三种类型中的一种：<code>int</code>、<code>float</code>、或者 <code>std::string</code>。</p><p><strong>2. 为 <code>variant</code> 赋值和使用 <code>std::get</code> 进行访问</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">cout &lt;&lt; v.<span class="built_in">index</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;std::string&gt;(v) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><ul><li><strong><code>v.index()</code></strong>：<code>index()</code> 方法返回当前 <code>variant</code> 存储的类型对应的索引（按类型在模板列表中的顺序）。<code>std::string</code> 是第三个类型，因此 <code>index()</code> 会返回 <code>2</code>。</li><li><strong><code>std::get&lt;std::string&gt;(v)</code></strong>：使用 <code>std::get&lt;T&gt;</code> 提取 <code>variant</code> 中存储的值。此处 <code>T</code> 是 <code>std::string</code>，因为当前 <code>v</code> 存储的是一个字符串。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; v.<span class="built_in">index</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(v) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><ul><li><strong><code>v = 100;</code></strong>：现在我们将一个 <code>int</code> 类型的值 <code>100</code> 赋给 <code>v</code>，此时 <code>v</code> 存储的是 <code>int</code> 类型。</li><li><strong><code>std::get&lt;0&gt;(v)</code></strong>：这里使用索引 <code>0</code> 来获取 <code>int</code> 类型的值，因为 <code>int</code> 是 <code>variant</code> 中的第一个类型。</li></ul><p><strong>3. <code>std::variant</code> 中异常和错误处理</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// v = 2.3f;  // 如果取消注释，发生了什么？</span></span><br><span class="line">cout &lt;&lt; v.<span class="built_in">index</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">float</span>&gt;(v) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><ul><li>这里 <code>v</code> 被赋值为 <code>100</code>，即 <code>int</code> 类型。<code>std::get&lt;float&gt;(v)</code> 试图获取 <code>float</code> 类型的值，但当前 <code>v</code> 中存储的是 <code>int</code> 类型，因此会抛出 <code>std::bad_variant_access</code> 异常。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">double</span>&gt;(v);  <span class="comment">// 会发生什么？</span></span><br></pre></td></tr></table></figure><ul><li><code>variant</code> 中并没有声明可以存储 <code>double</code> 类型，<code>std::get&lt;double&gt;</code> 会导致**编译错误。**这是因为 <code>double</code> 不是 <code>variant</code> 中的合法类型。</li></ul><p><strong>错误：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Compile Error</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>检查当前存储的类型：<code>std::get_if</code> 和 <code>std::holds_alternative</code></strong></li></ol><p>PPT 还展示了两种方法来安全地检查 <code>variant</code> 是否存储了某种类型，并提取存储的值。</p><p><strong>方法1：使用 <code>std::get_if</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span>* pf = std::<span class="built_in">get_if</span>&lt;<span class="type">float</span>&gt;(&amp;v);</span><br><span class="line"><span class="keyword">if</span> (pf != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">index</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *pf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Invalid&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>std::get_if&lt;T&gt;(variant)</code></strong>：这是一个更安全的获取方式，它返回指向 <code>variant</code> 中存储的 <code>T</code> 类型的指针。如果 <code>variant</code> 当前存储的是 <code>T</code> 类型的值，返回该值的指针；否则，返回 <code>nullptr</code>。</li><li>如果 <code>pf != nullptr</code>，则表示当前 <code>v</code> 中存储的是 <code>float</code> 类型，输出 <code>float</code> 值；否则输出 <code>Invalid</code>。</li></ul><p><strong>方法2：使用 <code>std::holds_alternative</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (std::<span class="built_in">holds_alternative</span>&lt;<span class="type">float</span>&gt;(v)) &#123;</span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">index</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">float</span>&gt;(v) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>std::holds_alternative&lt;T&gt;(variant)</code></strong>：用于检查 <code>variant</code> 当前是否存储了类型 <code>T</code> 的值。如果存储的是 <code>T</code>，返回 <code>true</code>，否则返回 <code>false</code>。</li><li>如果 <code>variant</code> 中确实存储了 <code>float</code>，则可以安全地使用 <code>std::get&lt;float&gt;(v)</code> 提取值。</li></ul><h2 id="any">any</h2><p><code>std::any</code> 是一个类型安全的通用容器，它可以<strong>存储任意类型的对象</strong>。和 <code>void*</code> 不同，<code>std::any</code> 提供了类型信息检查的功能，因此在取出存储的对象时，可以确保类型安全。</p><ol><li><strong>存储任意类型的值</strong>：<code>std::any</code> 能够存储任何类型的值，它提供了一种类型无关的方式来处理数据。</li><li><strong>类型安全的访问</strong>：<code>std::any</code> 能够通过 <code>std::any_cast</code> 安全地获取存储值的类型。</li><li><strong>动态类型识别</strong>：你可以在运行时检查 <code>std::any</code> 存储的值的类型，这为程序提供了高度的灵活性。</li></ol><p><strong>1. 创建与存储值</strong></p><p>你可以通过直接赋值或构造函数将任何类型的值存储到 <code>std::any</code> 中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::any a = <span class="number">10</span>;  <span class="comment">// 存储一个整数</span></span><br><span class="line">    std::any b = std::<span class="built_in">string</span>(<span class="string">&quot;Hello, World!&quot;</span>);  <span class="comment">// 存储一个字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 访问存储的值</strong></p><p>要访问存储在 <code>std::any</code> 中的值，你需要使用 <code>std::any_cast</code>，它允许你提取存储的特定类型值。如果类型不匹配，则会抛出异常 <code>std::bad_any_cast</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::any a = <span class="number">42</span>;  <span class="comment">// 存储一个整数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> value = std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(a);  <span class="comment">// 获取存储的整数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_any_cast&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bad any_cast: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::string str = std::<span class="built_in">any_cast</span>&lt;std::string&gt;(a);  <span class="comment">// 尝试获取字符串，类型不匹配</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_any_cast&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;  <span class="comment">// 会抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>std::any_cast&lt;int&gt;</code> 能够成功提取出整数，但 <code>std::any_cast&lt;std::string&gt;</code> 会抛出 <code>std::bad_any_cast</code> 异常，因为存储的类型并不是字符串。</p><p><strong>3. 检查存储的类型</strong></p><p><code>std::any</code> 提供了 <code>type()</code> 方法，可以获取当前存储对象的类型信息（通过 <code>std::type_info</code>）。这允许你在运行时进行类型检查。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::any a = <span class="number">42</span>;  <span class="comment">// 存储一个整数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Stored type: &quot;</span> &lt;&lt; a.<span class="built_in">type</span>().<span class="built_in">name</span>() &lt;&lt; std::endl;  <span class="comment">// 输出类型名</span></span><br><span class="line"></span><br><span class="line">    a = std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Stored type: &quot;</span> &lt;&lt; a.<span class="built_in">type</span>().<span class="built_in">name</span>() &lt;&lt; std::endl;  <span class="comment">// 输出新类型名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子使用了 <code>type().name()</code> 来获取 <code>std::any</code> 中存储值的类型信息。输出将显示存储的对象的具体类型（例如 <code>int</code> 或 <code>std::string</code>）。</p><p><strong>4. 检查是否为空</strong></p><p><code>std::any</code> 对象可以存储一个空值（即无任何内容）。你可以通过 <code>has_value()</code> 方法来检查它是否存储了有效的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::any a;  <span class="comment">// a 为空</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Has value: &quot;</span> &lt;&lt; a.<span class="built_in">has_value</span>() &lt;&lt; std::endl;  <span class="comment">// 输出: false</span></span><br><span class="line"></span><br><span class="line">    a = <span class="number">10</span>;  <span class="comment">// 存储一个值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Has value: &quot;</span> &lt;&lt; a.<span class="built_in">has_value</span>() &lt;&lt; std::endl;  <span class="comment">// 输出: true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 重置 <code>std::any</code></strong></p><p><code>std::any</code> 的 <code>reset()</code> 方法可以清空其存储的值，将其状态重置为“空”：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::any a = <span class="number">42</span>;  <span class="comment">// 存储一个整数</span></span><br><span class="line">    a.<span class="built_in">reset</span>();  <span class="comment">// 重置</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Has value after reset: &quot;</span> &lt;&lt; a.<span class="built_in">has_value</span>() &lt;&lt; std::endl;  <span class="comment">// 输出: false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>std::any</code> 和其他多态机制的对比</strong></p><ol><li><strong>与 <code>void*</code> 对比</strong>：<code>std::any</code> 提供了类型安全的类型擦除，而 <code>void*</code> 是完全不安全的。使用 <code>void*</code> 你无法知道存储的具体类型，而且在解引用时需要非常小心以防止类型错误。而 <code>std::any</code> 可以通过 <code>std::any_cast</code> 和 <code>type()</code> 提供运行时的类型信息和安全类型转换。</li><li><strong>与 <code>std::variant</code> 对比</strong>：<code>std::variant</code> 也是C++17引入的多态类型，但 <code>std::variant</code> 是静态类型安全的，它只能存储在编译时定义的特定类型集合中的一种类型。而 <code>std::any</code> 则更加灵活，它能够存储任何类型，甚至是运行时动态决定的类型，但缺乏 <code>std::variant</code> 的编译时检查。</li></ol><h3 id="案例-10">案例</h3><img src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241011090334329.png" class="" title="image-20241011090334329"><p><strong>1. any基本用法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span>  <span class="comment">// 引入头文件</span></span></span><br></pre></td></tr></table></figure><p><strong>代码 1：<code>input()</code> 函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">any <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i; </span><br><span class="line">    cin &gt;&gt; i; </span><br><span class="line">    <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> <span class="number">11</span>;         <span class="comment">// 返回 int</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="number">3.14</span>;       <span class="comment">// 返回 double</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// 返回 string</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>any</code> 类型返回值</strong>：<code>input()</code> 函数的返回类型为 <code>std::any</code>，因此它可以返回不同类型的值。</li></ul><p><strong>代码 2：存储 <code>std::any</code> 的值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">any aa; </span><br><span class="line">aa = <span class="built_in">input</span>();</span><br></pre></td></tr></table></figure><p><strong>代码 3：类型判断与提取值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (aa.<span class="built_in">type</span>() == <span class="built_in">typeid</span>(<span class="type">int</span>)) &#123;</span><br><span class="line">    cout &lt;&lt; aa.<span class="built_in">type</span>().<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(aa);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (aa.<span class="built_in">type</span>() == <span class="built_in">typeid</span>(<span class="type">double</span>)) &#123;</span><br><span class="line">    cout &lt;&lt; aa.<span class="built_in">type</span>().<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">any_cast</span>&lt;<span class="type">double</span>&gt;(aa);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; aa.<span class="built_in">type</span>().<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">any_cast</span>&lt;string&gt;(aa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>aa.type()</code></strong>：<code>std::any::type()</code> 返回存储在 <code>std::any</code> 中的类型信息（<code>std::type_info</code> 对象）。你可以将它与 <strong><code>typeid</code> 进行比较</strong>，判断 <code>std::any</code> 中的实际类型。</li><li><strong>输出类型名称</strong>：<ul><li><strong><code>aa.type().name()</code></strong>：输出存储值的类型名称（由编译器定义的名字，通常类型是经过编码的字符串）。</li></ul></li><li><strong>提取值</strong>：<ul><li><strong><code>any_cast&lt;T&gt;(aa)</code></strong>：<code>std::any_cast&lt;T&gt;(aa)</code> 用于将 <code>std::any</code> 类型的值转换为 <code>T</code> 类型的值。此处 <code>T</code> 是我们判断出来的实际存储的类型。如果类型不匹配，<code>any_cast</code> 会抛出 <code>std::bad_any_cast</code> 异常。</li></ul></li></ul><p><strong>3. PPT 中的其他重要知识点</strong></p><p><strong>3.1 类型安全</strong></p><p><strong><em>“type safe void”</em>：</strong></p><ul><li><code>std::any</code> 可以被看作是“类型安全的 <code>void*</code>”。<code>void*</code> 在C++中可以指向任何类型，但并不具有类型安全性。<code>std::any</code> 的出现弥补了这一缺陷，它允许存储不同类型的值，同时在需要时能安全地提取出正确的类型。通过 <code>std::any::type()</code> 和 <code>typeid()</code>，你可以在运行时检查存储的类型，并通过 <code>std::any_cast&lt;T&gt;</code> 安全地提取值。</li></ul><p><strong>“size-free basket”</strong>：</p><ul><li>这个术语是用来比喻 <code>std::any</code> 的。<code>basket</code>（篮子）意指 <code>std::any</code> 可以容纳任意类型的值。而“size-free” 表示 <code>std::any</code> 没有大小限制，可以容纳任何类型，无论它是基本类型如 <code>int</code> 或者是更大的复杂类型如 <code>std::vector</code>。这是因为 <strong><code>std::any</code> 会根据存储对象的大小动态分配所需的内存，而不是像数组那样有固定大小</strong>。</li></ul><h2 id="array">array</h2><h3 id="案例-11">案例</h3><img src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241011091150794.png" class="" title="image-20241011091150794"><p><strong><code>typeid(a).name()</code></strong></p><p><code>typeid(a).name()</code> 用于获取数组变量 <code>a</code> 的类型信息。在C++中，<code>typeid</code> 操作符可以返回一个 <code>std::type_info</code> 对象，<code>name()</code> 方法则返回类型的名称。<strong>数组作为参数传递时会退化为指针，所以 <code>typeid(a).name()</code> 返回的将是指针类型的名称。</strong></p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(a).<span class="built_in">name</span>() &lt;&lt; std::endl;  <span class="comment">// 输出int*</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当数组作为参数传递时，<code>typeid(a)</code> 会输出 <code>int*</code>，因为<strong>数组名在传递时已经退化为指针</strong>。</p><p><strong><code>sizeof</code> 问题</strong></p><p><code>sizeof</code> 操作符用于获取变量或类型的字节大小。在数组的上下文中，<code>sizeof</code> 有一些特殊表现：</p><ul><li>如果在数组定义的地方使用 <code>sizeof(arr)</code>，它会返回整个数组的字节大小。例如，<code>int arr[5]</code> 的 <code>sizeof(arr)</code> 是 <code>5 * sizeof(int)</code>，即 20 字节（在 32 位系统中）。</li><li>但是当数组作为参数传递给函数时，<strong>数组退化为指针</strong>，所以在<strong>函数内部对数组使用 <code>sizeof</code> 只会返回指针的大小</strong>（通常是 <strong>4</strong> 或 8 字节，具体取决于系统）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; std::endl;  <span class="comment">// 输出指针大小，而不是数组大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，<strong>如果你想在函数中知道数组的长度，需要传递数组的大小（如 <code>n</code>），而不能依赖 <code>sizeof</code> 操作符。</strong></p><p><strong>Use debug info (使用调试信息)</strong></p><p><strong>1. <code>/RTC1</code></strong></p><p>这是微软Visual Studio中的一个编译器选项，代表“运行时检查”。启用 <code>/RTC1</code> 可以捕捉一些运行时错误，比如<strong>数组越界和未初始化变量的使用等</strong>。它对调试和提高程序的健壮性非常有帮助。</p><p><strong>2. <code>mallopt</code></strong></p><p><code>mallopt</code> 是一个内存分配优化函数，它允许用户修改 <code>malloc</code>、<code>calloc</code> 和 <code>realloc</code> 的行为，以控制内存管理的细节。这在处理大量<strong>动态分配内存</strong>时有帮助，但在数组的上下文中，主要是提醒开发者注意<strong>内存分配和优化</strong>。</p><p><strong>3. <code>valgrind</code></strong></p><p><code>valgrind</code> 是一个用于检测内存问题的调试工具，广泛应用于Linux环境中。它可以帮助开发者检测诸如内存泄漏、无效的内存访问（如数组越界）、未初始化的内存使用等问题。使用 <code>valgrind</code> 可以有效防止数组的非法访问和内存泄漏等问题。</p><p>例如，在 Linux 中，你可以用以下命令通过 <code>valgrind</code> 来运行你的程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind ./my_program</span><br></pre></td></tr></table></figure><p><code>valgrind</code> 会报告程序中的<strong>内存错误</strong>，帮助你快速定位和修复问题。</p><h2 id="pointer">pointer</h2><h3 id="案例-12">案例</h3><img src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241011092004712.png" class="" title="image-20241011092004712"><p><strong>Pointer Literal（指针字面量）</strong></p><p>指针字面量指的是用于表示“空指针”（null pointer）的一种符号，专门表示指针不指向任何有效的内存地址。</p><p>PPT在这一部分讨论了 <strong><code>NULL</code> 和 <code>nullptr</code> 这两种特殊的指针字面量</strong>，以及它们在 C 和 C++ 中的定义和用法。</p><p><strong>1. <code>NULL</code> 在 ANSI C 中的定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void*)0)</span></span><br></pre></td></tr></table></figure><p>在ANSI C中，<strong><code>NULL</code> 通常被定义为 <code>(void*)0</code>，即空指针</strong>（指向空地址的指针），这是为了表示一个指针不指向任何有效的内存位置。对于像 <code>char*</code> 这样的指针，<code>NULL</code> 可以用于指示空指针。</p><p><strong>2. <code>NULL</code> 在 C++ 中的定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br></pre></td></tr></table></figure><p>在C++中，<code>NULL</code> 通常被定义为 <code>0</code>，用于表示空指针。不过这种定义在C++中可能会导致一些歧义，因为整数 <code>0</code> 在某些上下文中也可以代表整型常量。<strong>为了避免这种歧义，C++11引入了 <code>nullptr</code>。</strong></p><p><strong>3. <code>nullptr</code></strong></p><p><code>nullptr</code> 是C++11中引入的一种<strong>专门用于表示空指针的类型安全的指针字面量。它取代了C++中的 <code>NULL</code></strong>，并避免了 <code>NULL</code> 与整数 <code>0</code> 之间的混淆。</p><p><strong>代码示例中的歧义：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(<span class="literal">NULL</span>);  <span class="comment">// 这是调用哪个函数？</span></span><br></pre></td></tr></table></figure><p>在这个例子中，如果 <code>NULL</code> 被定义为 <code>0</code>，那么 <code>func(NULL)</code> 将变得模糊不清，因为 <code>NULL</code> 是一个整数 <code>0</code>，它可能匹配 <code>func(int)</code>，也可能匹配 <code>func(char*)</code>。这种模糊会带来不确定性。</p><p>使用 <code>nullptr</code> 可以消除这个歧义，因为 <code>nullptr</code> 是一个类型安全的指针字面量，专门用于指针类型，因此 <code>func(nullptr)</code> 只能匹配 <code>void func(char*)</code> 函数。</p><h2 id="Dynamic-variables">Dynamic variables</h2><h3 id="案例-13">案例</h3><img src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241011093714534.png" class="" title="image-20241011093714534"><p><strong>1. Dynamic Variables（动态变量）</strong></p><p>动态变量指的是在程序运行时<strong>通过动态内存分配（如 <code>malloc</code>、<code>new</code>）创建</strong>的变量。<strong>与静态分配的变量不同，动态变量不在编译时决定大小，而是在运行时动态分配，并且必须手动释放内存</strong>。否则，可能会引发内存泄漏。</p><p><strong>内存分配和释放相关的函数</strong></p><ul><li><p><code>malloc</code> 和 <code>free</code></p><p>：这些是C语言中的标准库函数，用于动态分配和释放内存。</p><ul><li><strong><code>malloc</code></strong>：分配一块指定大小的内存，返回指向这块内存的指针。</li><li><strong><code>free</code></strong>：释放先前通过 <code>malloc</code> 分配的内存，避免内存泄漏。</li></ul></li><li><p><code>new</code> 和 <code>delete</code></p><p>：这是C++中用于动态分配和释放内存的操作符。</p><ul><li><strong><code>new</code></strong>：在C++中，用于为某种类型分配内存并返回该类型的指针。与 <code>malloc</code> 不同，<code>new</code> 同时调用构造函数。</li><li><strong><code>delete</code></strong>：用于释放通过 <code>new</code> 分配的内存，防止内存泄漏。</li><li><strong><code>delete[]</code></strong>：当通过 <code>new[]</code> 分配一个数组时，使用 <code>delete[]</code> 释放内存。</li></ul></li></ul><p><strong>2. 内存泄漏（Memory Leak）与闲置指针（Idle Pointer）</strong></p><ul><li><strong>Memory Leak（内存泄漏）</strong>：如果分配了内存但没有释放，那么这些内存将无法再被使用，导致系统资源逐渐耗尽，这种情况称为内存泄漏。比如通过 <code>new</code> 分配内存后，如果没有使用 <code>delete</code> 来释放内存，就会发生内存泄漏。</li><li><strong>Idle Pointer（闲置指针）</strong>：指针如果没有及时释放或者没有正确指向有效的内存地址，可能会变成悬空指针（即指向已经被释放或不再有效的内存地址）。使用闲置指针可能导致程序崩溃或者不可预测的行为。</li></ul><p><strong>3. 堆（Heap）内存结构</strong></p><img src="/2025/01/25/C++高级程序设计/image-20241011094553926.png"  alt="image-20241011094553926" style="zoom: 50%;" /><p>在PPT的右上角，有一个堆内存结构的图示，展示了堆是如何在内存中的不同区域中分配的。</p><ul><li><strong>Kernel Space（内核空间）</strong>：用户代码无法直接访问这部分内存。</li><li><strong>Stack（栈）</strong>：栈用于存储函数调用时的<strong>局部变量</strong>，栈的内存从<strong>高地址向低地址</strong>增长。</li><li><strong>Heap（堆）</strong>：堆用于<strong>动态分配内存</strong>，内存从<strong>低地址向高地址</strong>增长。通过 <code>malloc</code> 或 <code>new</code> 分配的内存位于这里。堆的起始位置由 <code>brk</code> 或 <code>mmap</code> 进行管理（这是Linux系统中的内存管理方式）。</li></ul><p><strong>4. C++中动态内存分配的示例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">2</span>] &#123; <span class="number">7</span>, <span class="number">15</span> &#125;;</span><br></pre></td></tr></table></figure><ul><li><strong><code>int* p = new int[2]</code></strong>：在<strong>堆</strong>上为两个整型元素动态分配内存，返回指向该内存块的指针 <code>p</code>。该内存块包含两个整型值：<code>7</code> 和 <code>15</code>。</li><li><strong><code>&#123;7, 15&#125;</code></strong>：表示通过初始化列表，将两个元素的值分别设为 <code>7</code> 和 <code>15</code>。</li></ul><p><strong>5. 内存调试信息</strong></p><p>PPT中的数据表示了通过某种调试工具（例如 <code>valgrind</code> 或类似工具）获取的内存地址和内存中的值，展示了动态分配的内存的布局。</p><ul><li>内存地址和数据：<ul><li>你可以看到分配的内存从地址 <code>0x206334937D0</code> 开始，每个地址对应一组二进制数据，展示了<strong>堆上的内存内容</strong>。</li><li>内存地址的后面显示了该地址处存储的值。例如，地址 <code>0x206334937B0</code> 对应的值是 <code>00001000</code>。</li></ul></li></ul><p>这些数据展示了动态分配内存块中的内容。通常调试工具会显示类似的信息，以帮助开发者了解程序的内存使用情况。</p><p><strong>6. “cookie”</strong></p><ul><li><strong>Cookie（堆检查标记）</strong>：通常在<strong>堆分配器</strong>中，会在<strong>内存块的前后添加一些标记位或特殊的“cookie”值</strong>，用于检测是否存在<strong>内存越界写入或者非法内存访问</strong>。当程序对动态内存进行越界操作时，可能会破坏这些“cookie”值，从而触发内存错误的警告或检测。</li></ul><p>在这张PPT中，<code>cookie</code> 表示在内存分配或释放时用于检测非法访问或保护内存的机制。</p><p><strong>7. 内存管理方式：<code>brk</code> 和 <code>mmap</code></strong></p><ul><li><code>brk</code> 和 <code>mmap</code>是 Linux 操作系统中两种不同的内存管理方式：<ul><li><strong><code>brk</code></strong>：是通过调整堆的顶部（<code>program break</code>）来动态分配内存的方式。通过增加 <code>brk</code> 值，程序可以从操作系统请求更多的堆内存。</li><li><strong><code>mmap</code></strong>：是一种通过内存映射机制直接从操作系统分配内存块的方式，通常用于分配较大的内存块或者在某些情况下更高效的内存管理。</li></ul></li></ul><p>这两种机制都是Linux系统中常用的内存分配方式，它们被用来管理程序的堆内存。</p><ul><li>图示中的<code>fd fd fd fd</code> 是调试工具自动填充的字节模式，表示这些内存区域曾经被释放或标记为不再有效。如果在程序运行中不小心访问这些内存区域，通常意味着你正在使用已经释放的内存，这可能会导致程序崩溃或产生不可预期的行为。</li></ul><h2 id="RAII">RAII</h2><p>在C++中，RAII（Resource Acquisition Is Initialization，<strong>资源获取即初始化</strong>）是一种管理资源（如内存、文件句柄、网络连接等）的编程惯用法。RAII的核心思想是将**资源的生命周期与对象的生命周期绑定在一起，通过对象的构造函数获取资源，通过析构函数释放资源。**这样一来，当对象的作用域结束时（无论是正常退出还是异常退出），资源都会自动得到释放，避免资源泄露和重复释放的问题。</p><p><strong>具体机制</strong></p><ol><li><strong>构造函数负责获取资源</strong>：当一个对象被创建时，构造函数会同时分配资源。这些资源可能是动态内存、文件句柄、互斥锁等。</li><li><strong>析构函数负责释放资源</strong>：当对象的生命周期结束（对象超出作用域或被显式销毁）时，析构函数会被<strong>自动调用，释放对象持有的资源</strong>。这样，不需要手动管理资源的释放。</li></ol><p><strong>RAII的优点</strong></p><ol><li><strong>异常安全</strong>：如果在代码执行过程中发生异常，RAII保证了所有资源会在对象析构时自动释放，而不会因为异常的传播导致资源泄露。</li><li><strong>易于使用</strong>：RAII隐藏了资源管理的复杂性，开发者不需要显式地管理资源的释放，减少了手动释放资源的风险（如忘记释放、释放多次等）。</li></ol><p><strong>常见的RAII实现</strong></p><ul><li><strong><code>std::unique_ptr</code> 和 <code>std::shared_ptr</code></strong>：用于管理动态内存，自动释放内存等，见后续说明</li></ul><h3 id="RAII实现1-unique-ptr">RAII实现1 unique_ptr</h3><p><strong>1. <code>unique_ptr</code> 是什么？</strong></p><p><code>unique_ptr</code> 是C++标准库中的智能指针之一，它有如下特点：</p><ul><li><strong>唯一拥有</strong>：<code>unique_ptr</code> 拥有它所指向的对象，意味着<strong>同一时刻只能有一个 <code>unique_ptr</code> 指针管理某块内存</strong>。当 <code>unique_ptr</code> 被销毁、重置或指向另一对象时，它<strong>管理的内存会被自动释放</strong>。</li><li><strong>不可复制</strong>：<code>unique_ptr</code> 不允许被复制（拷贝语义被禁用），所以它不能被赋值给另一个 <code>unique_ptr</code>。但是可以通过 <strong>转移所有权</strong>（move semantics）将 <code>unique_ptr</code> 的所有权转移到另一个 <code>unique_ptr</code>。</li></ul><p><strong>2. <code>unique_ptr</code> 的特点</strong></p><ul><li><strong>自动管理内存</strong>：<code>unique_ptr</code> 在其生命周期结束时会自动释放内存，不需要手动调用 <code>delete</code>。</li><li><strong>不可复制，但可以移动</strong>：<code>unique_ptr</code> 遵循独占所有权原则，因此不允许多个指针同时管理同一块内存。如果你想将所有权转移给另一个 <code>unique_ptr</code>，需要使用 <strong>移动语义</strong>（<code>std::move</code>）。</li><li><strong>资源安全释放</strong>：即使在异常情况下（如抛出异常时），<code>unique_ptr</code> 也能确保其所管理的内存被安全释放。</li></ul><p><strong>3. 如何使用 <code>unique_ptr</code></strong></p><p><strong>3.1 基本用法</strong></p><p><code>unique_ptr</code> 用于替代传统的手动内存管理。下面是基本的使用示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>  <span class="comment">// 包含unique_ptr的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;  <span class="comment">// 使用unique_ptr管理动态分配的int</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; *p1 &lt;&lt; std::endl;         <span class="comment">// 通过解引用访问p1管理的内存</span></span><br><span class="line">    <span class="comment">// 不需要手动delete，p1超出作用域时会自动释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>p1</code> 是一个 <code>unique_ptr</code>，它管理着通过 <code>new int(10)</code> 动态分配的内存。<code>unique_ptr</code> 确保在 <code>main()</code> 函数结束时自动释放内存，不需要手动调用 <code>delete</code>。</p><p><strong>3.2 使用工厂函数 <code>std::make_unique</code></strong></p><p>C++14 之后引入了 <code>std::make_unique</code> 工厂函数来简化创建 <code>unique_ptr</code> 的过程，避免直接使用 <code>new</code>。推荐使用这种方式来分配和初始化 <code>unique_ptr</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p2 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>);  <span class="comment">// 使用std::make_unique创建unique_ptr</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; *p2 &lt;&lt; std::endl;        <span class="comment">// 输出20</span></span><br><span class="line">    <span class="comment">// 不需要手动delete</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>std::make_unique</code> 的好处是它避免了直接使用 <code>new</code>，从而减少了代码中可能的错误（如内存泄漏）。</p><p><strong>3.3 传递和返回 <code>unique_ptr</code></strong></p><p>由于 <code>unique_ptr</code> 不能复制，所以如果要将 <code>unique_ptr</code> <strong>作为参数传递或从函数返回时</strong>，应该使用 <strong>移动语义</strong>。</p><p><strong>传递 <code>unique_ptr</code> 到函数：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void process(std::unique_ptr&lt;int&gt; ptr) &#123;</span><br><span class="line">    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    auto p3 = std::make_unique&lt;int&gt;(30);</span><br><span class="line">    process(std::move(p3));  // 使用std::move将所有权转移给process函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>std::move(p3)</code> 将 <code>p3</code> 的所有权转移到 <code>process()</code> 函数内，<code>p3</code> 在 <code>main()</code> 函数中不再拥有这块内存。</p><p><strong>函数返回 <code>unique_ptr</code>：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">40</span>);  <span class="comment">// 返回一个unique_ptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p4 = <span class="built_in">create</span>();  <span class="comment">// 从create函数接收unique_ptr</span></span><br><span class="line">    std::cout &lt;&lt; *p4 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数 <code>create()</code> 中，返回一个 <code>unique_ptr</code>，然后在 <code>main()</code> 函数中接收该智能指针。</p><p><strong>3.4 转移所有权</strong></p><p>由于 <code>unique_ptr</code> 的不可复制性，它可以 <strong>转移所有权</strong>（所有权从一个 <code>unique_ptr</code> 移交到另一个 <code>unique_ptr</code>）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; p5 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">50</span>);</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; p6 = std::<span class="built_in">move</span>(p5);  <span class="comment">// 将p5的所有权转移给p6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!p5) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;p5 is null&quot;</span> &lt;&lt; std::endl;  <span class="comment">// p5不再拥有这块内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; *p6 &lt;&lt; std::endl;               <span class="comment">// p6拥有这块内存，输出50</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，<code>std::move(p5)</code> 将 <code>p5</code> 的所有权转移给了 <code>p6</code>，此时 <code>p5</code> 不再指向有效内存，而 <code>p6</code> 拥有该动态分配的内存。</p><p><strong>4. <code>unique_ptr</code> 的析构函数</strong></p><p><code>unique_ptr</code> 的析构函数非常重要，它会在 <code>unique_ptr</code> 超出作用域时自动释放其管理的内存。这是 <code>RAII</code> 的核心概念之一。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; p7 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">70</span>);</span><br><span class="line">    <span class="comment">// p7 的生命周期结束时，内存会自动释放</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里 p7 已经被销毁，内存被释放</span></span><br></pre></td></tr></table></figure><p>一旦 <code>p7</code> 超出它的作用域，<code>unique_ptr</code> 会自动调用 <code>delete</code> 释放所管理的资源，避免了手动释放的麻烦和潜在的内存泄漏问题。</p><h3 id="案例-14">案例</h3><img src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241011104009441-17286146129221.png" class="" title="image-20241011104009441"><p><strong>PPT左侧代码</strong></p><p><strong>1. 传统动态内存管理中的问题</strong></p><p><strong><code>old_use(Args a)</code>：手动管理内存的方式</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">old_use</span><span class="params">(Args a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> q = <span class="keyword">new</span> <span class="built_in">Blob</span>(a);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (foo) <span class="keyword">throw</span> <span class="built_in">Bad</span>();  <span class="comment">// 会泄漏</span></span><br><span class="line">    <span class="keyword">if</span> (bar) <span class="keyword">return</span>;       <span class="comment">// 会泄漏</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">delete</span> q;              <span class="comment">// 容易忘</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中：</p><ul><li><code>auto q = new Blob(a);</code>：通过 <code>new</code> 分配动态内存，<code>q</code> 指向类型为 <code>Blob</code> 的对象。</li><li><strong>潜在的问题</strong>：如果在函数执行过程中发生异常（如 <code>throw Bad()</code>）或提早返回（<code>if (bar) return;</code>），将会导致 <code>q</code> 所指向的内存永远无法被释放，造成 <strong>内存泄漏</strong>。</li><li><strong><code>delete</code> 操作</strong>：手动释放通过 <code>new</code> 分配的内存，需要调用 <code>delete q;</code>。但是这种手动内存管理极其容易出错，特别是在复杂的控制流中，程序员可能忘记释放内存，导致内存泄漏。</li></ul><p><strong>2. <code>unique_ptr</code> 和 RAII 的引入</strong></p><p>为了避免手动管理内存带来的问题，C++引入了<strong>智能指针</strong>，特别是 <code>unique_ptr</code>。<code>unique_ptr</code> 遵循 <strong>RAII</strong> 原则，确保<strong>当对象生命周期结束时，资源自动被释放</strong>。</p><p><strong><code>newer_use(Args a)</code>：使用 <code>unique_ptr</code> 管理内存</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">newer_use</span><span class="params">(Args a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = <span class="built_in">unique_ptr</span>&lt;Blob&gt;(<span class="keyword">new</span> <span class="built_in">Blob</span>(a));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (foo) <span class="keyword">throw</span> <span class="built_in">Bad</span>();  <span class="comment">// 不会泄漏</span></span><br><span class="line">    <span class="keyword">if</span> (bar) <span class="keyword">return</span>;       <span class="comment">// 不会泄漏</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>unique_ptr</code> 的使用</strong>：使用 <code>unique_ptr&lt;Blob&gt;(new Blob(a))</code> 分配动态内存，并将其管理权交给 <code>unique_ptr</code>。当 <code>unique_ptr</code> 超出作用域（如函数结束时）时，<strong>智能指针会自动调用 <code>delete</code> 来释放内存</strong>，避免了手动释放内存的错误。</li><li><strong>RAII 原则</strong>：RAII 表示资源获取时绑定其生命周期，即当对象创建时分配资源，当对象销毁时自动释放资源。<strong><code>unique_ptr</code> 符合这一原则，当 <code>unique_ptr</code> 被销毁时，它所管理的内存也会自动释放。</strong></li><li><strong>避免内存泄漏</strong>：如果 <code>foo</code> 导致抛出异常或者 <code>bar</code> 提前返回，智能指针 <code>p</code> 的析构函数会自动释放</li></ul><p><strong>PPT右侧代码</strong></p><p>这张PPT右侧的两个类展示了一个<strong>简单的智能指针实现</strong>——<code>auto_ptr</code> 和 <code>int_ptr</code>。</p><p><strong>1. <code>auto_ptr</code> 类模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Template &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">auto_ptr</span>(T *p=<span class="number">0</span>):<span class="built_in">ptr</span>(p) &#123;&#125;   <span class="comment">// 构造函数，初始化ptr</span></span><br><span class="line">    ~<span class="built_in">auto_ptr</span>() &#123; <span class="keyword">delete</span> ptr; &#125;   <span class="comment">// 析构函数，释放ptr所指向的资源</span></span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> ptr; &#125;    <span class="comment">// 重载 -&gt; 操作符，返回ptr</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr; &#125;    <span class="comment">// 重载 * 操作符，解引用ptr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;   <span class="comment">// 指向动态分配内存的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><strong>类模板 <code>auto_ptr&lt;T&gt;</code></strong>：这是一个用于管理动态分配对象的智能指针类。它接受任意类型 <code>T</code>，并管理指向 <code>T</code> 类型对象的指针。</li><li><strong>构造函数</strong>：<code>auto_ptr(T* p=0)</code>，构造函数接受一个指向类型 <code>T</code> 的指针 <code>p</code>，默认值为 <code>0</code>（空指针）。它将 <code>ptr</code> 初始化为传入的指针 <code>p</code>。</li><li><strong>析构函数</strong>：<code>~auto_ptr()</code>，在 <code>auto_ptr</code> 的生命周期结束时，析构函数会自动调用 <code>delete</code> 来释放 <code>ptr</code> 所指向的动态内存，防止内存泄漏。</li><li><code>operator-&gt;</code>：重载箭头操作符 <code>-&gt;</code>，允许通过智能指针直接访问它所指向的对象的成员。<ul><li>示例：<code>auto_ptr-&gt;成员函数()</code> 等同于 <code>ptr-&gt;成员函数()</code>。</li></ul></li><li><code>operator*</code>：重载解引用操作符 <code>*</code>，允许通过智能指针解引用获取指向的对象。<ul><li>示例：<code>*auto_ptr</code> 等同于 <code>*ptr</code>。</li></ul></li></ul><p>这个 <code>auto_ptr</code> 类类似于C++98标准库中的 <code>std::auto_ptr</code>，但由于 <code>std::auto_ptr</code> 存在所有权管理问题（不安全的复制行为），它在C++11中被弃用了。<code>unique_ptr</code> 是其更安全的替代品。</p><p><strong>2. <code>int_ptr</code> 类</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">int_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int_ptr</span>(<span class="type">int</span> *p=<span class="number">0</span>):<span class="built_in">ptr</span>(p) &#123;&#125;  <span class="comment">// 构造函数，初始化ptr</span></span><br><span class="line">    ~<span class="built_in">int_ptr</span>() &#123; <span class="keyword">delete</span> ptr; &#125;   <span class="comment">// 析构函数，释放ptr所指向的资源</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> ptr; &#125;  <span class="comment">// 重载 -&gt; 操作符，返回ptr</span></span><br><span class="line">    <span class="type">int</span>&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr; &#125;  <span class="comment">// 重载 * 操作符，解引用ptr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* ptr;   <span class="comment">// 指向动态分配int类型的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><strong><code>int_ptr</code> 类</strong>：这是一个特化用于管理 <code>int</code> 类型指针的类，与 <code>auto_ptr&lt;T&gt;</code> 类似，但它只用于管理 <code>int*</code> 类型的指针。</li><li><strong>构造函数</strong>：<code>int_ptr(int *p=0)</code>，接受一个 <code>int*</code> 类型的指针，并将其赋值给 <code>ptr</code>。同样，默认值是空指针 <code>0</code>。</li><li><strong>析构函数</strong>：在对象的生命周期结束时，<code>~int_ptr()</code> 会调用 <code>delete</code>，释放 <code>ptr</code> 所指向的 <code>int</code> 类型的内存。</li><li><strong><code>operator-&gt;</code></strong>：重载箭头操作符 <code>-&gt;</code>，允许通过 <code>int_ptr</code> 对象访问 <code>int</code> 类型指针的内容。虽然 <code>int</code> 类型没有成员函数，但为了与其他类一致，提供了该操作符。</li><li><strong><code>operator\*</code></strong>：重载解引用操作符 <code>*</code>，允许通过 <code>int_ptr</code> 访问 <code>ptr</code> 所指向的 <code>int</code> 值。</li></ul><p><strong>3. 这两个类的设计意图</strong></p><p>这两个类展示了智能指针的基本思想：</p><ul><li>自动管理动态分配的内存，通过析构函数确保资源的释放。</li><li>通过重载 <code>-&gt;</code> 和 <code>*</code> 操作符，使智能指针的使用方式与原生指针一致。</li></ul><p>两者的不同之处在于：</p><ul><li><strong><code>auto_ptr</code></strong> 是一个模板类，可以管理任意类型 <code>T</code> 的动态内存，具有通用性。</li><li><strong><code>int_ptr</code></strong> 则是特化的类，只用于管理 <code>int*</code> 类型的指针。</li></ul><p><strong>4. 与现代智能指针（如 <code>unique_ptr</code>）的对比</strong></p><p>与现代C++中的 <code>unique_ptr</code> 相比，这两个类存在一些不足：</p><ul><li><strong>所有权问题</strong>：<code>auto_ptr</code> 和 <code>int_ptr</code> 都没有处理指针所有权的转移，存在指针所有权的不安全复制问题。如果尝试拷贝 <code>auto_ptr</code>，会导致多次释放同一块内存（<code>double delete</code>），从而导致程序崩溃。</li><li><strong>移动语义</strong>：现代C++的智能指针如 <code>unique_ptr</code> 提供了 <strong>移动语义</strong>，即可以通过 <code>std::move</code> 安全地转移指针的所有权，而不会发生拷贝。</li><li><strong>线程安全</strong>：<code>auto_ptr</code> 在多线程环境下也不安全。现代智能指针如 <code>shared_ptr</code> 提供了更好的并发管理。</li></ul><h3 id="RAII实现2-shared-ptr">RAII实现2 shared_ptr</h3><p><strong>1. <code>shared_ptr</code> 是什么？</strong></p><p>多个 <code>shared_ptr</code> 可以同时指向同一个对象，并且通过 <strong>引用计数机制</strong> 来管理对象的生命周期。</p><p>当多个对象需要共享同一资源时，使用 <code>shared_ptr</code> 可以确保<strong>资源在最后一个使用者销毁时自动释放</strong>。</p><p><code>shared_ptr</code> 是 <strong>引用计数智能指针</strong>，它的主要特点是：</p><ul><li><strong>共享所有权</strong>：多个 <code>shared_ptr</code> 可以同时指向同一个对象，共享该对象的所有权。每一个 <code>shared_ptr</code> 指向该对象时，引用计数会递增；当 <code>shared_ptr</code> 被销毁或重置时，引用计数会递减。当引用计数变为 0 时，指向的对象会被销毁。</li><li><strong>自动管理内存</strong>：当引用计数归零时，<code>shared_ptr</code> 会自动释放内存，无需手动调用 <code>delete</code>。</li><li><strong>线程安全</strong>：<code>shared_ptr</code> 的引用计数是线程安全的，意味着可以在多个线程中共享同一个对象，引用计数的增加和减少不会引起数据竞争问题。</li></ul><p><strong>2. 如何使用 <code>shared_ptr</code></strong></p><p><strong>2.1 创建 <code>shared_ptr</code></strong></p><p>使用 <code>shared_ptr</code> 可以通过 <code>std::make_shared</code> 进行动态内存分配，或者通过直接构造 <code>shared_ptr</code> 对象。</p><p><strong>使用 <code>std::make_shared</code></strong>（推荐做法）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; p1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);  <span class="comment">// 创建shared_ptr，指向整数42</span></span><br><span class="line">    std::cout &lt;&lt; *p1 &lt;&lt; std::endl;  <span class="comment">// 输出42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::make_shared</code> 是推荐的方式，它不仅提供了更简洁的语法，还能减少内存分配的开销，因为它在分配对象和控制块（用于引用计数）时可以一次性完成。</p><p><strong>直接构造 <code>shared_ptr</code></strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;  <span class="comment">// 不推荐，手动使用new</span></span><br><span class="line">    std::cout &lt;&lt; *p1 &lt;&lt; std::endl;  <span class="comment">// 输出42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然可以直接通过 <code>new</code> 创建 <code>shared_ptr</code>，但不推荐，因为 <code>std::make_shared</code> 更高效且更安全。</p><p><strong>2.2 引用计数的管理</strong></p><p><code>shared_ptr</code> 通过引用计数来管理对象的生命周期。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; p1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);  <span class="comment">// 创建shared_ptr，引用计数为1</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;<span class="type">int</span>&gt; p2 = p1;  <span class="comment">// p2与p1共享对象，引用计数为2</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;use count: &quot;</span> &lt;&lt; p<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;  <span class="comment">// 输出2</span></span><br><span class="line">    &#125;  <span class="comment">// p2离开作用域，引用计数减为1</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;use count: &quot;</span> &lt;&lt; p<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;  <span class="comment">// 输出1</span></span><br><span class="line">&#125;  <span class="comment">// p1离开作用域，引用计数为0，内存被释放</span></span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li>当 <code>p1</code> 创建时，引用计数为 1。</li><li>当 <code>p2</code> 复制了 <code>p1</code>，它们共享同一块内存，引用计数增加为 2。</li><li>当 <code>p2</code> 离开作用域，引用计数减少为 1。</li><li>当 <code>p1</code> 离开作用域时，引用计数为 0，动态内存自动释放。</li></ul><p><strong>2.3 传递和返回 <code>shared_ptr</code></strong></p><p>可以安全地传递 <code>shared_ptr</code> 给函数或从函数返回，因为它支持拷贝语义，传递或返回时会增加引用计数。</p><p><strong>作为函数参数传递</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(std::shared_ptr&lt;<span class="type">int</span>&gt; sp)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; *sp &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; p = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    <span class="built_in">process</span>(p);  <span class="comment">// 引用计数增加</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;use count: &quot;</span> &lt;&lt; p.<span class="built_in">use_count</span>() &lt;&lt; std::endl;  <span class="comment">// 输出1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>从函数返回 <code>shared_ptr</code></strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">99</span>);  <span class="comment">// 返回shared_ptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; p = <span class="built_in">create</span>();  <span class="comment">// 获取函数返回的shared_ptr</span></span><br><span class="line">    std::cout &lt;&lt; *p &lt;&lt; std::endl;  <span class="comment">// 输出99</span></span><br><span class="line">&#125;</span><br><span class="line">**<span class="number">2.4</span> `shared_ptr` 的移动语义**</span><br></pre></td></tr></table></figure><p>虽然 <code>shared_ptr</code> 是可拷贝的，但在某些情况下使用移动语义更高效。例如，<strong>如果你不需要共享对象，只是想转移所有权，可以使用 <code>std::move</code>。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; p1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; p2 = std::<span class="built_in">move</span>(p1);  <span class="comment">// p1的所有权转移给p2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!p1) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;p1 is null&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p2: &quot;</span> &lt;&lt; *p2 &lt;&lt; std::endl;  <span class="comment">// 输出100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>p1</code> 的所有权通过 <code>std::move</code> 被转移给 <code>p2</code>，此时 <code>p1</code> 为空指针，只有 <code>p2</code> 继续持有该对象的所有权。</p><ol start="3"><li><strong><code>shared_ptr</code> 与 <code>unique_ptr</code> 的区别</strong></li></ol><ul><li><strong><code>shared_ptr</code> 共享所有权</strong>：<code>shared_ptr</code> 支持多个指针同时指向同一个对象，并通过引用计数管理对象的生命周期。多个 <code>shared_ptr</code> 共享同一对象时，它们的引用计数会递增，当引用计数归零时，内存会自动释放。</li><li><strong><code>unique_ptr</code> 独占所有权</strong>：<code>unique_ptr</code> 实现了独占所有权，同一时刻只有一个 <code>unique_ptr</code> 指向一个对象。它不支持拷贝操作，必须通过移动语义来转移所有权。</li></ul><p><strong>4. 循环引用问题</strong></p><p>如果两个对象相互引用对方，且都使用 <code>shared_ptr</code>，就会导致循环引用问题，即两个对象的引用计数都无法归零，造成内存泄漏。</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; next;</span><br><span class="line">    ~<span class="built_in">Node</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Node destroyed&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; n1 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line">    std::shared_ptr&lt;Node&gt; n2 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line">    n1-&gt;next = n2;</span><br><span class="line">    n2-&gt;next = n1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 由于循环引用，n1和n2都不会被销毁，导致内存泄漏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>n1</code> 和 <code>n2</code> 相互引用对方，导致它们的引用计数都不会归零，内存不会被释放。</p><p><strong>5. 解决循环引用：<code>weak_ptr</code></strong>**</p><p>为了解决循环引用问题，可以使用 <strong><code>weak_ptr</code></strong> 来打破循环引用。<code>weak_ptr</code> 是一种<strong>不增加引用计数的智能指针，它只能观察对象，而不会拥有对象。</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::weak_ptr&lt;Node&gt; next;  <span class="comment">// 使用weak_ptr打破循环引用</span></span><br><span class="line">    ~<span class="built_in">Node</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Node destroyed&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; n1 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line">    std::shared_ptr&lt;Node&gt; n2 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line">    n1-&gt;next = n2;</span><br><span class="line">    n2-&gt;next = n1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 由于weak_ptr的使用，n1和n2会被正确销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>weak_ptr</code> 不会增加引用计数，因此即使 <code>n1</code> 和 <code>n2</code> 相互引用，它们也能在引用计数归零时被正确销毁。</p><h3 id="RAII应该不包括-weak-ptr">RAII应该不包括 weak_ptr</h3><p><code>weak_ptr</code> 是 C++ 标准库中的一种智能指针，它提供了一种对对象的<strong>非拥有（non-owning）弱引用</strong>。<code>weak_ptr</code> 的主要作用是配合 <code>shared_ptr</code> 一起使用，解决**循环引用（circular reference）**的问题。它不会增加 <code>shared_ptr</code> 所指对象的引用计数，因此不会干扰对象的生命周期管理。</p><p><strong>1. <code>weak_ptr</code> 的基本概念</strong></p><ul><li><strong>弱引用</strong>：<strong><code>weak_ptr</code> 并不拥有对象的所有权，它只是指向一个 <code>shared_ptr</code> 管理的对象</strong>。因此，<code>weak_ptr</code> 不会影响 <code>shared_ptr</code> 的引用计数。即使存在多个 <code>weak_ptr</code> 指向同一个对象，也不会阻止该对象的销毁。</li><li><strong>避免循环引用</strong>：<code>weak_ptr</code> 的主要设计目的是打破循环引用的问题。当两个或多个对象互相通过 <code>shared_ptr</code> 引用对方时，会形成一个循环，导致这些对象的引用计数永远不会归零，进而无法被正确释放。<strong>通过使用 <code>weak_ptr</code>，可以打破这种循环引用。</strong></li></ul><p><strong>2. 如何使用 <code>weak_ptr</code></strong></p><p><code>weak_ptr</code> <strong>不能直接解引用访问对象</strong>（因为它不保证对象的存在），需要通过 <code>lock()</code> 方法将 <code>weak_ptr</code> 转换为 <code>shared_ptr</code>，然后才能安全地访问对象。</p><p><strong>2.1 创建 <code>weak_ptr</code></strong></p><p><code>weak_ptr</code> 通常从 <code>shared_ptr</code> 创建。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sp = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);  <span class="comment">// 创建shared_ptr</span></span><br><span class="line">    std::weak_ptr&lt;<span class="type">int</span>&gt; wp = sp;  <span class="comment">// 从shared_ptr创建weak_ptr</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Shared_ptr use count: &quot;</span> &lt;&lt; sp.<span class="built_in">use_count</span>() &lt;&lt; std::endl;  <span class="comment">// 输出1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>wp</code> 是一个指向 <code>sp</code> 管理的对象的弱引用。虽然 <code>wp</code> 指向同一个对象，但它<strong>不会增加引用计数</strong>，所以 <code>sp.use_count()</code> 输出仍为 1。</p><p><strong>2.2 访问 <code>weak_ptr</code> 指向的对象</strong></p><p>要从 <code>weak_ptr</code> 中访问对象，必须使用 <code>lock()</code> 方法将其转换为 <code>shared_ptr</code>。如果对象仍然存在，<code>lock()</code> 会返回一个指向该对象的 <code>shared_ptr</code>；如果对象已被销毁，<code>lock()</code> 返回一个空的 <code>shared_ptr</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sp = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">200</span>);  <span class="comment">// 创建shared_ptr</span></span><br><span class="line">    std::weak_ptr&lt;<span class="type">int</span>&gt; wp = sp;  <span class="comment">// 创建weak_ptr</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> spt = wp.<span class="built_in">lock</span>()) &#123;  <span class="comment">// 使用lock()获取shared_ptr</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Weak_ptr is valid, value: &quot;</span> &lt;&lt; *spt &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Weak_ptr is expired&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp.<span class="built_in">reset</span>();  <span class="comment">// 手动释放shared_ptr</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> spt = wp.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Weak_ptr is valid, value: &quot;</span> &lt;&lt; *spt &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Weak_ptr is expired&quot;</span> &lt;&lt; std::endl;  <span class="comment">// 现在对象已经被释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Weak_ptr is valid, value: 200</span><br><span class="line">Weak_ptr is expired</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li>使用 <code>lock()</code> 检查 <code>weak_ptr</code> 指向的对象是否有效。如果有效，<code>lock()</code> 返回一个 <code>shared_ptr</code>，可以正常解引用访问对象。</li><li>当 <code>shared_ptr</code> 释放其所管理的对象（通过 <code>sp.reset()</code>），<code>weak_ptr</code> 会失效（即变为 expired），<code>lock()</code> 返回空的 <code>shared_ptr</code>。</li></ul><p><strong>2.3 检查 <code>weak_ptr</code> 是否失效</strong></p><p>可以通过 <code>expired()</code> 方法检查 <code>weak_ptr</code> 是否失效：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (wp.<span class="built_in">expired</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Weak_ptr has expired&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Weak_ptr is still valid&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>expired()</code> 返回 <code>true</code>，表示对象已被销毁，<code>weak_ptr</code> 变得无效。</li><li><code>expired()</code> 返回 <code>false</code>，表示对象仍然存在。</li></ul><ol start="3"><li><strong>打破循环引用问题</strong></li></ol><p>循环引用是指多个对象互相持有 <code>shared_ptr</code>，导致它们的引用计数无法归零，从而无法释放内存。这是 <code>shared_ptr</code> 的一个常见问题，但可以通过 <code>weak_ptr</code> 来解决。</p><p><strong>循环引用示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; next;</span><br><span class="line">    ~<span class="built_in">Node</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Node destroyed&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; n1 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line">    std::shared_ptr&lt;Node&gt; n2 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line">    n1-&gt;next = n2;  <span class="comment">// n1指向n2</span></span><br><span class="line">    n2-&gt;next = n1;  <span class="comment">// n2指向n1，形成循环引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// n1和n2不会被销毁，内存泄漏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>n1</code> 和 <code>n2</code> 互相持有对方的 <code>shared_ptr</code>，这导致它们的引用计数永远不会降为 0，最终内存泄漏。</p><p><strong>使用 <code>weak_ptr</code> 打破循环引用：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">struct Node &#123;</span><br><span class="line">    std::weak_ptr&lt;Node&gt; next;  // 使用weak_ptr避免循环引用</span><br><span class="line">    ~Node() &#123; std::cout &lt;&lt; &quot;Node destroyed&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; n1 = std::make_shared&lt;Node&gt;();</span><br><span class="line">    std::shared_ptr&lt;Node&gt; n2 = std::make_shared&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line">    n1-&gt;next = n2;  // n1指向n2</span><br><span class="line">    n2-&gt;next = n1;  // n2通过weak_ptr指向n1，打破循环引用</span><br><span class="line"></span><br><span class="line">    return 0;  // n1和n2会被正确销毁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>n2</code> 持有对 <code>n1</code> 的弱引用，这样即使 <code>n1</code> 和 <code>n2</code> 互相引用，当 <code>n1</code> 和 <code>n2</code> 离开作用域时，它们的引用计数都会降为 0，最终正确释放内存。</p><p><strong>4. <code>weak_ptr</code> 的生命周期管理</strong></p><ul><li><strong>不会延长对象的生命周期</strong>：<code>weak_ptr</code> 不增加引用计数，因此它不会阻止对象的销毁。对象的生命周期完全由 <code>shared_ptr</code> 管理。</li><li><strong>不会直接访问对象</strong>：<code>weak_ptr</code> 不能像 <code>shared_ptr</code> 那样直接解引用访问对象，因为它不能保证对象仍然存在。要访问对象，需要调用 <code>lock()</code>。</li><li><strong>避免悬空指针</strong>：当 <code>shared_ptr</code> 被销毁时，所有指向同一个对象的 <code>weak_ptr</code> 会自动失效。调用 <code>lock()</code> 时，如果对象已销毁，<code>lock()</code> 会返回空的 <code>shared_ptr</code>，从而避免悬空指针。</li></ul><h3 id="案例-15">案例</h3><img src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241011105509353.png" class="" title="image-20241011105509353"><p><strong>1. 创建 <code>shared_ptr</code> 对象</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; shared_p&#123; <span class="keyword">new</span> <span class="type">int</span>&#123;<span class="number">1</span>&#125; &#125;;  <span class="comment">// = make_shared&lt;int&gt;(1);</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;shared_p: &quot;</span> &lt;&lt; *shared_p &lt;&lt; <span class="string">&quot; count: &quot;</span> &lt;&lt; shared_p.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><ul><li>创建 <code>shared_ptr</code>：<code>shared_p</code>指向一个动态分配的整数1<ul><li>这里可以使用 <code>new</code> 直接初始化，但<strong>推荐使用 <code>make_shared</code></strong>，因为它更高效且减少了潜在的内存分配错误。</li></ul></li><li><strong><code>use_count()</code> 输出</strong>：<code>shared_ptr</code> 的引用计数会初始化为 <strong>1</strong>，表示当前有一个 <code>shared_ptr</code> 拥有该资源。</li></ul><p><strong>2. 复制 <code>shared_ptr</code> 增加引用计数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; shared_p_ref = shared_p;</span><br><span class="line">*shared_p_ref = <span class="number">11</span>;  <span class="comment">// 修改 shared_p_ref 所指向的对象</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;add a ref :&quot;</span> &lt;&lt; endl</span><br><span class="line">     &lt;&lt; <span class="string">&quot;shared_p :&quot;</span> &lt;&lt; *shared_p &lt;&lt; <span class="string">&quot; count:&quot;</span> &lt;&lt; shared_p.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><ul><li><strong><code>shared_ptr</code> 拷贝</strong>：<code>shared_p_ref</code> 是 <code>shared_p</code> 的副本。它们共享同一个对象，并且<strong>引用计数增加到 2</strong>。</li><li><strong>修改对象</strong>：修改 <code>shared_p_ref</code> 中的值会同步反映在 <code>shared_p</code> 上。</li></ul><p><strong>3. 创建 <code>weak_ptr</code> 指向 <code>shared_ptr</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">weak_ptr&lt;<span class="type">int</span>&gt; weak_p&#123; shared_p &#125;;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;add a weak :&quot;</span> &lt;&lt; endl</span><br><span class="line">     &lt;&lt; <span class="string">&quot; shared_p: &quot;</span> &lt;&lt; *shared_p &lt;&lt; <span class="string">&quot; count: &quot;</span> &lt;&lt; shared_p.<span class="built_in">use_count</span>() &lt;&lt; endl</span><br><span class="line">     &lt;&lt; <span class="string">&quot; weak_p: &quot;</span> &lt;&lt; weak_p.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><ul><li><strong><code>weak_ptr</code></strong>：<code>weak_p</code> 是指向 <code>shared_p</code> 的<strong>弱引用</strong>，它不会增加引用计数。</li><li><strong><code>use_count()</code> 输出</strong>：虽然 <code>weak_ptr</code> 存在，但 <code>shared_ptr</code> 的引用计数仍为 <strong>2</strong>。<code>weak_p.use_count()</code> 返回 <code>2</code>，代表当前有两个 <code>shared_ptr</code> 拥有该资源。</li></ul><p><strong>4. 使用 <code>lock()</code> 从 <code>weak_ptr</code> 获取 <code>shared_ptr</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> temp = weak_p.<span class="built_in">lock</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;after lock :&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">nullptr</span> == temp)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;shared resource expired&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    *temp = <span class="number">111</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;shared_p: &quot;</span> &lt;&lt; *shared_p &lt;&lt; <span class="string">&quot; count:&quot;</span> &lt;&lt; shared_p.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>lock()</code></strong>：将 <code>weak_ptr</code> 转换为 <code>shared_ptr</code>，如果资源存在，则成功获取一个新的 <code>shared_ptr</code>，否则返回 <code>nullptr</code>。</li><li><strong>检查是否成功</strong>：如果 <code>temp</code> 不是空指针，则修改其值，并打印引用计数。</li></ul><p><strong>输出：</strong></p><ul><li>此时 <code>shared_p</code> 的引用计数为 <strong>3</strong>，因为 <strong><code>temp</code> 也是一个 <code>shared_ptr</code>。</strong></li></ul><p><strong>5. 重置 <code>shared_ptr</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shared_p.reset(new int&#123;2&#125;);  // 重新指向一个新对象</span><br><span class="line">cout &lt;&lt; &quot;shared_p moved &quot; &lt;&lt; endl</span><br><span class="line">     &lt;&lt; &quot;shared_p &quot; &lt;&lt; *shared_p &lt;&lt; &quot; count: &quot; &lt;&lt; shared_p.use_count() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;shared_p_ref: &quot; &lt;&lt; *shared_p_ref &lt;&lt; &quot; count: &quot; &lt;&lt; shared_p_ref.use_count() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><ul><li><strong><code>reset()</code></strong>：<code>shared_p</code> 被重置，指向一个新的整数 <code>2</code>。旧的资源引用计数减少，此时<strong>旧资源只有 <code>shared_p_ref</code> 拥有</strong>，引用计数为 1。</li><li><strong>新对象</strong>：<code>shared_p</code> 现在指向一个新分配的整数 <code>2</code>（因为还有temp），其引用计数为 2。</li></ul><p><strong>6. 总结：<code>shared_ptr</code> 和 <code>weak_ptr</code> 的关系</strong></p><ul><li><strong><code>shared_ptr</code></strong>：管理对象的所有权，通过引用计数管理其生命周期。多个 <code>shared_ptr</code> 可以共享同一个对象。</li><li><strong><code>weak_ptr</code></strong>：不会增加引用计数，只用于观察对象，避免循环引用问题。需要通过 <code>lock()</code> 方法访问资源。</li></ul><p><strong>引用计数的变化：</strong></p><ol><li><code>shared_p</code> 创建时，计数为 1。</li><li>复制给 <code>shared_p_ref</code>，计数变为 2。</li><li>创建 <code>weak_p</code> 后，引用计数保持为 2。</li><li>使用 <code>lock()</code> 获取 <code>temp</code> 后，计数变为 3。</li><li>重置 <code>shared_p</code> 后，新对象计数为 1，旧对象只剩下 <code>shared_p_ref</code>和<code>temp</code>，计数为2。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++高级程序设计笔记（C7）</title>
      <link href="/2025/01/25/C7/"/>
      <url>/2025/01/25/C7/</url>
      
        <content type="html"><![CDATA[<h1>C7</h1><h2 id="程序组织">程序组织</h2><h3 id="示例">示例</h3><img src="/2025/01/25/C7/image-20241029141243146.png" class="" title="image-20241029141243146"><p>这张PPT展示了<strong>C++程序的组织结构</strong>，主要通过头文件和源文件的划分来组织代码，并且强调了不同的<strong>作用域（Scope）</strong>。代码分布在三个文件中：<code>a.h</code>、<code>const.h</code>、<code>a.cpp</code> 和 <code>b.cpp</code>。</p><ol><li><strong>a.h</strong> — 头文件</li></ol><ul><li><p><code>a.h</code> 是一个头文件，通常用于声明在多个文件中共享的变量和函数。</p></li><li><p>文件内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">float</span> salary;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>extern float salary;</code>：这是一个外部变量声明，表示变量 <code>salary</code> 在其他文件中定义（例如 <code>a.cpp</code> 中），可以在其他文件中使用。</li><li><code>extern void show();</code>：这是一个外部函数声明，表示 <code>show</code> 函数在其他文件中定义，也可以在其他文件中使用。</li></ul><p>头文件中使用 <code>extern</code> 关键字可以避免变量和函数的重复定义，<strong>使变量和函数在多个文件中共享。</strong></p></li></ul><ol start="2"><li><strong>const.h</strong> — 常量头文件</li></ol><ul><li><p><code>const.h</code> 用于定义常量，它只包含一个常量定义。</p></li><li><p>文件内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure><ul><li><code>const double pi = 3.14;</code>：这是一个全局常量，表示圆周率的值为3.14。在多个文件中使用该常量时，通过包含 <code>const.h</code> 即可，不会产生重复定义的问题，因为 <code>const</code> 常量默认具有内部链接性。</li></ul><p><strong>常量头文件在项目中常用于集中定义全局常量</strong>，方便管理和修改。</p></li></ul><ol start="3"><li><strong>a.cpp</strong> — 源文件A</li></ol><ul><li><code>a.cpp</code> 是一个源文件，主要<strong>定义了 <code>a.h</code> 中声明的变量和函数</strong>，并包含了 <code>const.h</code> 头文件。</li><li>文件内容：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;const.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> salary = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (...) &#123;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="comment">// 块级代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>#include &quot;const.h&quot;</code>：通过包含 <code>const.h</code>，可以在 <code>a.cpp</code> 中使用常量 <code>pi</code>。</p></li><li><p><code>static int count = 0;</code>：<code>count</code> 是一个静态局部变量，具有<strong>文件级</strong>作用域（即仅在 <code>a.cpp</code> 文件内部可见）。</p></li><li><p><code>float salary = 0;</code>：这是变量 <code>salary</code> 的定义，<strong>对应于 <code>a.h</code> 中的声明。</strong></p></li><li><p><code>void show()</code>：这是 <code>show</code> 函数的定义，<strong>对应于 <code>a.h</code> 中的声明。</strong></p></li><li><p><code>static void process()</code>：<code>process</code> 函数使用 <code>static</code> 修饰，具有文件级作用域，仅在 <code>a.cpp</code> 文件内部可见。</p></li><li><p><code>process</code> 函数内部：</p><ul><li><code>int i = 0;</code> 和 <code>char c;</code> 是局部变量，具有块级作用域，仅在 <code>process</code> 函数内部可见。</li></ul></li></ul></li></ul><ol start="4"><li><strong>b.cpp</strong> — 源文件B</li></ol><ul><li><code>b.cpp</code> 是另一个源文件，包含了 <code>a.h</code> 和 <code>const.h</code>，可以使用 <code>a.h</code> 中声明的变量和函数，以及 <code>const.h</code> 中定义的常量。</li><li>文件内容：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;const.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    salary = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span> (...) &#123;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="comment">// 块级代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="comment">// main函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>#include &quot;a.h&quot;</code>：包含了 <code>a.h</code>，<strong>因此可以使用 <code>a.h</code> 中声明的 <code>salary</code> 和 <code>show</code>。</strong></p></li><li><p><code>#include &quot;const.h&quot;</code>：包含了 <code>const.h</code>，因此可以使用常量 <code>pi</code>。</p></li><li><p><code>static int count = 0;</code>：<code>count</code> 是 <code>b.cpp</code> 文件中的静态变量，具有文件级作用域，<strong>与 <code>a.cpp</code> 文件中的 <code>count</code> 是独立的</strong>。</p></li><li><p><code>static void process()</code>：<code>process</code> 函数在 <code>b.cpp</code> 文件中定义，具有文件级作用域，<strong>与 <code>a.cpp</code> 中的 <code>process</code> 是不同的函数。</strong></p></li><li><p><code>process</code> 函数内部：</p><ul><li><code>static int k = 0;</code>：<code>k</code> 是 <code>process</code> 函数中的静态局部变量，具有块级作用域，<strong>但其值在函数调用之间保持不变</strong>。</li><li><code>salary = 100;</code>：<code>salary</code> 是一个全局变量，通过 <code>extern</code> 引入，<strong>因此在 <code>b.cpp</code> 中可以修改其值</strong>。</li><li><code>show();</code>：调用 <code>a.h</code> 中声明的 <code>show</code> 函数。</li></ul></li><li><p><code>void main()</code>：这是 <code>main</code> 函数的定义，程序的入口点。<code>int x;</code> 是局部变量，具有块级作用域，仅在 <code>main</code> 函数内部可见。</p></li></ul></li></ul><ol start="5"><li><strong>作用域（Scope）</strong></li></ol><p>PPT中标注了几个作用域，分别是<strong>程序级</strong>、<strong>文件级</strong>、<strong>函数级</strong>和<strong>块级</strong>，解释如下：</p><ul><li><p><strong>程序级</strong>：程序级作用域表示<strong>整个程序中都可以访问的变量或函数</strong>，例如 <strong><code>extern</code> 声明的变量和函数，以及包含在头文件中的常量</strong>。</p></li><li><p><strong>文件级</strong>：文件级作用域表示<strong>仅在当前源文件中可见的变量或函数</strong>，例如<strong>用 <code>static</code> 修饰</strong>的 <code>count</code> 和 <code>process</code> 函数。这种作用域用于<strong>避免在多个文件中定义同名变量或函数时产生冲突</strong>。</p></li><li><p><strong>函数级</strong>：函数级作用域指的是<strong>函数内部定义的变量或静态变量</strong>，例如 <code>process</code> 函数内的 <code>static int k</code>。</p></li><li><p><strong>块级</strong>：块级作用域表示在代码块 <code>&#123;&#125;</code> 中定义的变量，只在该代码块内有效。例如 <code>process</code> 函数中的 <code>int i</code> 和 <code>char c</code>。</p></li></ul><p><strong>总结</strong></p><ul><li><strong>头文件（Header files）</strong>：<code>a.h</code> 和 <code>const.h</code> 用于声明全局变量、常量和函数，使得不同的源文件可以共享这些声明。</li><li><strong>源文件（Source files）</strong>：<code>a.cpp</code> 和 <code>b.cpp</code> 是实现文件，分别定义了各自的变量和函数，并通过 <code>static</code> 控制文件级作用域。</li><li><strong>作用域的控制</strong>：通过 <code>static</code> 控制文件级作用域，通过 <code>extern</code> 引入全局变量，充分利用C++的作用域控制机制组织代码，避免冲突并提高代码的可维护性。</li></ul><h2 id="namespace">namespace</h2><h3 id="示例-2">示例</h3><img src="/2025/01/25/C7/image-20241029142815805.png" class="" title="image-20241029142815805"><p>这张PPT讲解了C++中的**命名空间（namespace）**以及两种使用命名空间的方式：<strong>using declaration</strong> 和 <strong>using directive</strong>。此外，PPT还提到命名空间在限定作用域方面可以替代<code>static</code>。</p><ol><li><strong>命名空间（namespace）</strong></li></ol><p>命名空间是一种在C++中引入的工具，用于组织代码、避免名字冲突。当代码库变得越来越大时，<strong>不同模块之间可能会使用相同的变量名</strong>、函数名或者类名，<strong>命名空间可以帮助我们将这些名称分组，避免冲突。</strong></p><p>命名空间的定义示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> L &#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 其他声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>L</code> 是命名空间的名称，命名空间 <code>L</code> 中包含了一个整数 <code>k</code> 和一个函数 <code>f(int)</code>。<strong>为了使用命名空间中的内容，C++ 提供了 <code>using declaration</code> 和 <code>using directive</code> 两种方式。</strong></p><ol start="2"><li><strong>两种形式：declaration 和 directive</strong></li></ol><p>(1) Using Declaration（using 声明）</p><p><code>using declaration</code> 用于<strong>引入命名空间中的特定名称</strong>。它仅将命名空间中的<strong>某个名称</strong>引入当前作用域，而<strong>不会引入整个命名空间</strong>。</p><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> L::k;</span><br><span class="line"><span class="keyword">using</span> L::f;</span><br><span class="line"></span><br><span class="line">k = <span class="number">0</span>;    <span class="comment">// 使用命名空间 L 中的变量 k</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">6</span>);     <span class="comment">// 使用命名空间 L 中的函数 f</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们通过 <code>using L::k;</code> 和 <code>using L::f;</code> 分别引入了 <code>k</code> 和 <code>f</code>，因此可以直接使用 <code>k</code> 和 <code>f</code>，而不需要在前面加上 <code>L::</code>。</p><p><strong>优点：</strong></p><ul><li><code>using declaration</code> 可以控制引入的名称，避免引入命名空间中的所有名称，从而减少命名冲突的风险。</li><li>当只需要命名空间中的特定成员时，<code>using declaration</code> 是更好的选择。</li></ul><p>(2) Using Directive（using 指令）</p><p><code>using directive</code> 是将<strong>整个命名空间引入当前作用域</strong>，它会将命名空间中的所有名称引入。</p><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> L;</span><br><span class="line"></span><br><span class="line">k = <span class="number">0</span>;    <span class="comment">// 直接使用 L 中的 k</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">6</span>);     <span class="comment">// 直接使用 L 中的 f</span></span><br></pre></td></tr></table></figure><p>在这个例子中，通过 <code>using namespace L;</code>，整个命名空间 <code>L</code> 中的所有成员都可以在当前作用域中直接使用。这意味着可以直接访问 <code>L</code> 中的所有变量和函数。</p><p><strong>优点和缺点：</strong></p><ul><li><strong>优点</strong>：简化了代码，特别是当需要频繁访问命名空间中的多个成员时。</li><li><strong>缺点</strong>：可能会引入意外的命名冲突，尤其是在多个命名空间都包含相同名称的成员时。因此，<code>using directive</code> 更适合在小型文件或者局部作用域中使用，避免引入全局命名冲突。</li></ul><ol start="3"><li><strong>命名空间与<code>static</code>的替代关系</strong></li></ol><p>PPT中提到“在约束作用域方面，替代 <code>static</code>”。这意味着命名空间在限制符号作用域时，提供了类似 <code>static</code> 的效果。在C语言中，<strong><code>static</code> 常用于限制变量和函数的作用域，使它们只在定义的文件内部可见</strong>。但在C++中，我们可以通过命名空间和<code>using declaration</code>等特性实现更灵活的作用域控制。</p><p><strong>示例：</strong></p><ul><li><p>在C语言中，我们可能会这样写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;  <span class="comment">// 仅在当前文件可见</span></span><br></pre></td></tr></table></figure></li><li><p>在C++中，可以使用命名空间来实现类似效果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;  <span class="comment">// 仅在当前文件可见的匿名命名空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在这里，匿名命名空间（即没有名字的 <code>namespace</code>）中的 <code>count</code> 变量也只能在当前文件中使用，达到了与 <code>static</code> 类似的效果。</p><ol start="4"><li><strong>using declaration 与 using directive 的区别</strong><ul><li><strong>使用范围</strong>：<ul><li><code>using declaration</code> 仅引入命名空间中的某个特定成员，控制更精细。</li><li><code>using directive</code> 引入整个命名空间的所有成员，方便但容易产生命名冲突。</li></ul></li><li><strong>命名冲突</strong>：<ul><li><code>using declaration</code> 仅引入指定成员，因此不容易引发命名冲突。</li><li><code>using directive</code> 引入整个命名空间，若多个命名空间中有重名的成员，可能导致冲突。</li></ul></li></ul></li><li><strong>总结</strong></li></ol><ul><li><strong>命名空间</strong>是一种用于组织代码和避免名称冲突的工具，特别是在大型项目中，可以有效管理不同模块之间的名称。</li><li><strong>using declaration</strong> 和 <strong>using directive</strong> 是使用命名空间成员的两种方式：<ul><li><code>using declaration</code> 引入命名空间中的特定成员，适合在需要精确控制名称时使用。</li><li><code>using directive</code> 引入整个命名空间，适合在需要频繁访问命名空间中成员的场景。</li></ul></li><li><strong>命名空间替代 <code>static</code></strong>：命名空间可以通过限定作用域来达到与 <code>static</code> 类似的效果，尤其是匿名命名空间，能够限制符号在文件内的可见性。</li></ul><h3 id="示例-3">示例</h3><img src="/2025/01/25/C7/image-20241029143357005.png" class="" title="image-20241029143357005"><p>这张PPT深入讲解了C++命名空间的高级特性，包括<strong>别名</strong>、<strong>全局</strong>、<strong>开放</strong>、<strong>可嵌套</strong>和<strong>重载</strong>。</p><ol><li><strong>别名（Alias）</strong></li></ol><ul><li><p><strong>定义别名</strong>：命名空间别名是对现有命名空间的一个新的简写。通过给长命名空间名称创建别名，可以让代码更简洁。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> American_Telephone_and_Telegraph &#123;</span><br><span class="line">    <span class="comment">// 一些定义</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ATT = American_Telephone_and_Telegraph;</span><br></pre></td></tr></table></figure><p>在这里，<code>ATT</code> 是 <code>American_Telephone_and_Telegraph</code> 命名空间的别名。这种别名简化了对命名空间的引用，例如<strong>可以直接使用 <code>ATT::function()</code> 来调用 <code>American_Telephone_and_Telegraph::function()</code>。</strong></p></li></ul><ol start="2"><li><strong>全局（Global）</strong></li></ol><ul><li><p>在C++中，<code>::</code>（全局作用域运算符）可以用于引用全局命名空间中的变量或函数，以避免与其他命名空间中的名称冲突。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;       <span class="comment">// 全局变量 a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> X &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;  <span class="comment">// 命名空间 X 内的变量 a</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">    ::a++;      <span class="comment">// 引用全局的 a，值变为 6</span></span><br><span class="line">    X::a++;     <span class="comment">// 引用命名空间 X 中的 a，值变为 11</span></span><br><span class="line">    a++;        <span class="comment">// 引用本地变量 a，值变为 21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>f</code> 函数中，<strong><code>::a</code> 访问全局变量</strong>，<code>X::a</code> 访问命名空间 <code>X</code> 内的 <code>a</code>，而 <code>a</code> 则是局部变量。</p></li></ul><ol start="3"><li><strong>开放（Open）</strong></li></ol><ul><li><p>命名空间是开放的，意味着<strong>可以在多个位置对同一个命名空间添加内容</strong>。可以在不同的源文件中继续添加到同一个命名空间中，以便组织代码。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，<code>namespace A</code> 在两个不同的代码块中定义，并在第二个代码块中为命名空间 <code>A</code> 添加了函数 <code>f</code>。</p></li></ul><ol start="4"><li><strong>可嵌套（Nested）</strong></li></ol><ul><li><p>命名空间可以嵌套使用，即<strong>在一个命名空间内定义另一个命名空间</strong>。这种方式可以用于更细粒度地组织代码结构。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> L1 &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">namespace</span> L2 &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 在 L2 中定义函数 f</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，<code>L1</code> 是外层命名空间，<code>L2</code> 是 <code>L1</code> 的嵌套命名空间。<code>L2::f()</code> 可以通过 <code>L1::L2::f()</code> 调用。</p><p><strong>使用嵌套命名空间</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L1::L2::<span class="built_in">f</span>(); <span class="comment">// 直接调用 L2 中的 f 函数</span></span><br></pre></td></tr></table></figure></li></ul><ol start="5"><li><strong>重载（Overloading）</strong></li></ol><ul><li><p>不同命名空间中的函数可以具有相同的名字，这样即使在不同的命名空间中定义了相同的函数名，也不会产生冲突。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> B &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> B;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="string">&#x27;1&#x27;</span>);  <span class="comment">// 调用 A::f(char)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>A</code> 和 <code>B</code> 命名空间中都定义了 <code>f</code> 函数，参数类型不同。在 <code>g</code> 函数中，调用 <code>f('1')</code> 会选择合适的重载，即 <code>A::f(char)</code>。</p><p><strong>注意</strong>：PPT中有一个红色的叉号，表明<strong>不建议在同一作用域内多次使用 <code>using-directive</code></strong>。这是因为这样可能导致命名冲突和意外的行为。</p></li></ul><ol start="6"><li><strong>PPT总结</strong></li></ol><p>PPT列出了命名空间的几个重要特性，并给出了一些高级用法建议：</p><ul><li><strong>别名</strong>：可以为命名空间设置别名，使长名称更加简洁。</li><li><strong>全局</strong>：<code>::</code> 运算符可以用于访问全局命名空间中的成员，避免与局部或其他命名空间中的名称冲突。</li><li><strong>开放</strong>：命名空间是开放的，可以在不同位置添加内容，方便组织代码。</li><li><strong>可嵌套</strong>：命名空间可以嵌套，便于更好地划分代码结构。</li><li><strong>重载</strong>：不同命名空间中的函数可以重载，但在同一作用域内避免多次使用 <code>using-directive</code> 以防止冲突。</li></ul><h3 id="示例-4">示例</h3><img src="/2025/01/25/C7/image-20241029144106940.png" class="" title="image-20241029144106940"><p>这张PPT展示了一个关于C++中命名空间使用的简单示例，并建议在使用命名空间时<strong>优先考虑 using-declaration</strong>。</p><ol><li><strong>简单示例</strong></li></ol><p>代码展示了一个简单的<code>main</code>函数，用来打印 “hello, world”。在C++中，这种标准库函数（如<code>printf</code>）通常定义在<code>namespace std</code>命名空间中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C++中，如果没有<code>using</code>语句，则需要在调用标准库中的函数时使用<code>std</code>命名空间前缀。例如，<code>std::printf(&quot;hello, world\n&quot;);</code>。这确保了<code>printf</code>来自标准命名空间，避免与用户自定义的函数重名。</p><ol start="2"><li><strong>&lt;stdio.h&gt; 和命名空间 std</strong></li></ol><p>在C++标准库中，所有标准库的符号都位于<code>std</code>命名空间内，以防止命名冲突。<code>&lt;stdio.h&gt;</code>是C标准库中的头文件，定义了像<code>printf</code>这样的标准输入输出函数。虽然<code>&lt;stdio.h&gt;</code>是C的头文件，但在C++中，我们通常将其视为<code>&lt;cstdio&gt;</code>，并放入<code>std</code>命名空间中。</p><ul><li>其中为什么在调用<code>#include &lt;stdio.h&gt;</code>时不需要using namespace std呢？因为在C的.h文件中默认添加了using namespace std;</li></ul><ol start="3"><li><strong>优先考虑 using-declaration</strong></li></ol><p>PPT建议在C++中优先考虑 <strong>using-declaration</strong>，即显式引入命名空间中的某个特定成员，而不是引入整个命名空间。这样可以减少命名冲突的风险。</p><ol start="4"><li><p>参考：</p><ol><li><p>确实有必要澄清这个问题。在调用 <code>#include &lt;stdio.h&gt;</code> 时，不需要使用 <code>using namespace std;</code>，主要原因是：</p><ol><li>C 标准库头文件的兼容性</li></ol><p>C++ 中的 <code>&lt;stdio.h&gt;</code> 是从 C 标准库继承而来，但它的内容不在 <code>std</code> 命名空间中。传统 C 头文件（如 <code>&lt;stdio.h&gt;</code>、<code>&lt;stdlib.h&gt;</code> 等）并不包含在 <code>std</code> 命名空间下，因为它们是直接从 C 语言标准库引入的，C 标准库并没有使用 C++ 的命名空间机制。因此，在 C++ 中直接使用 <code>&lt;stdio.h&gt;</code> 提供的 <code>printf</code> 等函数，不需要 <code>std</code> 前缀，也不需要 <code>using namespace std;</code>。</p><ol start="2"><li>C++ 的 C 标准库头文件（<code>&lt;cstdio&gt;</code>）</li></ol><p>为了更符合 C++ 的命名空间管理，C++ 标准库提供了 C 标准库头文件的 C++ 版本，如 <code>&lt;cstdio&gt;</code> 对应于 <code>&lt;stdio.h&gt;</code>，<code>&lt;cstdlib&gt;</code> 对应于 <code>&lt;stdlib.h&gt;</code> 等。这些 C++ 版本的头文件会将 C 标准库的符号放入 <code>std</code> 命名空间中。因此，如果在 C++ 中包含 <code>&lt;cstdio&gt;</code> 而不是 <code>&lt;stdio.h&gt;</code>，就需要使用 <code>std::printf</code> 或者 <code>using std::printf;</code>。</p><ol start="3"><li>总结</li></ol><ul><li><strong><code>#include &lt;stdio.h&gt;</code></strong>：直接包含传统的 C 头文件，<code>printf</code> 位于全局命名空间，无需 <code>std</code> 前缀。</li><li><strong><code>#include &lt;cstdio&gt;</code></strong>：包含 C++ 版本的头文件，C 标准库中的符号会被放入 <code>std</code> 命名空间中，需要使用 <code>std::printf</code> 或 <code>using std::printf;</code>。</li></ul></li></ol></li></ol><h2 id="编译预处理">编译预处理</h2><h3 id="示例-5">示例</h3><img src="/2025/01/25/C7/image-20241029151204519.png" class="" title="image-20241029151204519"><p>这张PPT主要讨论了C++中的编译预处理（Preprocessing）和编译指令替换的概念，并结合了一个代码示例，展示了如何通过预定义宏来替换函数的行为。</p><ol><li><strong>编译预处理（Preprocessing）</strong></li></ol><p>编译预处理是在C/C++编译器真正编译代码之前的一个阶段，负责处理<strong>头文件包含、宏定义、条件编译</strong>等内容。PPT中的“编译预处理”就是指<strong>在编译过程中可以用宏定义和其他预处理指令来调整代码</strong>的编译方式。</p><ul><li><p><strong>代码示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">double</span> <span class="title">sqrt</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The square root of 2 is %g\n&quot;</span>, <span class="built_in">sqrt</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码片段中，<code>extern double sqrt(double);</code> 是一个外部函数声明，表示我们希望使用外部库中的 <code>sqrt</code> 函数来计算平方根。同时使用了<code>printf</code>来输出结果。</p></li></ul><ol start="2"><li><strong>示例输出和替换效果</strong></li></ol><ul><li><p><strong>正常情况输出</strong>：<br>正常编译时，<code>sqrt(2)</code> 会返回 2 的平方根 <code>1.41421</code>，并输出 <code>The square root of 2 is 1.41421</code>。这个输出展示了正确的 <code>sqrt</code> 函数的行为。</p></li><li><p><strong>使用宏替换</strong>：<br>PPT中给出的编译命令行参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -7 -Dsqrt=rand -Dreturn=<span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>这里通过<code>-D</code>选项定义了两个宏替换规则：</p><ul><li><code>-Dsqrt=rand</code>：将<code>sqrt</code>函数替换为<code>rand</code>函数。这意味着代码中的<code>sqrt(2)</code>会被替换成<code>rand()</code>，即随机数生成函数。<code>rand</code>函数返回一个伪随机整数，导致输出的结果不再是 2 的平方根，而是一个随机值。</li><li><code>-Dreturn=exit</code>：将<code>return</code>语句替换为<code>exit</code>函数。这意味着<code>return(0)</code>会被替换为<code>exit(0)</code>，程序将在执行到<code>exit</code>时立即终止，而不返回到调用者。</li></ul><p><strong>替换后可能的输出</strong>：<br>替换后可能会输出一个随机数，形如 <code>The square root of 2 is 6.93232e-310</code>（实际数值会根据 <code>rand</code> 的返回值有所不同），这并非正确的平方根结果，而是<code>rand</code>函数产生的随机数。</p></li></ul><ol start="3"><li><strong>与作用域、类型和接口不兼容</strong></li></ol><ul><li><p><strong>潜伏于环境</strong>：<br>PPT中提到“潜伏于环境”指的是宏替换会在代码中进行“静态文本替换”，而不考虑代码的作用域、类型检查或函数接口。因此，宏替换可能会潜在地影响程序的环境，使代码变得难以理解和维护。例如，<code>sqrt</code>被替换为<code>rand</code>后，<code>sqrt(2)</code>实际上调用了一个不需要参数的随机数生成函数<code>rand</code>，导致了潜在的错误行为。</p></li><li><p><strong>穿透作用域</strong>：<br>宏替换在编译预处理阶段进行，因此它不受作用域的限制。在整个编译单元中，所有出现的<code>sqrt</code>和<code>return</code>都会被替换，无论它们出现在何处。这种“全局”替换可能会导致意料之外的副作用。例如，如果代码中有多个文件，并且它们都包含了<code>sqrt</code>函数的使用，<code>-Dsqrt=rand</code>将会影响所有包含此符号的地方，可能导致错误。</p></li></ul><ol start="4"><li><strong>设想和置换的应用</strong></li></ol><ul><li><p><strong>应用场景</strong>：<br>使用宏替换时可以实现一些应用场景的功能调整，例如通过宏定义控制调试模式和发布模式，或通过宏定义来决定是调用某个库的API还是模拟实现。</p></li><li><p><strong>替换的风险</strong>：<br>尽管宏替换提供了一定的灵活性，但这种方式容易出错，且难以维护，特别是在复杂的代码库中。宏替换不具备类型检查能力，编译器只会做字面替换，这可能导致程序运行时行为不符合预期。</p></li></ul><ol start="5"><li><strong>总结</strong></li></ol><ul><li><strong>宏替换</strong>可以让程序在编译时进行符号替换，使得代码在不同环境下实现不同的行为。</li><li><strong>风险</strong>：由于宏替换无视作用域和类型信息，它可能会影响程序的全局环境，容易引入难以调试的错误。因此，在实际应用中，使用宏替换应谨慎，尽量避免对核心函数或关键语句的替换，以防影响代码的可读性和可维护性。</li><li><strong>现代替代</strong>：在现代C++中，更推荐使用 <code>constexpr</code>、<code>inline functions</code> 或模板等具有类型检查的特性来替代宏替换，以保证代码的健壮性和可维护性。</li></ul><h2 id="预处理指令">预处理指令</h2><h3 id="示例-6">示例</h3><img src="/2025/01/25/C7/image-20241029151846103.png" class="" title="image-20241029151846103"><p>这张PPT介绍了C++中的几种预处理指令（preprocessor directives），包括 <code>#include</code>、<code>#define</code>、<code>#ifdef</code>、<code>#pragma</code> 等。还展示了一些相关的用法和代码示例，展示了这些指令在代码组织、宏定义、条件编译和编译器指示方面的作用。</p><ol><li><strong>#include</strong></li></ol><ul><li><p><strong>功能</strong>：<code>#include</code> 指令用于将其他文件的内容包含到当前文件中。它通常用于引入头文件，使接口定义（如函数和变量声明）在当前文件中可用。</p></li><li><p><strong>作用</strong>：</p><ul><li><strong>Make interface definitions available</strong>：通过包含头文件，可以在当前文件中使用头文件中声明的接口（如函数、变量等）。</li><li><strong>Compose source text</strong>：编译器在预处理阶段<strong>会将包含的文件内容直接插入到 <code>#include</code> 语句所在的位置</strong>。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  <span class="comment">// 包含标准输入输出流库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myheader.h&quot;</span> <span class="comment">// 包含自定义的头文件</span></span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>#define</strong></li></ol><ul><li><p><strong>功能</strong>：<code>#define</code> 指令用于定义宏。这种宏替换机制可以用于定义常量、<strong>简单的代码片段</strong>，甚至可以实现一些复杂的操作，如拼接和字符串化操作。</p></li><li><p><strong>用法</strong>：</p><ul><li><p><strong>Symbolic constants</strong>：可以用 <code>#define</code> 定义符号常量，将数值或字符串赋给一个符号名称，避免在代码中直接使用“魔法数字”，提高可读性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Open subroutines</strong>：可以用 <code>#define</code> 实现简单的代码片段或内联函数，比如通过宏定义一个求平方的操作。宏替换不进行参数类型检查，但可以减少函数调用的开销。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) ((x) * (x))</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Generic subroutines</strong>：宏可以创建通用的子程序，不限定类型。例如，<code>SQUARE(x)</code> 可以用于不同类型的变量（<code>int</code>、<code>double</code>等）。</p></li><li><p><strong>Generic “types”</strong>：通过宏定义，可以使用通用类型名称来代替具体的类型。例如，可以定义一个 <code>#define INTEGER int</code>，使得代码中可以使用 <code>INTEGER</code> 来表示 <code>int</code>。</p></li><li><p><strong>Renaming</strong>：使用宏可以为现有的变量、类型或函数起别名。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIDTH LENGTH</span></span><br></pre></td></tr></table></figure></li><li><p><strong>String concatenation</strong>：在宏中使用 <code>##</code> 可以将两个标识符拼接在一起。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FUNC(x, y) x##y</span></span><br><span class="line"><span class="built_in">FUNC</span>(hello, world);  <span class="comment">// 等价于 helloworld</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Special purpose syntax</strong>：有些宏可以包含特殊用途的语法，比如用于调试信息的打印、日志记录等，这些特定用途的语法可以通过宏进行定义和替换，来控制调试输出或其他辅助功能。</p></li><li><p><strong>General macro processing</strong>：宏定义提供了一个通用的预处理工具，可以在代码编译之前对代码进行文本级的处理，例如字符串拼接、条件编译等。宏处理没有类型检查的限制，灵活但容易产生意外错误。</p></li></ul></li></ul><ol start="3"><li>字符串拼接</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Func(x, y) x##y</span></span><br><span class="line"><span class="built_in">Func</span>(my, _func)();  <span class="comment">// 结果为调用 my_func()</span></span><br></pre></td></tr></table></figure><p><strong>详细解释</strong>：</p><ul><li><code>#define Conn(x, y) x##y</code>：使用 <code>##</code> 操作符连接两个标识符。例如，<code>Conn(my, func)</code> 会生成 <code>myfunc</code>。</li><li><code>#define ToString(x) #x</code>：使用 <code>#</code> 操作符将参数转换为字符串，例如 <code>ToString(123)</code> 会生成字符串 <code>&quot;123&quot;</code>。</li><li><code>#define ToChar(x) #@x</code>：这是一个非标准写法，在标准C++中不存在 <code>#@</code> 这样的操作符。一般的字符串化操作使用 <code>#</code> 就可以。</li></ul><ol start="4"><li><strong>#ifdef</strong></li></ol><ul><li><p><strong>功能</strong>：<code>#ifdef</code> 和 <code>#ifndef</code> 是条件编译指令，用于判断某个宏是否被定义。</p></li><li><p><strong>作用</strong>：</p><ul><li><strong>Version control</strong>：可以根据宏的定义情况控制不同的代码版本。例如，可以为不同的平台或编译器配置不同的代码。</li><li><strong>Commenting out code</strong>：可以通过条件编译“注释”掉一部分代码，而不需要真正移除它。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在这个示例中，如果定义了 <code>DEBUG</code>，那么 <code>LOG(x)</code> 会输出内容；否则，<code>LOG(x)</code> 会被替换为空操作。</p></li></ul><ol start="4"><li><strong>#pragma</strong></li></ol><ul><li><p><strong>功能</strong>：<code>#pragma</code> 是一种提供给编译器的指示，可以控制编译器的特定行为。不同的编译器支持不同的 <code>#pragma</code> 指令。</p></li><li><p><strong>作用</strong>：</p><ul><li><strong>Control of layout</strong>：可以控制内存布局或数据对齐方式。</li><li><strong>Informing the compiler</strong>：可以用来向编译器传达一些信息，比如禁用某些警告或进行优化。</li></ul></li><li><p><strong>示例</strong>：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 1)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once  <span class="comment">// 防止头文件被重复包含</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable: 4996)  <span class="comment">// 禁用特定的编译警告</span></span></span><br></pre></td></tr></table></figure><ol start="5"><li><strong>const, inline, template, namespace</strong></li></ol><p>这些关键字并不是预处理指令，但在PPT中列出，表明它们可以在代码结构设计中与预处理指令相配合使用。</p><ul><li><strong>const</strong>：用于定义常量，替代 <code>#define</code> 定义的常量，更加安全，具有类型检查功能。</li><li><strong>inline</strong>：用于提示编译器将函数内联化，避免函数调用开销。</li><li><strong>template</strong>：用于创建泛型函数或类，以便在不同类型上复用代码。</li><li><strong>namespace</strong>：用于组织代码，避免名字冲突。</li></ul><p>总结</p><ul><li><strong>#include</strong>：用于包含文件，使接口定义可用。</li><li><strong>#define</strong>：定义宏，用于常量、简单代码段、拼接、字符串化等。</li><li><strong>#ifdef</strong>：条件编译，控制代码的编译版本。</li><li><strong>#pragma</strong>：向编译器提供指示，控制特定编译行为。</li></ul><h2 id="宏">宏</h2><h3 id="示例-7">示例</h3><img src="/2025/01/25/C7/image-20241029154328358.png" class="" title="image-20241029154328358"><p>这张PPT展示了C++中的宏定义使用示例。我们看到两个宏 <code>ARRAY_SIZE</code> 和 <code>FOR_EACH</code>，并展示了如何使用宏来遍历数组中的每一个元素。下面是对PPT中每个部分的详细解释。</p><ol><li><strong>宏 <code>ARRAY_SIZE</code></strong></li></ol><ul><li><p><strong>定义</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))</span></span><br></pre></td></tr></table></figure><p>这个宏用于计算数组的元素个数。它通过计算数组的总字节大小 <code>sizeof(arr)</code>，然后除以单个元素的字节大小 <code>sizeof(arr[0])</code> 来得到数组的大小。</p></li><li><p><strong>工作原理</strong>：<br>假设有一个数组 <code>int arr[5];</code>，<code>sizeof(arr)</code> 返回整个数组的字节大小（假设每个 <code>int</code> 为4字节，则 <code>sizeof(arr) = 20</code> 字节），<code>sizeof(arr[0])</code> 返回单个元素的字节大小（4字节）。因此，<code>ARRAY_SIZE(arr)</code> 的结果为 <code>20 / 4 = 5</code>，即数组中元素的个数。</p></li><li><p><strong>注意事项</strong>：</p><ul><li>该宏只能用于“真正的”数组类型，不能用于指针类型。因为 <strong><code>sizeof(arr)</code> 在数组和指针上返回的结果不同</strong>：数组返回整个数组的大小，而指针仅返回指针自身的大小（通常为4或8字节）。</li></ul></li></ul><ol start="2"><li><strong>宏 <code>FOR_EACH</code></strong></li></ol><ul><li><p><strong>定义</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FOR_EACH(arr, fn) do &#123; \</span></span><br><span class="line"><span class="meta">    for (int i = 0; i &lt; ARRAY_SIZE(arr); i++) &#123; \</span></span><br><span class="line"><span class="meta">        (fn)(arr[i]); \</span></span><br><span class="line"><span class="meta">    &#125; \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure><p>这个宏用于遍历数组 <code>arr</code> 中的每一个元素，并对每个元素应用函数 <code>fn</code>。</p></li><li><p><strong>工作原理</strong>：<br><code>FOR_EACH</code> 宏定义了一个 <code>for</code> 循环，从 <code>i = 0</code> 开始遍历数组 <code>arr</code>。每次循环中调用 <code>(fn)(arr[i])</code>，将数组的第 <code>i</code> 个元素作为参数传递给函数 <code>fn</code>。这个宏利用了 <code>ARRAY_SIZE</code> 来获取数组的大小，确保遍历所有元素。</p></li><li><p><strong>多行宏的实现</strong>：<br>宏定义中使用了反斜杠 <code>\</code> 来表示换行符，这样可以将宏定义分布在多行中，增加可读性。</p><ul><li><code>do &#123; ... &#125; while (0)</code>：这是一个<strong>常见的宏模式，用于确保宏语句在用作单独语句块时不会引起语法问题</strong>。这样一来，无论宏在何处使用，都不会影响代码的结构完整性。</li></ul></li><li><p><strong>应用示例</strong>：<br>假设 <code>arr</code> 是一个整数数组，<code>fn</code> 是一个打印函数 <code>print_int</code>，<code>FOR_EACH(arr, print_int);</code> 会遍历数组 <code>arr</code> 的每个元素并打印它们。</p></li></ul><ol start="3"><li><strong>函数 <code>print_int</code></strong></li></ol><ul><li><p><strong>定义</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_int</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个简单的打印函数，用于打印传入的整数 <code>i</code>，并换行。</p></li><li><p><strong>作用</strong>：<br>这个函数作为 <code>FOR_EACH</code> 宏的参数 <code>fn</code>，在遍历数组时对每个元素调用 <code>print_int</code>，从而实现数组中所有元素的打印。</p></li></ul><ol start="4"><li><strong>主函数 <code>main</code></strong></li></ol><ul><li><p><strong>定义</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">FOR_EACH</span>(arr, print_int);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数中定义了一个数组 <code>arr</code>，包含一个整数元素。通过 <code>FOR_EACH(arr, print_int);</code> 宏调用，将 <code>arr</code> 数组的每个元素传入 <code>print_int</code> 函数打印出来。</p></li><li><p><strong>作用</strong>：<br>这个主函数展示了 <code>FOR_EACH</code> 宏的用法。宏 <code>FOR_EACH</code> 遍历数组 <code>arr</code> 的每个元素，并调用 <code>print_int</code> 打印元素的值。</p></li></ul><ol start="5"><li><strong>整体流程总结</strong></li></ol><ul><li><strong>ARRAY_SIZE</strong>：用于计算数组的大小，确保 <code>FOR_EACH</code> 宏能够正确地遍历数组的每一个元素。</li><li><strong>FOR_EACH</strong>：一个用于遍历数组的通用宏，它接受一个数组和一个函数作为参数，并将数组中的每个元素传递给函数。</li><li><strong>print_int</strong>：一个简单的打印函数，用于 <code>FOR_EACH</code> 宏的示例。</li><li><strong>main</strong>：演示了如何使用 <code>FOR_EACH</code> 宏来遍历数组并打印每个元素。</li></ul><h3 id="示例-8">示例</h3><img src="/2025/01/25/C7/image-20241029160651480.png" class="" title="image-20241029160651480"><p>这张PPT主要展示了C/C++中预处理器的条件编译指令和一些预定义的宏。</p><ol><li><strong>预定义宏</strong></li></ol><p>在C/C++中，编译器提供了一些<strong>预定义宏</strong>，用于<strong>获取编译器或当前文件的相关信息</strong>，这些宏在<strong>程序编译时会自动展开</strong>，<strong>不需要显式定义</strong>。这些预定义宏包括：</p><ul><li><strong><code>__FILE__</code></strong>：表示当前文件的名称。</li><li><strong><code>__LINE__</code></strong>：表示当前行号。</li><li><strong><code>__DATE__</code></strong>：表示当前的编译日期。</li><li><strong><code>__TIME__</code></strong>：表示当前的编译时间。</li><li><strong><code>__STDC__</code></strong>：如果编译器遵循ANSI标准C，则定义该宏。一般用于判断代码是否符合标准C。</li><li><strong><code>__COUNTER__</code></strong>：一个递增的整型值，每使用一次这个宏，值都会增加。通常用于生成唯一的标识符。</li><li><strong><code>__INCLUDE_LEVEL__</code></strong>：表示当前文件被嵌套包含的级别。每次 <code>#include</code> 会增加这个值，用于调试文件包含的层次结构。</li></ul><p>这些预定义宏可以帮助开发者在代码中加入调试信息，记录文件、行号、时间等信息，方便定位问题和追踪代码执行。</p><ol start="2"><li><strong>条件编译示例</strong></li></ol><p>上半部分的代码展示了条件编译的用法，通过预处理指令 <code>#ifdef</code>、<code>#ifndef</code>、<code>#if</code>、<code>#elif</code>、<code>#else</code>、<code>#endif</code> 等控制代码的编译流程。这些指令允许开发者根据不同的条件来选择性地编译部分代码，特别适合于多平台、多版本的代码。</p><p><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_PRINTF_VERSION</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> MY_PRINTF_VERSION 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MY_PRINTF_VERSION == 1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printf</span><span class="params">(<span class="type">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实现版本1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> MY_PRINTF_VERSION == 2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">printf</span><span class="params">(<span class="type">char</span>* fmt, <span class="type">char</span>* args, ...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实现版本2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li><p><strong>解释</strong>：</p><ul><li><code>#ifndef MY_PRINTF_VERSION</code>：检查是否未定义宏 <code>MY_PRINTF_VERSION</code>。如果未定义，则定义它并将其值设为 <code>1</code>。</li><li><code>#if MY_PRINTF_VERSION == 1</code>：检查 <code>MY_PRINTF_VERSION</code> 是否等于 <code>1</code>，如果是，则编译第一个 <code>printf</code> 版本。</li><li><code>#elif MY_PRINTF_VERSION == 2</code>：如果 <code>MY_PRINTF_VERSION</code> 等于 <code>2</code>，则编译第二个 <code>printf</code> 版本。</li><li><code>#endif</code>：结束条件编译。</li></ul></li><li><p><strong>用途</strong>：这种条件编译方式允许开发者定义不同版本的 <code>printf</code> 函数，可以根据 <code>MY_PRINTF_VERSION</code> 的值选择不同的实现。这在需要兼容多个版本的函数或特性时非常有用。</p></li></ul><ol start="3"><li><strong>预处理指令</strong></li></ol><ul><li><strong>#ifdef 和 #ifndef</strong>：用于条件编译。<code>#ifdef</code> 检查一个宏是否已定义，<code>#ifndef</code> 则检查宏是否未定义。常用于版本控制和代码屏蔽。</li></ul><ol start="4"><li><strong>IDE</strong></li></ol><ul><li>可以在IDE里用上面这些预定义宏进行详细debug，可以精确到行，时间等</li></ul><h2 id="泛型编程（template）">泛型编程（template）</h2><h3 id="示例-9">示例</h3><img src="/2025/01/25/C7/image-20241029161232170.png" class="" title="image-20241029161232170"><p>这张PPT概述了**泛型编程（Generic Programming）**的核心特点及其应用领域。泛型编程是一种编程范式，强调代码的通用性和复用性，特别在算法和数据结构的设计中得到广泛应用。</p><ol><li><strong>Reusable（可复用）</strong></li></ol><ul><li><p><strong>含义</strong>：泛型编程的一个重要目标是实现代码的复用性。通过定义具有通用性的数据结构和算法，代码可以在不同的场景中重用，而不需要进行修改。</p></li><li><p><strong>示例</strong>：C++中的模板（templates）就是泛型编程的一种实现方式。例如，<code>std::vector</code> 是一个通用的容器类模板，它可以存储任意类型的元素，不需要为每种类型分别定义一个新的容器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; intVec;      <span class="comment">// 存储整数的向量</span></span><br><span class="line">std::vector&lt;<span class="type">double</span>&gt; doubleVec; <span class="comment">// 存储双精度数的向量</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>Type-safe（类型安全）</strong></li></ol><ul><li><strong>含义</strong>：泛型编程还强调类型安全，这意味着编译器可以在编译阶段检查类型是否匹配，从而减少运行时错误。与传统的使用<code>void*</code>的通用指针不同，泛型编程允许在保持类型安全的同时实现代码的通用性。</li><li><strong>示例</strong>：在C++中，通过模板类或模板函数，编译器可以在实例化模板时确保类型的正确性。如果类型不匹配，编译器会报错。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">5</span>);        <span class="comment">// 类型安全，正确</span></span><br><span class="line"><span class="type">double</span> dResult = <span class="built_in">add</span>(<span class="number">2.5</span>, <span class="number">3.5</span>); <span class="comment">// 类型安全，正确</span></span><br><span class="line"><span class="comment">// add(2, 2.5); // 如果不支持类型转换，会导致编译错误</span></span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><strong>Algorithm（算法）</strong></li></ol><ul><li><strong>作用</strong>：泛型编程通常应用于算法设计。通过定义通用的算法模板，可以实现对不同类型的数据进行操作，而不必重写相同逻辑的代码。</li><li><strong>示例</strong>：C++标准库中的算法，如 <code>std::sort</code>、<code>std::find</code> 等都是泛型算法，它们可以作用于任意类型的容器上，不限定数据的具体类型。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); <span class="comment">// 泛型排序算法，可用于任意支持排序的类型</span></span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li><strong>Data Structure（数据结构）</strong></li></ol><ul><li><p><strong>作用</strong>：泛型编程在数据结构设计中也有广泛应用。通过定义泛型的数据结构，可以支持存储不同类型的数据，而不需要为每种类型实现不同的结构。</p></li><li><p><strong>示例</strong>：C++的标准模板库（STL）中的 <code>std::vector</code>、<code>std::list</code>、<code>std::map</code> 等数据结构都是泛型数据结构。它们可以存储任意类型的数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; intVector;    <span class="comment">// 存储整数</span></span><br><span class="line">std::vector&lt;std::string&gt; strVector; <span class="comment">// 存储字符串</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="示例-10">示例</h3><img src="/2025/01/25/C7/image-20241029162149076.png" class="" title="image-20241029162149076"><img src="/2025/01/25/C7/image-20241029162155250.png" class="" title="image-20241029162155250"><img src="/2025/01/25/C7/image-20241029162203563.png" class="" title="image-20241029162203563"><img src="/2025/01/25/C7/image-20241029162231458.png" class="" title="image-20241029162231458"><img src="/2025/01/25/C7/image-20241029162238671.png" class="" title="image-20241029162238671"><img src="/2025/01/25/C7/image-20241029162244301.png" class="" title="image-20241029162244301"><p>好的，我可以直接访问您上传的图片。让我为您详细解释每一张PPT内容。</p><hr><h3 id="第一张PPT">第一张PPT</h3><h4 id="内容：">内容：</h4><p>第一张PPT展示了使用C宏定义和结构体来创建一个通用的栈（Stack）结构，以支持不同的数据类型。具体实现如下：</p><ol><li><p><strong>宏 <code>CREATE_STACK(T)</code></strong>：通过宏定义的方式创建一个特定类型的栈，<code>T</code> 代表数据类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CREATE_STACK(T) \</span></span><br><span class="line"><span class="meta">typedef struct Stack_##T &#123; \</span></span><br><span class="line"><span class="meta">    T* array; \</span></span><br><span class="line"><span class="meta">    int capacity; \</span></span><br><span class="line"><span class="meta">    int top; \</span></span><br><span class="line"><span class="meta">&#125; Stack_##T; \</span></span><br><span class="line"><span class="meta">void Stack_##T##_init(Stack_##T* stack, int capacity) &#123; \</span></span><br><span class="line"><span class="meta">    stack-&gt;array = (T*)malloc(sizeof(T) * capacity); \</span></span><br><span class="line"><span class="meta">    stack-&gt;capacity = capacity; \</span></span><br><span class="line"><span class="meta">    stack-&gt;top = -1; \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta"><span class="comment">//其他函数定义</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用 <code>CREATE_STACK(int)</code> 和 <code>CREATE_STACK(double)</code></strong>：</p><ul><li>通过宏 <code>CREATE_STACK(int)</code> 创建了一个整型栈结构 <code>Stack_int</code>。</li><li>通过宏 <code>CREATE_STACK(double)</code> 创建了一个双精度浮点型栈结构 <code>Stack_double</code>。</li></ul></li></ol><h4 id="总结：">总结：</h4><p>这张PPT展示了如何使用宏定义创建不同类型的栈。尽管灵活，但宏定义的方式可能会降低代码可读性和调试性。</p><hr><h3 id="第二张PPT">第二张PPT</h3><h4 id="内容：-2">内容：</h4><p>第二张PPT是在第一张的基础上，继续使用宏定义方法扩展了栈的功能，包括 <code>push</code>、<code>pop</code> 和 <code>release</code> 等操作。</p><ol><li><p><strong><code>push</code> 函数</strong>：检查栈是否已满，然后插入元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> Stack_##T##_push(Stack_##T* <span class="built_in">stack</span>, T data) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;top + <span class="number">1</span> &gt;= <span class="built_in">stack</span>-&gt;capacity) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is full\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;<span class="built_in">array</span>[++<span class="built_in">stack</span>-&gt;top] = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>pop</code> 函数</strong>：检查栈是否为空，然后移除并返回栈顶元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T Stack_##T##_pop(Stack_##T* <span class="built_in">stack</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;top &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;<span class="built_in">array</span>[<span class="built_in">stack</span>-&gt;top--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="总结：-2">总结：</h4><p>通过这些宏定义的栈操作函数，可以实现栈的入栈、出栈操作，且能适配多种类型。不过仍然存在调试困难的问题。</p><hr><h3 id="第三张PPT">第三张PPT</h3><h4 id="内容：-3">内容：</h4><p>第三张PPT改进了宏定义方式，使代码更具可读性。这里的C++版本不使用宏，而是直接用模板来实现通用栈的功能，具有更高的类型安全性和可读性。</p><ol><li><p><strong>模板定义栈结构</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    T* array;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>模板定义栈的操作函数</strong>：<br>使用 <code>template&lt;typename T&gt;</code> 创建通用函数，包括 <code>_init</code>、<code>_push</code> 和 <code>_pop</code> 等。</p></li></ol><h4 id="总结：-3">总结：</h4><p>相比宏定义，这种模板方式更具灵活性，且类型安全，可以在编译时检查类型是否正确。</p><hr><h3 id="第四张PPT：宏的缺点">第四张PPT：宏的缺点</h3><p>这张PPT列出了使用宏的缺点：</p><ol><li><strong>代码可读性差</strong>：宏代码在展开后不易理解。</li><li><strong>难调试</strong>：宏代码在编译器层面展开，不易定位错误。</li><li><strong>显式类型参数</strong>：需要显式地传入类型。</li><li><strong>手动实例化</strong>：每种类型都要手动实例化栈，缺乏自动泛型功能。</li></ol><p>这正是模板方法更适合C++泛型编程的原因。</p><hr><h3 id="第五张PPT：C-模板实现">第五张PPT：C++模板实现</h3><p>这张PPT展示了如何通过C++模板来实现通用的栈结构，且避免了宏定义的缺点。</p><ol><li><strong>模板实现栈</strong>：使用 <code>template&lt;typename T&gt;</code>，使得栈可以容纳不同类型的数据。</li><li><strong>操作函数</strong>：通过模板函数 <code>_push</code>、<code>_pop</code> 和 <code>_release</code> 实现栈操作。</li></ol><h4 id="总结：-4">总结：</h4><p>使用模板实现通用栈，具有良好的类型安全性和复用性，是一种更优雅的泛型编程方式。</p><hr><h3 id="第六张PPT：概念与约束（C-20）">第六张PPT：概念与约束（C++20）</h3><p>在C++20中，通过 <code>concept</code> 和 <code>requires</code> 语句进一步增强了模板的类型安全性。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> DataAvailable = !std::is_pointer&lt;T&gt;::value;</span><br></pre></td></tr></table></figure><ol><li><strong><code>concept</code> 关键字</strong>：定义了类型约束，确保传入的类型满足特定条件。</li><li><strong><code>requires</code> 约束</strong>：用来限制模板类型，确保在编译时检测类型要求。</li></ol><h4 id="总结：-5">总结：</h4><p>C++20的概念和约束提高了泛型编程的安全性，使得模板更加强大。</p><hr><p>以上是六张PPT的详细解释。每张PPT的内容都通过示例代码和讲解展示了从C宏到C++模板，再到C++20概念的演变。</p>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++高级程序设计笔记（C8）</title>
      <link href="/2025/01/25/C8/"/>
      <url>/2025/01/25/C8/</url>
      
        <content type="html"><![CDATA[<h1>C8</h1><h2 id="template-concept">template &amp; concept</h2><h3 id="示例">示例</h3><img src="/2025/01/25/C8/image-20241118170656491.png" class="" title="image-20241118170656491"><p><strong>Concepts 与约束</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">concept</span> DataAvailable = !std::is_pointer&lt;T&gt;::value;</span><br><span class="line"><span class="keyword">template</span> &lt;DataAvaliable T&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">requires</span> (!std::is_pointer&lt;T&gt;::value)</span><br></pre></td></tr></table></figure><ul><li><strong>Concepts</strong>：用于<strong>约束模板的类型</strong>。<ul><li><code>std::is_pointer&lt;T&gt;::value</code>：检查<code>T</code>是否是指针类型。</li><li><code>concept DataAvailable</code>：定义了一个概念，要求模板参数<code>T</code>必须是指针类型。</li></ul></li><li><strong><code>requires</code>关键字</strong>：对<code>T</code>进行约束，确保<code>T</code>不为指针类型时生效。</li></ul><h2 id="元编程">元编程</h2><h3 id="示例-2">示例</h3><img src="/2025/01/25/C8/image-20241118170807071.png" class="" title="image-20241118170807071"><p><strong>元编程的核心思想</strong></p><p>元编程是利用编译器在<strong>编译期完成一些计算任务</strong>，从而优化运行时性能。在这段代码中，模板被用来计算整数的阶乘（factorial）。</p><p>阶乘公式：<br>$N! = N \times (N-1) \times (N-2) \times … \times 1 $</p><p><strong>1. 使用模板实现阶乘计算</strong></p><p><strong>代码结构</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">factorial</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; value = N * factorial&lt;N - <span class="number">1</span>&gt;::value &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">factorial</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; value = <span class="number">1</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><code>::value</code> 的含义</strong></p><p><code>::value</code> 是访问<strong>结构体或类</strong>中的<strong>静态成员变量</strong>的一种方式。它的作用是获取模板递归计算中定义的值。</p><p><strong>代码中的定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">factorial</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; value = N * factorial&lt;N - <span class="number">1</span>&gt;::value &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong><code>factorial&lt;N&gt;</code></strong>：模板生成的一个结构体实例。</li><li><strong><code>::value</code></strong>：访问这个模板实例中的<code>value</code>，表示当前阶乘的计算结果。</li></ul><p><strong>工作方式</strong></p><p>以<code>factorial&lt;3&gt;::value</code>为例：</p><ol><li><code>factorial&lt;3&gt;</code> 表示模板实例化，展开成以下结构体：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">factorial</span>&lt;<span class="number">3</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; value = <span class="number">3</span> * factorial&lt;<span class="number">2</span>&gt;::value &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>编译器接着实例化 <code>factorial&lt;2&gt;</code>，并递归到 <code>factorial&lt;0&gt;</code>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">factorial&lt;<span class="number">2</span>&gt;::value = <span class="number">2</span> * factorial&lt;<span class="number">1</span>&gt;::value;</span><br><span class="line">factorial&lt;<span class="number">1</span>&gt;::value = <span class="number">1</span> * factorial&lt;<span class="number">0</span>&gt;::value;</span><br><span class="line">factorial&lt;<span class="number">0</span>&gt;::value = <span class="number">1</span>; <span class="comment">// 终止条件</span></span><br></pre></td></tr></table></figure></li><li>最后计算得出：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>l</mi><mo>&lt;</mo><mn>3</mn><mo>&gt;</mo><mo>:</mo><mo>:</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo>=</mo><mn>3</mn><mo>×</mo><mn>2</mn><mo>×</mo><mn>1</mn><mo>=</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">factorial&lt;3&gt;::value = 3 \times 2 \times 1 = 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord mathnormal">ia</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;::</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span></span></span></span></li></ol><p><strong>为什么使用结构体？</strong></p><p>使用结构体是因为：</p><ol><li><strong>模板支持</strong>：C++中<strong>模板通常结合类或结构体</strong>使用，可以通过递归模板实现复杂的编译期逻辑。</li><li><strong>静态成员变量</strong>：结构体可以包含静态成员变量，例如<code>value</code>，用于保存计算结果。</li></ol><p><strong>特定于结构体的优势</strong></p><ul><li><strong>实例化时的独立性</strong>：每个模板实例<code>factorial&lt;N&gt;</code>都有自己的<code>value</code>，编译器会分别生成代码，无需共享数据。</li><li><strong>清晰的语法</strong>：模板递归和特化非常适合通过结构体来表达。</li></ul><p><strong>为什么使用 <code>enum</code>？可以用其他方式替代吗？</strong></p><p><strong>为什么用 <code>enum</code></strong></p><p><code>enum</code> 是 C++98 和 C++03 中实现<strong>编译期常量</strong>的一种方式，<code>value</code> 的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; value = ... &#125;;</span><br></pre></td></tr></table></figure><ul><li><p><strong>优点</strong>：</p><ul><li><strong>枚举中的值在编译期直接计算并存储</strong>，不需要运行时的内存分配。</li><li>编译器直接内联这些值，生成高效的代码。</li></ul></li><li><p><strong>历史原因</strong>：</p><ul><li>在 C++11 之前，没有<code>constexpr</code>关键字，<code>enum</code> 是实现<strong>编译期常量</strong>的主要方法。</li></ul></li></ul><p><strong>核心机制</strong></p><ol><li><p><strong>递归模板</strong>：</p><ul><li>模板<code>factorial</code>定义了一个整数<code>value</code>，通过递归调用<code>factorial&lt;N-1&gt;</code>计算<code>N</code>的阶乘。</li><li>每个模板实例都会生成一个<code>factorial&lt;N&gt;</code>类型，其中包含<code>value</code>的编译期常量。</li></ul></li><li><p><strong>模板特化</strong>：</p><ul><li>当<code>N=0</code>时，模板通过特化处理：<code>factorial&lt;0&gt;</code>直接返回<code>value=1</code>，结束递归。</li></ul></li></ol><p><strong>代码运行方式</strong></p><p>编译器在<strong>编译期</strong>展开递归计算：</p><ul><li><p>对于<code>factorial&lt;5&gt;::value</code>：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo stretchy="false">!</mo><mo>=</mo><mn>5</mn><mo>×</mo><mi>f</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>l</mi><mo>&lt;</mo><mn>4</mn><mo>&gt;</mo><mo>:</mo><mo>:</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">5! = 5 \times factorial&lt;4&gt;::value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">5</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord mathnormal">ia</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;::</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>l</mi><mo>&lt;</mo><mn>4</mn><mo>&gt;</mo><mo>:</mo><mo>:</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo>=</mo><mn>4</mn><mo>×</mo><mi>f</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>l</mi><mo>&lt;</mo><mn>3</mn><mo>&gt;</mo><mo>:</mo><mo>:</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">factorial&lt;4&gt;::value = 4 \times factorial&lt;3&gt;::value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord mathnormal">ia</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;::</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord mathnormal">ia</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;::</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span></li></ul></li><li><p>最终展开到<code>factorial&lt;0&gt;::value = 1</code>，完成计算。</p></li></ul><p><strong>使用示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; factorial&lt;<span class="number">5</span>&gt;::value; <span class="comment">// 输出 120</span></span><br></pre></td></tr></table></figure><p><strong>2. C++11 后的改进</strong></p><p><strong>新特性：<code>constexpr</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">factorial1</span> &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">int</span> value = N * factorial1&lt;N - <span class="number">1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">factorial1</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>改进的原因</strong></p><ol><li><p><strong>枚举类型的局限</strong>：</p><ul><li>在 C++11 之前，常量只能通过<code>enum</code>实现，但<code>enum</code>语法过时，且功能有限。</li><li>无法对复杂类型或浮点数进行类似处理。</li></ul></li><li><p><strong><code>constexpr</code> 的优势</strong>：</p><ul><li><code>constexpr</code>是 C++11 引入的新特性，用于<strong>声明编译期常量</strong>，语法更简洁。</li><li>支持更复杂的表达式和类型推导。</li></ul></li></ol><p><strong>工作原理</strong></p><ul><li>编译器在编译期计算<code>value</code>，并保证它是一个常量。</li><li><code>constexpr</code>比<code>enum</code>更通用，能扩展到浮点数、指针等类型。</li></ul><p><strong>使用示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; factorial1&lt;<span class="number">5</span>&gt;::value; <span class="comment">// 输出 120</span></span><br></pre></td></tr></table></figure><p><strong>3. 两种方法的比较</strong></p><table><thead><tr><th>特性</th><th>使用<code>enum</code>的实现</th><th>使用<code>constexpr</code>的实现</th></tr></thead><tbody><tr><td><strong>语法</strong></td><td>需要<code>enum</code>关键字，显得冗余</td><td>直接声明<code>constexpr static int</code>更清晰</td></tr><tr><td><strong>可读性</strong></td><td>略显复杂</td><td>更加直观，现代化</td></tr><tr><td><strong>类型支持</strong></td><td>只能处理整数</td><td>支持更多类型，例如浮点数、指针等</td></tr><tr><td><strong>扩展性</strong></td><td>扩展能力有限</td><td>支持任意复杂编译期计算</td></tr></tbody></table><p><strong>4. 编译期 vs 运行期</strong></p><p><strong>元编程的优势</strong></p><ol><li><p><strong>编译期计算</strong>：<br>所有计算在编译期完成，生成优化后的代码，运行时无需重复计算。</p></li><li><p><strong>性能提升</strong>：<br>避免运行时开销，适合对性能敏感的场景。</p></li></ol><p><strong>运行时计算的缺点</strong></p><p>如果阶乘是运行时计算：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial_runtime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &lt;= <span class="number">1</span>) ? <span class="number">1</span> : n * <span class="built_in">factorial_runtime</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>递归函数在<strong>运行时调用，消耗栈空间</strong>。</li><li>会引入<strong>函数调用开销</strong>。</li></ul><p>相比之下，<strong>元编程直接将结果嵌入到最终的可执行文件中</strong>。</p><h2 id="constexpr">constexpr</h2><h3 id="示例-3">示例</h3><img src="/2025/01/25/C8/image-20241118171755507.png" class="" title="image-20241118171755507"><p>这张PPT展示了 <strong>C++11 的 <code>constexpr</code></strong> 的用法，通过计算阶乘 (<code>factorial</code>) 和时间处理，进一步探索编译期与运行期计算的区别。下面我将逐步解析每一部分代码和概念，帮助你理解 <code>constexpr</code> 的作用及其优势。</p><p><strong>1. <code>constexpr</code> 的定义</strong></p><p><strong>函数定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> <span class="title">factorial</span><span class="params">(std::<span class="type">size_t</span> N)</span> </span>&#123;</span><br><span class="line">    std::<span class="type">size_t</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        result *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>核心知识点</strong></p><ol><li><p><strong><code>constexpr</code> 的作用</strong>：</p><ul><li>表示该函数的<strong>返回值可以在编译期计算</strong>（如果所有输入参数是常量）。</li><li>函数的逻辑必须满足编译期执行的要求，例如没有动态内存分配、I/O操作等。</li></ul></li><li><p><strong>局限性</strong>：</p><ul><li><code>constexpr</code>函数在编译期执行时的逻辑必须是确定性的（即所有分支和循环都可以确定地被执行或退出）。</li><li>在运行时，<code>constexpr</code>函数也可以像普通函数一样被调用。</li></ul></li><li><p><strong>优点</strong>：</p><ul><li><strong>性能提升</strong>：编译器可以在编译期直接完成复杂的计算，避免运行时的开销。</li><li><strong>安全性</strong>：通过编译期检查逻辑，确保计算过程的正确性。</li></ul></li></ol><p><strong>2. 示例代码解读</strong></p><p><strong>编译期计算</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> a = <span class="built_in">factorial</span>(<span class="number">5</span>); <span class="comment">// compile-time</span></span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><ul><li><p><strong>作用</strong>：</p><ul><li>编译器在编译期直接展开<code>factorial(5)</code>的计算，结果为 <code>5! = 120</code>。</li><li><code>a</code> 是一个编译期常量，存储在程序的只读内存区。</li></ul></li><li><p><strong>编译器如何展开</strong>：</p><ul><li>循环 <code>for (i = 1; i &lt;= 5; ++i)</code> 被编译器静态展开为：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi><mi>u</mi><mi>l</mi><mi>t</mi><mo>=</mo><mn>1</mn><mo>×</mo><mn>2</mn><mo>×</mo><mn>3</mn><mo>×</mo><mn>4</mn><mo>×</mo><mn>5</mn><mo>=</mo><mn>120</mn></mrow><annotation encoding="application/x-tex">result = 1 \times 2 \times 3 \times 4 \times 5 = 120</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">res</span><span class="mord mathnormal">u</span><span class="mord mathnormal">lt</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">120</span></span></span></span></li></ul></li></ul><p><strong>运行期计算</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="type">size_t</span>&amp; n = *<span class="keyword">new</span> std::<span class="built_in">size_t</span>(<span class="number">5</span>); <span class="comment">// 动态分配的运行期变量</span></span><br><span class="line"><span class="keyword">auto</span> b = <span class="built_in">factorial</span>(n);                <span class="comment">// run-time</span></span><br><span class="line">std::cout &lt;&lt; b &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><ul><li><p><strong>区别</strong>：</p><ul><li><code>n</code> 是运行时通过动态分配 (<code>new</code>) 创建的变量，值为 <code>5</code>。</li><li><code>factorial(n)</code> 在运行时执行，而不是编译期计算。</li></ul></li><li><p><strong>为什么是运行时？</strong></p><ul><li><strong><code>n</code> 是在运行时创建的变量</strong>，编译器在编译时无法得知它的值。</li><li>因此，<code>factorial</code> 函数需要在运行时执行循环逻辑来计算结果。</li></ul></li><li><p><strong>性能影响</strong>：</p><ul><li>运行时计算增加了函数调用和循环的开销，效率不如编译期计算。</li></ul></li></ul><p><strong>3. 编译期 vs 运行期：<code>constexpr</code> 的优劣势</strong></p><p><strong>编译期（<code>constexpr</code>）计算的特点</strong></p><ol><li><p><strong>性能</strong>：</p><ul><li>编译期完成所有计算，运行时只需直接使用结果。</li><li>避免了函数调用和循环的开销。</li></ul></li><li><p><strong>限制</strong>：</p><ul><li><strong>输入值必须是编译期常量</strong>。</li><li>不支持动态内存分配、异常处理或其他运行期特性。</li></ul></li></ol><p><strong>运行期计算的特点</strong></p><ol><li><p><strong>灵活性</strong>：</p><ul><li>支持动态输入，可以处理在运行时确定的变量。</li></ul></li><li><p><strong>性能</strong>：</p><ul><li>存在函数调用和循环的开销。</li><li>不如编译期计算高效。</li></ul></li></ol><p><strong>4. 示例代码总结</strong></p><table><thead><tr><th>用法</th><th>编译期计算</th><th>运行期计算</th></tr></thead><tbody><tr><td><strong>代码</strong></td><td><code>constexpr auto a = factorial(5);</code></td><td><code>auto b = factorial(n);</code></td></tr><tr><td><strong>输入</strong></td><td>编译期常量</td><td>运行时变量</td></tr><tr><td><strong>执行时机</strong></td><td>编译期</td><td>运行期</td></tr><tr><td><strong>性能</strong></td><td>高效，无运行时开销</td><td>有函数调用和循环开销</td></tr><tr><td><strong>限制</strong></td><td>输入需为编译期常量</td><td>不受限制</td></tr></tbody></table><h2 id="面向对象">面向对象</h2><h3 id="示例-4">示例</h3><img src="/2025/01/25/C8/image-20241121091810305.png" class="" title="image-20241121091810305"><p><strong>1. 核心概念</strong></p><p>这是一个基于 <strong>模板（template）</strong> 的通用栈实现，支持任意数据类型（如 <code>int</code> 和 <code>double</code>）。使用面向对象的思想，所有栈操作（初始化、入栈、出栈、释放内存）都被封装在 <code>Stack</code> 结构体的成员函数中。</p><p><strong>2. 代码结构</strong></p><p><strong>模板结构体定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    T* array;       <span class="comment">// 动态分配的数组，用于存储栈元素</span></span><br><span class="line">    <span class="type">int</span> capacity;   <span class="comment">// 栈的最大容量</span></span><br><span class="line">    <span class="type">int</span> top;        <span class="comment">// 栈顶元素的索引</span></span><br></pre></td></tr></table></figure><h3 id="concept">concept</h3><h4 id="示例-5">示例</h4><img src="/2025/01/25/C8/image-20241121093826803.png" class="" title="image-20241121093826803"><p><strong>1.4 友元函数：输出运算符重载</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; o, Stack&lt;T&gt;&amp; s) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = s.top; i &gt;= <span class="number">0</span>; i--) &#123;   <span class="comment">// 从栈顶到栈底遍历元素</span></span><br><span class="line">        o &lt;&lt; s.array[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    o &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> o;                            <span class="comment">// 返回输出流对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><ul><li><strong>友元函数</strong>：<ul><li>声明为 <code>friend</code> 的函数<strong>可以访问类的私有成员</strong>。</li><li>此处允许 <code>operator&lt;&lt;</code> 访问 <code>array</code> 和 <code>top</code>。</li></ul></li><li><strong>功能</strong>：<ul><li>按照从栈顶到栈底的顺序打印栈中的元素。</li></ul></li><li><strong>返回值</strong>：<ul><li>返回输出流对象 <code>o</code>，支持链式调用（如 <code>cout &lt;&lt; stack1 &lt;&lt; stack2</code>）。</li></ul></li></ul><hr><p><strong>2. Concepts（C++20 新特性）</strong></p><p><strong>2.1 定义概念</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Integral = is_integral&lt;T&gt;::value;</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><ul><li><strong>概念（Concept）</strong>：限制模板参数的类型。</li><li><strong><code>is_integral</code></strong>：<ul><li>C++标准库的类型萃取工具，判断模板参数 <code>T</code> 是否为整型（如 <code>int</code>、<code>long</code> 等）。</li></ul></li><li><strong>作用</strong>：<ul><li>定义了 <code>Integral</code> 概念，用于限制模板类型必须是整型。</li></ul></li></ul><p><strong>2.2 使用概念</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;Integral T&gt;</span><br></pre></td></tr></table></figure><p><strong>功能</strong></p><ul><li>将模板类型 <code>T</code> 限制为满足 <code>Integral</code> 概念的类型，即 <code>T</code> 必须是整型。</li><li>如果用户尝试使用不满足 <code>Integral</code> 的类型（如浮点型），编译器会报错。</li></ul><h3 id="函数指针构造栈">函数指针构造栈</h3><h4 id="示例-6">示例</h4><img src="/2025/01/25/C8/image-20241121094354554.png" class="" title="image-20241121094354554"><p><strong>1. 核心概念</strong></p><p>这段代码实现了一个通用的栈，支持<strong>任意数据类型</strong>。主要通过以下几种方式实现：</p><ul><li><strong><code>void*</code> 指针</strong>：实现泛型数据的存储。</li><li><strong>函数指针</strong>：灵活设置栈的显示功能（<code>showFun</code>）。</li><li><strong>动态内存管理</strong>：利用 <code>malloc</code> 和 <code>realloc</code> 管理栈的存储空间。</li></ul><p><strong>2. 数据结构定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>* elems;          <span class="comment">// 栈中元素的存储空间（指向动态分配的内存）</span></span><br><span class="line">    <span class="type">int</span> elemSize;         <span class="comment">// 每个元素的大小（以字节为单位）</span></span><br><span class="line">    <span class="type">int</span> logicalLen;       <span class="comment">// 栈中实际存储的元素个数</span></span><br><span class="line">    <span class="type">int</span> allocLen;         <span class="comment">// 栈的分配容量（元素个数）</span></span><br><span class="line">    <span class="type">void</span> (*showFun)(<span class="type">void</span>*); <span class="comment">// 函数指针，用于打印元素</span></span><br><span class="line">&#125; Stack;</span><br></pre></td></tr></table></figure><p><strong>字段解析</strong></p><ol><li><p><strong><code>void* elems</code></strong>：</p><ul><li>指向动态分配的内存，用于存储栈中的元素。</li><li>泛型实现的关键，允许栈存储任意类型的元素。</li></ul></li><li><p><strong><code>int elemSize</code></strong>：</p><ul><li>每个元素的字节大小，例如 <code>int</code> 是 4 字节，<code>double</code> 是 8 字节。</li></ul></li><li><p><strong><code>int logicalLen</code></strong>：</p><ul><li>栈中当前存储的元素个数。</li></ul></li><li><p><strong><code>int allocLen</code></strong>：</p><ul><li>栈的分配容量（以元素为单位）。当栈满时，会动态扩展容量。</li></ul></li><li><p><strong><code>void (*showFun)(void*)</code></strong>：</p><ul><li>函数指针，用于打印栈中元素。允许用户自定义显示方式。</li></ul></li></ol><p><strong>3. 核心函数实现</strong></p><p><strong>3.1 栈的初始化</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StackNew</span><span class="params">(Stack* s)</span> &#123;</span><br><span class="line">    s-&gt;logicalLen = <span class="number">0</span>;                      <span class="comment">// 初始化元素个数为 0</span></span><br><span class="line">    s-&gt;allocLen = <span class="number">4</span>;                        <span class="comment">// 初始化栈容量为 4</span></span><br><span class="line">    s-&gt;elems = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配内存</span></span><br><span class="line">    assert(s-&gt;elems != <span class="literal">NULL</span>);               <span class="comment">// 确保分配成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>功能</strong></p><ul><li>初始化栈的基本字段。</li><li>使用 <code>malloc</code> 分配初始的存储空间，初始容量为 4 个元素。</li></ul><p><strong>注意</strong></p><ul><li><strong>动态分配内存</strong>：需要保证后续释放内存，避免内存泄漏。</li><li><strong>断言检查</strong>：使用 <code>assert</code> 确保分配内存成功。</li></ul><p><strong>3.2 栈的销毁</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StackDispose</span><span class="params">(Stack* s)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(s-&gt;elems);                        <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    s-&gt;logicalLen = <span class="number">0</span>;                     <span class="comment">// 重置栈的实际元素个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>功能</strong></p><ul><li>释放栈的动态内存，清理栈中的元素。</li><li>将 <code>logicalLen</code> 重置为 0，表示栈为空。</li></ul><p><strong>3.3 入栈操作</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StackPush</span><span class="params">(Stack* s, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;logicalLen == s-&gt;allocLen) &#123;    <span class="comment">// 栈满时扩容</span></span><br><span class="line">        s-&gt;allocLen *= <span class="number">2</span>;                  <span class="comment">// 容量翻倍</span></span><br><span class="line">        s-&gt;elems = (<span class="type">int</span>*)<span class="built_in">realloc</span>(s-&gt;elems, s-&gt;allocLen * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        assert(s-&gt;elems != <span class="literal">NULL</span>);          <span class="comment">// 确保重新分配成功</span></span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;elems[s-&gt;logicalLen] = value;       <span class="comment">// 将元素存储在栈顶</span></span><br><span class="line">    s-&gt;logicalLen++;                       <span class="comment">// 更新栈的实际元素个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>功能</strong></p><ul><li>检查栈是否已满：<ul><li>如果已满，使用 <code>realloc</code> 动态扩容。</li><li>容量翻倍（<code>allocLen *= 2</code>）。</li></ul></li><li>将新元素存储在栈顶位置（<code>logicalLen</code>）。</li><li>更新 <code>logicalLen</code>。</li></ul><p><strong>3.4 出栈操作</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">StackPop</span><span class="params">(Stack* s)</span> &#123;</span><br><span class="line">    assert(s-&gt;logicalLen &gt; <span class="number">0</span>);             <span class="comment">// 确保栈非空</span></span><br><span class="line">    s-&gt;logicalLen--;                       <span class="comment">// 更新栈的实际元素个数</span></span><br><span class="line">    <span class="keyword">return</span> s-&gt;elems[s-&gt;logicalLen];        <span class="comment">// 返回栈顶元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>功能</strong></p><ul><li>检查栈是否为空：<ul><li>如果为空，<code>assert</code> 会报错，程序终止。</li></ul></li><li>返回当前栈顶元素，并更新栈的实际元素个数（<code>logicalLen</code>）。</li></ul><p><strong>3.5 栈的打印</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StackPrint</span><span class="params">(Stack* s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;logicalLen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Empty\n&quot;</span>);                 <span class="comment">// 如果栈为空，打印 &quot;Empty&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s-&gt;logicalLen; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%p : %d\n&quot;</span>, &amp;(s-&gt;elems[i]), s-&gt;elems[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>功能</strong></p><ul><li>遍历栈中所有元素，并打印每个元素的地址和值。</li></ul><p><strong>注意</strong></p><ul><li>使用 <code>%p</code> 打印指针地址，<code>%d</code> 打印整数值。</li></ul><p><strong>4. 使用自定义函数指针</strong></p><p><strong><code>showFun</code> 的作用</strong></p><p>函数指针 <code>showFun</code> 为栈提供了灵活的打印功能：</p><ul><li>不同类型的栈可以定义不同的打印方式。</li><li>通过传入自定义函数，栈可以适配任意类型的元素。</li></ul><p><strong>5. 主函数中的示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printInt</span><span class="params">(<span class="type">void</span>* elem)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(<span class="type">int</span>*)elem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Stack s;</span><br><span class="line">    StackNew(&amp;s);               <span class="comment">// 初始化栈</span></span><br><span class="line">    s.showFun = printInt;       <span class="comment">// 设置自定义打印函数</span></span><br><span class="line"></span><br><span class="line">    StackPush(&amp;s, <span class="number">10</span>);          <span class="comment">// 入栈</span></span><br><span class="line">    StackPush(&amp;s, <span class="number">20</span>);</span><br><span class="line">    StackPush(&amp;s, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    s.showFun(&amp;s.elems[<span class="number">0</span>]);     <span class="comment">// 使用自定义打印函数打印栈顶元素</span></span><br><span class="line"></span><br><span class="line">    StackPop(&amp;s);               <span class="comment">// 出栈</span></span><br><span class="line">    StackDispose(&amp;s);           <span class="comment">// 销毁栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例-7">示例</h4><img src="/2025/01/25/C8/image-20241121102436530.png" class="" title="image-20241121102436530"><p><strong>1. 栈的实现细节</strong></p><p><strong>1.1 出栈操作：<code>StackPop</code></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StackPop</span><span class="params">(Stack* s, <span class="type">void</span>* elemAddr)</span> &#123;</span><br><span class="line">    assert(s-&gt;logicalLen &gt; <span class="number">0</span>);  <span class="comment">// 检查栈是否为空</span></span><br><span class="line">    s-&gt;logicalLen--;            <span class="comment">// 减少实际长度</span></span><br><span class="line">    <span class="type">void</span>* source = (<span class="type">char</span>*)s-&gt;elems + s-&gt;logicalLen * s-&gt;elemSize; </span><br><span class="line">    <span class="built_in">memcpy</span>(elemAddr, source, s-&gt;elemSize);  <span class="comment">// 将栈顶元素拷贝到 elemAddr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>功能</strong></p><ul><li>检查栈是否为空（<code>logicalLen &gt; 0</code>）。</li><li>通过指针偏移计算栈顶元素的地址。</li><li>使用 <code>memcpy</code> 将栈顶元素拷贝到 <code>elemAddr</code>（出栈时返回元素的值）。</li></ul><p><strong>1.2 打印栈内容：<code>StackPrint</code></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StackPrint</span><span class="params">(Stack* s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;logicalLen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; Empty \n&quot;</span>);  <span class="comment">// 如果栈为空，打印提示</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s-&gt;logicalLen; i++) &#123;</span><br><span class="line">        s-&gt;showFun((<span class="type">char</span>*)s-&gt;elems + i * s-&gt;elemSize);  <span class="comment">// 调用自定义打印函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点</strong></p><ol><li><p><strong>指针偏移</strong>：</p><ul><li>每个元素的地址为：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>address</mtext><mo>=</mo><mtext>s-&gt;elems</mtext><mo>+</mo><mi>i</mi><mo>×</mo><mtext>s-&gt;elemSize</mtext></mrow><annotation encoding="application/x-tex">\text{address} = \text{s-&gt;elems} + i \times \text{s-&gt;elemSize}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord">address</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord text"><span class="mord">s-&gt;elems</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord text"><span class="mord">s-&gt;elemSize</span></span></span></span></span></li></ul></li><li><p><strong>函数指针 <code>showFun</code></strong>：</p><ul><li>用户可以为栈绑定自定义的打印函数（见后文的 <code>StackCharPrint</code> 和 <code>StackIntPrint</code>）。</li></ul></li></ol><p><strong>1.3 整数栈的打印函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StackIntPrint</span><span class="params">(<span class="type">void</span>* p)</span> &#123;</span><br><span class="line">    <span class="type">int</span>* i_p = (<span class="type">int</span>*)p;  <span class="comment">// 将泛型指针转换为 int 类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p : %d\n&quot;</span>, i_p, *i_p);  <span class="comment">// 打印地址和值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>功能</strong></p><ul><li>打印整型栈的每个元素，包括元素的地址和值。</li></ul><hr><h3 id="1-4-字符串栈的打印函数"><strong>1.4 字符串栈的打印函数</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StackCharPrint</span><span class="params">(<span class="type">void</span>* p)</span> &#123;</span><br><span class="line">    <span class="type">char</span>** s_p = (<span class="type">char</span>**)p;  <span class="comment">// 将泛型指针转换为 char* 类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p : %s\n&quot;</span>, s_p, *s_p);  <span class="comment">// 打印地址和值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="功能"><strong>功能</strong></h4><ul><li>打印字符串栈的每个元素，包括元素的地址和字符串值。</li><li>注意，字符串本身是 <code>char*</code> 类型，栈中存储的是指向字符串的指针。</li></ul><hr><h3 id="1-5-主函数"><strong>1.5 主函数</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i[<span class="number">6</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">Stack iStack;</span><br><span class="line">StackNew(&amp;iStack, <span class="keyword">sizeof</span>(<span class="type">int</span>), StackIntPrint);  <span class="comment">// 创建整数栈</span></span><br><span class="line">StackPush(&amp;iStack, &amp;i[<span class="number">0</span>]);                     <span class="comment">// 压入整数</span></span><br><span class="line">...</span><br><span class="line">StackPrint(&amp;iStack);                           <span class="comment">// 打印栈内容</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">StackPop(&amp;iStack, &amp;x);                         <span class="comment">// 弹出整数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Pop element: %d\n&quot;</span>, x);                <span class="comment">// 打印弹出的整数</span></span><br><span class="line">StackDispose(&amp;iStack);                         <span class="comment">// 销毁栈</span></span><br></pre></td></tr></table></figure><h4 id="功能-2"><strong>功能</strong></h4><ul><li>创建一个整型栈 <code>iStack</code>，初始化时绑定打印函数 <code>StackIntPrint</code>。</li><li>调用 <code>StackPush</code> 和 <code>StackPop</code> 操作栈，并在需要时打印栈的内容。</li><li>使用 <code>StackDispose</code> 销毁栈，释放动态内存。</li></ul><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* s[] = &#123;<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;dd&quot;</span>, <span class="string">&quot;ee&quot;</span>, <span class="string">&quot;fffff&quot;</span>&#125;;</span><br><span class="line">Stack sStack;</span><br><span class="line">StackNew(&amp;sStack, <span class="keyword">sizeof</span>(<span class="type">char</span>*), StackCharPrint);  <span class="comment">// 创建字符串栈</span></span><br><span class="line">StackPush(&amp;sStack, &amp;s[<span class="number">0</span>]);                        <span class="comment">// 压入字符串</span></span><br><span class="line">...</span><br><span class="line">StackPrint(&amp;sStack);                              <span class="comment">// 打印栈内容</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* tmp;</span><br><span class="line">StackPop(&amp;sStack, &amp;tmp);                          <span class="comment">// 弹出字符串</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Pop element: %s\n&quot;</span>, tmp);                 <span class="comment">// 打印弹出的字符串</span></span><br><span class="line">StackDispose(&amp;sStack);                            <span class="comment">// 销毁栈</span></span><br></pre></td></tr></table></figure><h4 id="功能-3"><strong>功能</strong></h4><ul><li>创建一个字符串栈 <code>sStack</code>，初始化时绑定打印函数 <code>StackCharPrint</code>。</li><li>调用 <code>StackPush</code> 和 <code>StackPop</code> 操作栈，并在需要时打印栈的内容。</li><li>使用 <code>StackDispose</code> 销毁栈，释放动态内存。</li></ul><hr><h2 id="2-核心特性"><strong>2. 核心特性</strong></h2><h3 id="2-1-泛型支持"><strong>2.1 泛型支持</strong></h3><ul><li>通过 <code>void*</code> 和 <code>elemSize</code>，实现对任意数据类型的支持。</li><li>用户在使用时只需提供每个元素的大小（<code>sizeof(type)</code>）。</li></ul><h3 id="2-2-动态扩容"><strong>2.2 动态扩容</strong></h3><ul><li>使用 <code>realloc</code> 自动扩展栈的容量：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s-&gt;logicalLen == s-&gt;allocLen) &#123;</span><br><span class="line">    s-&gt;allocLen *= <span class="number">2</span>;  <span class="comment">// 容量翻倍</span></span><br><span class="line">    s-&gt;elems = <span class="built_in">realloc</span>(s-&gt;elems, s-&gt;allocLen * s-&gt;elemSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-函数指针"><strong>2.3 函数指针</strong></h3><ul><li>允许用户为栈绑定自定义的打印函数：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StackNew(&amp;<span class="built_in">stack</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>), StackIntPrint);  <span class="comment">// 整数打印</span></span><br><span class="line">StackNew(&amp;<span class="built_in">stack</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>*), StackCharPrint);  <span class="comment">// 字符串打印</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="3-总结"><strong>3. 总结</strong></h2><h3 id="优点"><strong>优点</strong></h3><ol><li><p><strong>泛型灵活性</strong>：</p><ul><li>通过 <code>void*</code> 和 <code>elemSize</code>，支持任意类型的数据。</li><li>函数指针进一步增强了灵活性，允许用户自定义打印方式。</li></ul></li><li><p><strong>动态扩容</strong>：</p><ul><li>使用 <code>realloc</code> 实现动态扩容，无需提前固定栈的大小。</li></ul></li><li><p><strong>模块化设计</strong>：</p><ul><li>所有功能（初始化、销毁、入栈、出栈、打印）封装为独立函数，易于复用。</li></ul></li></ol><hr><h3 id="不足"><strong>不足</strong></h3><ol><li><p><strong>类型安全性不足</strong>：</p><ul><li><code>void*</code> 不提供类型检查，容易出现指针转换错误。</li></ul></li><li><p><strong>手动内存管理</strong>：</p><ul><li>需要显式调用 <code>StackDispose</code> 销毁栈，容易引发内存泄漏。</li></ul></li><li><p><strong>复杂性较高</strong>：</p><ul><li>比起 C++ 标准容器（如 <code>std::vector</code>），代码复杂且容易出错。</li></ul></li></ol><hr><h3 id="改进建议"><strong>改进建议</strong></h3><ul><li>使用现代 C++ 特性（如模板和智能指针）简化代码：<ul><li>使用模板取代 <code>void*</code>，保证类型安全。</li><li>使用 <code>std::unique_ptr</code> 或 <code>std::vector</code> 代替手动内存管理。</li></ul></li></ul><hr><p>如果对代码中的某些细节还有疑问，或者想进一步优化这段代码，欢迎随时提问！</p>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++高级程序设计笔记（C5）</title>
      <link href="/2025/01/25/C5/"/>
      <url>/2025/01/25/C5/</url>
      
        <content type="html"><![CDATA[<h1>C5</h1><p>指针的两个重点：</p><p>Memory Leak</p><p>Idle pointer</p><ul><li>详见dynamic variables</li></ul><h2 id="Pointer-and-Array">Pointer and Array</h2><h3 id="案例">案例</h3><img src="/2025/01/25/C5/image-20241012161459857.png" class="" title="image-20241012161459857"><p><strong>关于指针递增与数组名的不可变性</strong></p><ul><li><strong>指针可以递增</strong>：<code>p++</code> 使指针 <code>p</code> 指向下一个元素。</li><li><strong>数组名不能递增</strong>：数组名 <code>a</code> 是常量，不能执行 <code>a++</code> 这样的操作。这就是 PPT 中 <code>// *(a++) = 0;</code> 被标注为非法的原因。</li></ul><p><strong>指针常量：</strong></p><p>右上角的红色标注 <strong><code>int* const</code></strong> 表示的是一个 <strong>指针常量</strong>（<code>const pointer</code>）</p><p><code>int* const</code> 的含义</p><ul><li><strong><code>int*</code></strong>：这是一个指向 <code>int</code> 类型数据的指针。</li><li><strong><code>const</code> 修饰指针本身</strong>：当 <code>const</code> 放在指针声明的尾部（即 <code>int* const</code>），表示<strong>指针本身不可改变</strong>，即指针一旦指向某个地址，就不能再指向其他地址。</li></ul><p>完整解释：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">12</span>];         <span class="comment">// 创建一个大小为12的数组</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p = a;  <span class="comment">// 指针p是常量，必须初始化，且不可修改</span></span><br><span class="line"></span><br><span class="line">*p = <span class="number">10</span>;           <span class="comment">// 合法，修改p指向的内容</span></span><br><span class="line"><span class="comment">// p = &amp;a[1];      // 非法，不能修改p的指向</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>p</code> 是一个 <strong>指向 <code>int</code> 类型数据的常量指针</strong>。虽然我们可以通过 <code>p</code> 修改它指向的地址中的数据（例如 <code>*p = 10;</code>），但是<strong>不能修改 <code>p</code> 本身的指向</strong>（即不能让它指向别的地址）。</p><p><strong>指针常量与常量指针的区别</strong></p><ol><li><strong><code>int* const p</code></strong>：<ul><li>指针是常量（<code>p</code> 不可改变）。</li><li>但是指向的对象（即 <code>*p</code>）可以被修改。</li></ul></li><li><strong><code>const int* p</code> 或 <code>int const* p</code></strong>：<ul><li>指向的对象是常量（<code>*p</code> 不可改变）。</li><li>但是指针本身可以改变（<code>p</code> 可以指向其他地址）。</li></ul></li><li><strong><code>const int* const p</code></strong>：<ul><li><strong>指针和指向的对象都是常量</strong>：既不能改变 <code>p</code> 的指向，也不能修改 <code>*p</code> 的值。</li></ul></li></ol><h2 id="Multi-Dimension-Array">Multi-Dimension Array</h2><h3 id="案例-2">案例</h3><img src="/2025/01/25/C5/image-20241012163844354.png" class="" title="image-20241012163844354"><p><strong>声明二维数组：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T A[c1][c2];</span><br></pre></td></tr></table></figure><p><strong>typedef 和 using 在数组中的应用</strong></p><p><strong>typedef 用法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> T U[c2];  <span class="comment">// 定义新类型 U 为一个包含 c2 个 T 元素的一维数组</span></span><br><span class="line">T a[c1];           <span class="comment">// 声明一个包含 c1 个 T 元素的数组 a</span></span><br></pre></td></tr></table></figure><ul><li><code>U</code> 被定义为一个大小为 <code>c2</code> 的一维数组类型。</li></ul><p><strong>using 用法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> T = U[c2];  <span class="comment">// 使用 C++11 的 using 定义类型别名</span></span><br><span class="line">T a[c1];           <span class="comment">// 声明一个大小为 c1 的数组，其中每个元素是大小为 c2 的数组</span></span><br></pre></td></tr></table></figure><ul><li><code>using</code> 是 C++11 引入的，用于替代 <code>typedef</code>，其语法更简洁，尤其在定义模板类型时。</li></ul><p>两种方式效果类似，但**<code>using</code>** 语法更推荐在现代 C++ 中使用。</p><h2 id="Ragged-Array">Ragged Array</h2><p>不规则数组（Ragged Array）是指 <strong>每一行的列数不同</strong> 的二维数组，这与普通的矩阵不同。虽然 C++ 不直接支持不规则数组，但我们可以通过 <strong>数组指针或动态分配内存</strong> 实现。</p><p>在 PPT 中，不规则数组的概念以 <strong>Java 的代码</strong> 展示出来：</p><p><strong>Java 中的不规则数组（Ragged Array）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">displayArray2D</span><span class="params">(<span class="type">int</span>[][] arrays)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] eachArray : arrays) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> eachValue : eachArray) &#123;</span><br><span class="line">            System.out.print(eachValue + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>解释：<ul><li><code>arrays</code> 是一个二维数组的参数，但每一行可以有不同的长度（即不规则数组）。</li><li>使用 <strong>增强型 <code>for</code> 循环</strong> 遍历二维数组中的每一行和每个元素，并逐个打印出来。</li></ul></li></ul><h3 id="案例-3">案例</h3><img src="/2025/01/25/C5/image-20241012164121683.png" class="" title="image-20241012164121683"><p>对于数组的C++表达，以<code>int a[6][2]</code>为例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> T[<span class="number">2</span>];  <span class="comment">// 定义 T 为大小为 2 的数组类型</span></span><br><span class="line">T a[<span class="number">6</span>];            <span class="comment">// 定义 a 为包含 6 行的数组，每行 2 列</span></span><br></pre></td></tr></table></figure><p>可以理解为T是一个指针，指向的是Int[2]数组，那么<code>T a[6]</code>就是6个指向int[2]的数组，即<code>a[6][2]</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">6</span>][<span class="number">2</span>];           <span class="comment">// 声明一个 6x2 的二维数组</span></span><br><span class="line"><span class="type">int</span>* p = &amp;a[<span class="number">0</span>][<span class="number">0</span>];     <span class="comment">// p 是指向二维数组第一个元素的指针</span></span><br><span class="line"><span class="built_in">int</span> (*q)[<span class="number">2</span>] = a;       <span class="comment">// q 是指向数组行的指针，每行有 2 个元素</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>q</code></strong> 是一个<strong>行指针</strong>，其类型为 <code>int (*q)[2]</code>，表示指向大小为 2 的数组的指针。</li></ul><p><strong>解读：</strong></p><ul><li><code>p</code> 是单一元素级别的指针，指向 <code>a</code> 中具体的元素，例如 <code>p + 1</code> 指向 <code>a[0][1]</code>。</li><li><code>q</code> 是行指针，指向二维数组中的整行。<code>q + 1</code> 会跳到 <code>a[1]</code>，即数组的第二行。</li></ul><h2 id="行指针与二维数组">行指针与二维数组</h2><h3 id="案例-4">案例</h3><img src="/2025/01/25/C5/image-20241015141722410.png" class="" title="image-20241015141722410"><p><strong>1. 一维数组和指针的关系</strong></p><ul><li>略</li></ul><p><strong>2. 二维数组与指针的关系</strong></p><p><strong>代码部分：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b[<span class="number">20</span>][<span class="number">10</span>];   <span class="comment">// 定义一个20x10的二维数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> T[<span class="number">10</span>];   <span class="comment">// 定义类型别名T，表示一个包含10个整数的数组</span></span><br><span class="line">T b[<span class="number">20</span>];   <span class="comment">// 使用typedef定义二维数组的另一种写法</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *q;</span><br><span class="line">q = &amp;b[<span class="number">0</span>][<span class="number">0</span>];   <span class="comment">// q 指向二维数组第一个元素的地址</span></span><br><span class="line">q = b[<span class="number">0</span>];       <span class="comment">// 等价写法，指向第一行的第一个元素</span></span><br></pre></td></tr></table></figure><p>==<strong>二维数组元素的访问：</strong>==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b[i][j] ⇔ *(&amp;b[<span class="number">0</span>][<span class="number">0</span>] + i * <span class="number">10</span> + j) ⇔ *(q + i * <span class="number">10</span> + j) ⇔ q[i * <span class="number">10</span> + j]</span><br></pre></td></tr></table></figure><p><strong>知识点解析：</strong></p><ul><li><strong>访问二维数组元素</strong>：<code>b[i][j]</code> 表示第 <code>i</code> 行第 <code>j</code> 列的元素。</li><li><strong>指针运算</strong>：通过 <code>(&amp;b[0][0] + i * 10 + j)</code> 可以计算出数组元素的地址。</li><li>==<strong>指针访问</strong>==：<code>*(q + i * 10 + j)</code> 或 <code>q[i * 10 + j]</code> 可以等效访问元素。</li></ul><p><strong><code>q</code> 是一个 <code>int*</code></strong>，指向二维数组中的一个整数元素。在这种情况下，二维数组 <strong>“降维”</strong> 处理，被视为一个连续的线性数组，因此可以使用：</p><p>*<em>相当于对于一个int <em>q = b，即一个int指针指向高位数组，那么在对q指针进行下标访问时，q只能使用一维数组的下标访问方法，如<code>q[i*10+j]</code>进行访问</em></em></p><p><strong>指针类型的影响</strong>：</p><ul><li><p>如果你声明了一个指向<strong>数组行</strong>的指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*p)[<span class="number">10</span>] = b;  <span class="comment">// p 是一个指向含有10个整数的数组的指针</span></span><br></pre></td></tr></table></figure><p>访问方式会变成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p[i][j];  <span class="comment">// 直接访问第 i 行第 j 列的元素</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>行指针的使用：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T *p;</span><br><span class="line">p = &amp;b[<span class="number">0</span>];   <span class="comment">// p 指向二维数组的第一行</span></span><br><span class="line">p = b;       <span class="comment">// 等价写法，指向二维数组的第一行</span></span><br></pre></td></tr></table></figure><p><strong>知识点解析：</strong></p><ul><li><strong><code>T *p</code></strong> 是一个指向数组行的指针。</li><li><strong><code>p = &amp;b[0]</code> 或 <code>p = b</code></strong>：这两种写法表示指针 <code>p</code> 指向二维数组的第一行。</li></ul><hr><p><strong>元素访问与指针偏移：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b[i][j] ⇔ *((b + i) + j) ⇔ *((p + i) + j) ⇔ p[i][j]</span><br></pre></td></tr></table></figure><p><strong>知识点解析：</strong></p><ul><li><strong>二维数组的访问</strong>：<code>b[i][j]</code> 表示第 <code>i</code> 行第 <code>j</code> 列的元素。</li><li><strong>指针计算</strong>：通过偏移计算访问二维数组中的元素，例如 <code>*((b + i) + j)</code>。</li></ul><h2 id="Dimension-Reduction">Dimension Reduction</h2><h3 id="案例-5">案例</h3><img src="/2025/01/25/C5/image-20241015143712523.png" class="" title="image-20241015143712523"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximum</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">        <span class="keyword">if</span> (a[k] &gt; max)</span><br><span class="line">            max = a[k];</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> A[<span class="number">2</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">68</span>, <span class="number">69</span>, <span class="number">70</span>, <span class="number">71</span>&#125;, &#123;<span class="number">85</span>, <span class="number">86</span>, <span class="number">87</span>, <span class="number">89</span>&#125; &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;the max grade is &quot;</span> &lt;&lt; <span class="built_in">maximum</span>(A[<span class="number">0</span>], <span class="number">2</span> * <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><strong>降维处理的核心概念</strong>：</p><ul><li>目标：将 <strong>二维数组</strong> 转换为 <strong>一维数组</strong> 进行处理。这是一种常见的降维操作，通过将多维数组“线性化”传递给只接受一维数组的函数。</li><li>通过传递 <strong>二维数组的首地址</strong>，以及 <strong>元素数量的乘积</strong>，我们可以将二维数组 <strong>视为一维数组</strong> 进行处理。</li></ul></li><li><p><strong><code>int maximum(int a[], int n)</code></strong>：</p><ul><li>这个函数接收一个 <strong>一维数组</strong> 和其长度 <code>n</code>，用于计算数组中的最大值。</li></ul></li><li><p><strong>二维数组传递为一维数组</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maximum(A[0], 2 * 4);</span><br></pre></td></tr></table></figure><ul><li><strong><code>A[0]</code></strong> 是二维数组的第一行，实际上是一个指向 <code>int</code> 类型数据的指针（即指向 <code>A[0][0]</code>）。</li><li>这里我们将整个二维数组 <strong>线性化</strong>，通过 <code>A[0]</code> 传递数组的首地址，并指定数组长度为 <code>2 * 4 = 8</code>。</li></ul></li><li><p><strong>调用示例：</strong></p><ul><li><pre><code>maximum(&amp;A[0][0], 2 * 4);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     - 等效于传递 `A[0]`，因为 `A[0]` 和 `&amp;A[0][0]` 指向同一个地址。</span><br><span class="line">     - 这里将整个二维数组作为一维数组来处理，共计 8 个元素。</span><br><span class="line"></span><br><span class="line">**尺寸计算：**</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">sizeof(A) / sizeof(A[0][0]);</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ol><ul><li><p><strong><code>sizeof(A)</code></strong>：计算整个二维数组 <code>A[2][4]</code> 的字节大小。假设 <code>int</code> 类型占用 4 字节，则：</p><ul><li><code>sizeof(A) = 2 * 4 * 4 = 32</code> 字节。</li></ul></li><li><p><strong><code>sizeof(A[0][0])</code></strong>：表示数组中单个元素的大小，即 <code>4</code> 字节。</p></li><li><p>计算结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sizeof</span>(A) / <span class="built_in">sizeof</span>(A[<span class="number">0</span>][<span class="number">0</span>]) = <span class="number">32</span> / <span class="number">4</span> = <span class="number">8</span></span><br></pre></td></tr></table></figure><ul><li>这表明二维数组 <strong>逻辑上可以视为一个包含 8 个元素的一维数组</strong>。</li></ul></li></ul><p><strong><code>typeid(A[0]).name()</code>：</strong></p><ul><li><strong><code>typeid</code></strong> 是 C++ 的运行时类型识别（RTTI）工具，用于在运行时获取变量的类型信息。</li><li><code>typeid(A[0]).name()</code>：这里会返回 <strong><code>A[0]</code></strong> 的类型名称。<code>A[0]</code> 是一个 <strong>一维数组的引用</strong>，其类型是 <code>int[4]</code>。</li></ul><p>函数也可以传递二维数组，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximum</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">        <span class="keyword">if</span> (a[k] &gt; max)</span><br><span class="line">            max = a[k];</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximum</span><span class="params">(<span class="type">int</span> a[][<span class="number">4</span>], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[k][i] &gt; max)</span><br><span class="line">                max = a[k][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> B[<span class="number">2</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">68</span>, <span class="number">69</span>, <span class="number">70</span>, <span class="number">71</span>&#125;, &#123;<span class="number">85</span>, <span class="number">86</span>, <span class="number">87</span>, <span class="number">89</span>&#125; &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;the max grade is &quot;</span> &lt;&lt; <span class="built_in">maximum</span>(B, <span class="number">2</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">typeid</span>(B[<span class="number">0</span>]).<span class="built_in">name</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">typeid</span>(B).<span class="built_in">name</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">typeid</span>(B[<span class="number">0</span>][<span class="number">0</span>]).<span class="built_in">name</span>();</span><br><span class="line"><span class="comment">//the max grade is 89 A4_i A2_A4_i i</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>多维数组传参的规则</strong>：</p><ul><li><strong>第一维可以不指定</strong>，因为传递时是按行传递的地址。</li><li><strong>后续维度必须指定</strong>，这样编译器才能知道每行的偏移量。</li></ul><p><strong>一维数组和二维数组传参的区别</strong></p><ol><li><p><strong>传递二维数组：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">maximum</span>(A, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><ul><li>这里传递的是整个 <strong>二维数组</strong> <code>A</code> 的地址。</li><li>在函数中，<code>A</code> 被解释为 <code>int[2][4]</code> 类型。</li></ul></li><li><p><strong>传递一维数组：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">maximum</span>(A[<span class="number">0</span>], <span class="number">4</span>);</span><br></pre></td></tr></table></figure><ul><li>这里传递的是 <strong>二维数组第一行的地址</strong>（即 <code>A[0]</code> 的类型是 <code>int[4]</code>）。</li><li>在函数中，它会被解释为一维数组。</li></ul></li></ol><p><strong>二维数组传参为什么需要明确标注除第一维外的维度？</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximum</span><span class="params">(<span class="type">int</span> a[][<span class="number">4</span>], <span class="type">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>这是因为 C++ 编译器需要知道每一行占据多少内存。在本例中，每一行 <code>a[k]</code>有 4 个 <code>int</code> 元素，所以：<ul><li>每行占据 <code>4 * sizeof(int)</code> 字节。</li><li>如果不明确指定列数（即 <code>4</code>），编译器无法正确计算每行的偏移。</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k][i] = *(*(a + k) + i);</span><br></pre></td></tr></table></figure><ul><li>其中a+k指向第k行的<strong>首地址</strong>，即<code>&amp;a[k]</code></li><li><code>*(a + k)</code>：指向第 k 行第 0 列元素的指针，即<code>a[k]</code></li></ul><img src="/2025/01/25/C5/image-20241015151635665.png" class="" title="image-20241015151635665"><ul><li>编译器根据 **<code>a[k]</code> 的长度（即 4 个整数的大小）**来进行偏移。</li></ul><p>因此，<strong>必须在函数声明中指定所有除第一维以外的维度</strong>，让编译器正确处理每行的偏移。</p><h2 id="Dimension-augmentation">Dimension augmentation</h2><h3 id="案例-6">案例</h3><img src="/2025/01/25/C5/image-20241015150736777.png" class="" title="image-20241015150736777"><p><strong>1. 一维数组的显示</strong></p><ul><li>略</li></ul><p><strong>2. 二维数组的显示</strong></p><p><strong>函数：<code>show(int a[][2], int n)</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> a[][<span class="number">2</span>], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">            cout &lt;&lt; a[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout &lt;&lt; *(a+i) + j &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; a[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//*(a+i) + j为地址</span></span><br><span class="line">            <span class="keyword">if</span> ((i * <span class="number">2</span> + j + <span class="number">1</span>) % <span class="number">4</span> == <span class="number">0</span>) cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>二维数组传参</strong>：<code>int a[][2]</code> 表示每一行有 2 个元素。</li><li><strong>指针访问</strong>：<code>*(a+i) + j</code>为<code>a[i][j]</code>地址</li><li><strong>打印逻辑</strong>：每打印 4 个元素后换行。</li></ul><p><strong>3. 三维数组的显示</strong></p><p><strong>函数：<code>show(int a[][2][3], int n)</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> a[][<span class="number">2</span>][<span class="number">3</span>], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">                cout &lt;&lt; *( *(a + i) + j ) + k &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; a[i][j][k] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                <span class="keyword">if</span> ((i * <span class="number">6</span> + j * <span class="number">3</span> + k + <span class="number">1</span>) % <span class="number">4</span> == <span class="number">0</span>) cout &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>三维数组传参</strong>：<code>int a[][2][3]</code> 表示每一层有 2 行，每行 3 个元素。</li><li><strong>指针访问</strong>：<code>*( *(a + i) + j ) + k</code> 是三维数组的指针访问形式，对应 <code>a[i][j][k]</code>的<strong>地址</strong></li><li><strong>换行逻辑</strong>：每打印 4 个元素后换行。</li></ul><p><strong>4. Main 函数中的 typedef 和类型转换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++) </span><br><span class="line">        b[i] = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">show</span>(b, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> T[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">show</span>((T *)b, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> T1[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">typedef</span> T1 T2[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">show</span>((T2 *)b, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong></p><ol><li><strong><code>typedef int T[2];</code></strong><ul><li>定义 <code>T</code> 为长度为 2 的 <code>int</code> 数组类型。</li><li><code>(int (*)[2])b</code> 将 <code>b</code> 转换为指向二维数组的指针类型。</li></ul></li><li><strong><code>typedef int T1[3];</code> 和 <code>typedef T1 T2[2];</code></strong><ul><li><code>T1</code>可看做指向 <code>int[3]</code>的指针</li><li><code>T2</code> 可看做指向<code>int[2][3]</code>的指针</li><li><code>(int (*)[2][3])b</code> 和 <code>(T2 *)b</code> 将数组转换为指向三维数组的指针。</li></ul></li></ol><h2 id="Pointer-and-Function">Pointer and Function</h2><h3 id="案例-7">案例</h3><img src="/2025/01/25/C5/image-20241015160455810.png" class="" title="image-20241015160455810"><ol><li><strong>As Argument（作为参数传递）</strong></li></ol><ul><li><strong>提高传输效率</strong>：<ul><li>将指针作为参数传递时，<strong>只传递地址，而不是整个对象的副本。这样可以减少内存的消耗</strong></li></ul></li><li><strong>函数副作用（Side Effect）</strong>：<ul><li>当指针传递给函数时，函数可以通过指针改变传入变量的值。这就是指针传递可能带来的<strong>副作用</strong>：函数调用结束后，外部变量的值可能被修改。</li></ul></li><li><strong>常量指针（const Pointer）</strong>：<ul><li>使用<code>const</code>修饰指针参数，可以防止在函数内修改指针所指向的内容。这对于需要保证函数调用的安全性和数据的不可变性非常有用。</li></ul></li></ul><p><strong>代码片段</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun1</span><span class="params">(<span class="type">int</span> *p)</span> </span>&#123;</span><br><span class="line">    *p = <span class="number">10</span>;  <span class="comment">// 读写指针指向的内容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun1</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// *p = 10;  // 编译错误，只读</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第一种<code>void Fun1(int *p)</code>：传递的指针允许读写。</li><li>第二种<code>void Fun1(const int *p)</code>：传递的指针只能读取内容，不能修改。</li></ul><ol start="2"><li><strong>Function Pointer（函数指针）</strong></li></ol><ul><li>指向函数的指针：<ul><li><strong>函数指针</strong>是指向函数的指针，它保存了函数的入口地址，可以通过它调用对应的函数。</li><li>这种方式允许程序在运行时动态选择要调用的函数，类似于回调机制。</li></ul></li></ul><p>==<strong>代码片段：</strong>==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个函数指针 fp1 指向 double(int) 类型的函数</span></span><br><span class="line">    <span class="built_in">double</span> (*fp1)(<span class="type">int</span>) = &amp;f;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过函数指针调用函数</span></span><br><span class="line">    (*fp1)(<span class="number">10</span>);  <span class="comment">// 或者：fp1(10);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义指向无参 int 函数的指针，并赋值给 g</span></span><br><span class="line">    <span class="built_in">int</span> (*fp2)() = &amp;g;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过函数指针调用无参函数</span></span><br><span class="line">    (*fp2)();  <span class="comment">// 或者：fp2();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>==解释：==<ul><li><code>double (*fp1)(int) = &amp;f;</code>：定义了一个函数指针<code>fp1</code>，指向返回类型为<code>double</code>、参数为<code>int</code>的函数<code>f</code>。</li><li>通过<code>(*fp1)(10);</code>调用函数<code>f</code>，也可以直接写成<code>fp1(10);</code>。</li></ul></li></ul><ol start="3"><li><strong>使用 <code>typedef</code> 定义函数指针类型</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> x1)</span></span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f2</span><span class="params">(<span class="type">int</span> x2)</span></span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f3</span><span class="params">(<span class="type">int</span> x3)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">double</span> <span class="params">(*FP)</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">FP fp = f1;  <span class="comment">// 指向 f1</span></span><br><span class="line">fp = f2;     <span class="comment">// 改为指向 f2</span></span><br><span class="line">fp = f3;     <span class="comment">// 改为指向 f3</span></span><br></pre></td></tr></table></figure><ul><li>解释：<ul><li><code>typedef double (*FP)(int);</code>：定义了一个名为<code>FP</code>的函数指针类型，它指向返回类型为<code>double</code>、参数为<code>int</code>的函数。</li><li>通过将<code>fp</code>依次指向<code>f1</code>、<code>f2</code>、<code>f3</code>，可以动态调用不同的函数。这种用法在回调函数和事件处理机制中非常常见。</li></ul></li></ul><h2 id="Function-Pointer">Function Pointer</h2><h3 id="案例-8">案例</h3><img src="/2025/01/25/C5/image-20241016102219800.png" class="" title="image-20241016102219800"><p><strong>1. 函数指针的定义和使用</strong></p><p><strong>函数指针的声明：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">integrate</span><span class="params">(<span class="type">double</span> (*f)(<span class="type">double</span>), <span class="type">double</span> a, <span class="type">double</span> b)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>**解释：**这里的<code>integrate</code>函数接受一个函数指针作为参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double (*f)(double)</span><br></pre></td></tr></table></figure><p>表示：</p><ul><li>传递给<code>integrate</code>的参数<code>f</code>是一个指向函数的指针。</li><li>该函数的参数是一个<code>double</code>类型的变量，并且返回一个<code>double</code>类型的值。</li></ul></li><li><p><strong>函数指针的意义：</strong></p><ul><li>函数指针使得<code>integrate</code>函数能够动态地接受不同的函数作为参数，例如<code>sin</code>、<code>cos</code>或用户定义的函数<code>my_func</code>。</li></ul></li></ul><p>==函数可以做参数：（函数是一等公民）==</p><p><strong>2. 示例函数定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">my_func</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用户自定义的函数，返回某种计算结果</span></span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个函数可以与<code>sin</code>、<code>cos</code>等函数一起传递给<code>integrate</code>函数。</li></ul><p><strong>3. <code>main</code>函数的作用和示例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">integrate</span>(sin, <span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// 计算 sin 在 [0, 1] 上的积分</span></span><br><span class="line">    <span class="built_in">integrate</span>(cos, <span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// 计算 cos 在 [1, 2] 上的积分</span></span><br><span class="line">    <span class="built_in">integrate</span>(my_func, <span class="number">1</span>, <span class="number">10</span>);  <span class="comment">// 计算 my_func 在 [1, 10] 上的积分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>解释：在<code>main</code>函数中，调用<code>integrate</code>函数，并传入不同的函数作为参数进行积分：</li></ul><h2 id="Function运行时环境">Function运行时环境</h2><h3 id="案例-9">案例</h3><img src="/2025/01/25/C5/image-20241016102822260.png" class="" title="image-20241016102822260"><p><strong>1. 左侧函数定义与符号表</strong></p><p><strong>函数定义：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> d)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>解释：</strong><ul><li>这两行展示了两个<strong>重载的函数</strong>，一个接受一个<code>int</code>参数，另一个接受两个参数<code>(int, double)</code>。</li><li>在C++中，<strong>函数重载</strong>允许同名函数根据参数的不同而实现不同的行为。PPT展示了这两个重载函数在内存中的位置和符号表中如何映射。</li></ul></li></ul><p><strong>2. 符号表与静态符号映射</strong></p><p>在PPT左下角，我们可以看到<strong>符号表</strong>的部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x               0x02020202</span><br><span class="line">d               0x04040404</span><br><span class="line">(func) _Z4funci 0x01010101</span><br><span class="line">_Z4funcid       0x010101AB</span><br></pre></td></tr></table></figure><ul><li><p><strong>符号表（Symbol Table）：</strong></p><ul><li><strong>符号表</strong>保存了程序中变量、函数等符号的<strong>名称</strong>和它们在<strong>内存中的地址</strong>。这些地址帮助编译器和链接器在程序中找到正确的函数或变量。</li></ul></li><li><p><strong>符号名解析（Name Mangling）：</strong></p><ul><li>C++在符号表中将函数名称进行<strong>修饰（Name Mangling）</strong>，以支持重载：<ul><li><strong><code>_Z4funci</code></strong>：这是表示**<code>int func(int)</code>**的修饰名称。</li><li><strong><code>_Z4funcid</code></strong>：这是表示**<code>int func(int, double)</code>**的修饰名称。</li></ul></li><li><strong>Name Mangling</strong> 是必要的，因为 C++ 支持函数重载，不同的函数需要被区分开。经过修饰的符号名称会包含函数的参数类型信息，因此同名函数（不同参数）在符号表中不会冲突。</li></ul></li></ul><p><strong>3. 内存布局与运行时环境（Runtime Environment）</strong></p><p>右侧展示了典型C/C++程序的<strong>内存布局</strong>，分为：</p><ul><li><strong>Code 区段（R）</strong>：存放程序的指令，即代码本身。</li><li><strong>Data 区段（RW）</strong>：存储<strong>全局变量</strong>和<strong>静态变量</strong>，这些变量在整个程序运行期间都存在。</li><li><strong>Heap 堆区（RW）</strong>：用于动态内存分配，比如通过<code>malloc</code>或<code>new</code>分配的内存。</li><li><strong>Stack 栈区（RW）</strong>：存储局部变量和函数调用的参数。</li></ul><p><strong>每个区域的细节：</strong></p><p><strong>Code 区段</strong></p><ul><li>存放可执行代码和函数，比如<code>func(int)</code> 和 <code>func(int, double)</code>。</li><li><strong>COST</strong>标签表示：函数调用会有性能开销，如栈帧的创建和参数传递。</li></ul><p><strong>Data 区段</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>; <span class="comment">// 名、值、地址、类型、性质</span></span><br></pre></td></tr></table></figure><ul><li>静态全局变量<code>x</code>会被存放在<strong>Data区</strong>。它的内存地址是<code>0x02020202</code>，这个地址在程序运行期间不会改变。</li></ul><p><strong>Heap 堆区</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><ul><li>动态分配的内存存储在<strong>Heap区</strong>，并且内存地址是<code>0x03030303</code>。</li><li><strong>动态内存</strong>需要手动管理，使用<code>malloc/free</code>或<code>new/delete</code>。</li></ul><p><strong>Stack 栈区</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> d = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ul><li>局部变量<code>d</code>在<strong>栈区</strong>分配，栈区是**LIFO（后进先出）**结构，随着函数调用栈的增长和缩减而变化。变量<code>d</code>的地址在符号表中为<code>0x04040404</code>。</li></ul><p><strong>3. 函数调用的COST</strong></p><ul><li><strong>PPT中的COST标签：</strong><ul><li>每次函数调用都会有一定的性能开销：<ul><li>创建新的<strong>栈帧</strong>，存储局部变量和函数参数。</li><li>在函数退出时，栈帧会被销毁。</li></ul></li></ul></li></ul><p><strong>4. 三个Questions</strong>（仅供参考）</p><p><strong>Q1. 能否不降低可读性的前提下，降低COST？</strong></p><p>答案：</p><ul><li>可以通过**内联函数（inline）**减少函数调用的开销，避免频繁的栈操作。</li><li>使用<strong>模板函数（template）</strong>，将代码直接展开在编译时。</li><li>减少<strong>递归调用</strong>和优化参数传递方式（如通过引用或指针传递）。</li></ul><hr><p><strong>Q2. 使用Lib需要注意什么？</strong></p><p>答案：</p><ul><li><strong>ABI兼容性</strong>：库的二进制接口（ABI）必须与调用代码兼容，避免链接错误。</li><li><strong>线程安全</strong>：如果多个线程使用同一个库函数，需要确认该库是线程安全的。</li><li><strong>性能与依赖</strong>：了解库的依赖关系和潜在性能开销，避免不必要的依赖增加二进制大小。</li><li><strong>动态库 vs 静态库</strong>：根据应用场景选择使用动态库（减小程序体积）还是静态库（提升独立性）。</li></ul><p><strong>Q3. 执行性能如何？</strong></p><p>答案：</p><ul><li>执行性能依赖于<strong>函数调用开销</strong>和<strong>内存布局的高效性</strong>。</li><li>使用合适的数据结构和减少不必要的动态分配，可以提高执行效率。</li><li>函数调用链过长或频繁的堆分配都会增加执行时间，降低性能。</li><li><strong>编译器优化</strong>（如内联、常量传播）对执行性能有很大影响。</li></ul><h2 id="Function">Function</h2><h3 id="案例-10">案例</h3><img src="/2025/01/25/C5/image-20241016104628420.png" class="" title="image-20241016104628420"><h3 id="一-函数的原则"><strong>一. 函数的原则</strong></h3><ol><li><p><strong>定义不允许嵌套</strong>：</p><ul><li><strong>解释</strong>：C++中不支持函数的嵌套定义，即不允许一个函数内部再定义另一个函数。所有函数必须在文件的全局作用域或类中定义。</li><li><strong>示例（非法代码）</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">outerFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">innerFunction</span><span class="params">()</span> </span>&#123;  <span class="comment">// 错误：不允许嵌套定义</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Inner function&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>先定义后使用</strong>：</p><ul><li><strong>解释</strong>：函数必须要么在调用之前定义，要么在调用之前声明（通过函数原型）。这保证了在编译阶段，编译器能够识别函数的调用。</li><li><strong>函数原型声明</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span></span>;  <span class="comment">// 函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">myFunction</span>();  <span class="comment">// 可以正常调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;  <span class="comment">// 函数定义</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="二-函数的执行机制"><strong>二. 函数的执行机制</strong></h3><ol><li><p><strong>建立被调用函数的栈空间</strong>：</p><ul><li><p><strong>解释</strong>：每次调用函数时，程序会在<strong>栈</strong>中创建一个新的栈帧，用于存储该函数的局部变量、参数、返回地址等信息。这是函数调用过程中的一个关键操作。</p></li><li><p><strong>栈帧示例</strong>：</p><ul><li>参数：如<code>int a</code>、<code>int b</code></li><li>局部变量：如<code>int sum</code></li><li>返回地址：指向调用函数的位置</li></ul></li><li><p><strong>栈的特点</strong>：</p><ul><li>后进先出（LIFO）</li><li>每次函数返回时，栈帧被弹出。</li></ul></li></ul></li><li><p><strong>参数传递机制</strong>：</p><ul><li><p><strong>值传递（Call by Value）</strong>：</p><ul><li>将实参的值拷贝一份传递给函数。函数内部的参数与外部变量<strong>没有联系</strong>，在函数内修改参数不会影响外部变量。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeValue</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">10</span>;  <span class="comment">// 只改变了局部变量x的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">changeValue</span>(a);</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;  <span class="comment">// 输出：5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>引用传递（Call by Reference）</strong>：</p><ul><li>将变量的引用传递给函数，函数内部对参数的修改会直接影响原变量的值。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeValue</span><span class="params">(<span class="type">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">10</span>;  <span class="comment">// 修改了外部变量的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">changeValue</span>(a);</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;  <span class="comment">// 输出：10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>保存调用函数的运行状态</strong>：</p><ul><li>在函数调用时，**当前的运行状态（即寄存器和栈信息）**会被保存，以便函数返回后能够恢复原状态。这是通过栈帧机制实现的。</li></ul></li><li><p><strong>将控制权转交给被调用函数</strong>：</p><ul><li>当调用一个函数时，程序会将控制权转交给被调用函数，并且函数执行完毕后，再将控制权返回给调用者。每次控制权的转交都伴随着栈帧的创建和销毁。</li></ul></li></ol><h2 id="汇编小结">汇编小结</h2><p>这里是一些常见的 <strong>x86 汇编语法规则</strong>，分别解释 AT&amp;T 语法和 Intel 语法的特点，覆盖你提到的所有相关汇编指令。</p><p><strong>通用语法概念：</strong></p><ol><li><strong>寄存器</strong>：汇编中，CPU 寄存器被直接使用。常见的寄存器有：<ul><li><code>eax</code>, <code>ebx</code>, <code>ecx</code>, <code>edx</code>：常规数据寄存器。</li><li><code>esp</code>：堆栈指针寄存器，用于指向当前栈顶。</li><li><code>ebp</code>：基址指针寄存器，常用于函数调用时保存调用栈的基址。</li><li><code>eip</code>：指令指针寄存器，指向下一条执行的指令。</li></ul></li></ol><p><strong>AT&amp;T 语法 vs. Intel 语法：</strong></p><ol><li><p><strong>操作数顺序</strong>：</p><ul><li><strong>AT&amp;T</strong>：<code>操作数源, 操作数目标</code>（<strong>源在前，目标在后</strong>）。</li><li><strong>Intel</strong>：<code>操作数目标, 操作数源</code>（目标在前，源在后）。</li></ul></li><li><p><strong>寄存器前缀</strong>：</p><ul><li><strong>AT&amp;T</strong>：寄存器前无需前缀，寄存器名是区分大小写的。</li><li><strong>Intel</strong>：寄存器前没有前缀。</li></ul></li><li><p><strong>立即数</strong>：</p><ul><li><strong>AT&amp;T</strong>：立即数使用 <code>$</code> 作为前缀，表示常量。<ul><li>如：<code>$0xc</code> 表示常量 <code>12</code>。</li></ul></li><li><strong>Intel</strong>：立即数不使用前缀。</li></ul></li><li><p><strong>内存地址</strong>：</p><ul><li><strong>AT&amp;T</strong>：<strong>内存操作数用 <code>()</code> 来表示间接寻址。</strong><ul><li>如：<code>(%esp)</code> 表示 <code>esp</code> 所指向的地址。</li></ul></li><li><strong>Intel</strong>：直接写内存地址。<ul><li>如：<code>[esp]</code> 表示 <code>esp</code> 所指向的地址。</li></ul></li></ul></li><li><p><strong>汇编指令</strong>：</p><ul><li>指令前缀和后缀：<ul><li><strong>AT&amp;T</strong>：指令后可能会带有 <code>b</code>, <code>w</code>, <code>l</code> 后缀，分别表示字节（byte）、字（word）和长字（long word）。</li><li><strong>Intel</strong>：无此后缀，取决于操作数的大小。</li></ul></li><li>示例：<ul><li><strong>AT&amp;T</strong>：<code>movl %eax, (%esp)</code> 表示将 <code>eax</code> 中的数据存储到 <code>esp</code> 所指向的内存地址。</li><li><strong>Intel</strong>：<code>mov [esp], eax</code> 同样表示将 <code>eax</code> 中的数据存储到 <code>esp</code> 所指向的内存地址。</li></ul></li></ul></li></ol><h3 id="常见指令语法">常见指令语法</h3><p><strong>1. <code>mov</code>（数据传输）</strong></p><ul><li><strong>AT&amp;T</strong>：<code>mov source, destination</code><ul><li>示例：<code>movl %eax, -0xc(%ebp)</code> 表示将 <code>eax</code> 的内容存到 <code>ebp-0xc</code> 的地址。</li></ul></li><li><strong>Intel</strong>：<code>mov destination, source</code><ul><li>示例：<code>mov [ebp-0xc], eax</code></li></ul></li></ul><p><strong>2. <code>add</code>（加法运算）</strong></p><ul><li><strong>AT&amp;T</strong>：<code>add source, destination</code><ul><li>示例：<code>add $0x10, %esp</code> 表示将 <code>esp</code> 加上 <code>0x10</code>。</li></ul></li><li><strong>Intel</strong>：<code>add destination, source</code><ul><li>示例：<code>add esp, 0x10</code></li></ul></li></ul><p><strong>3. <code>sub</code>（减法运算）</strong></p><ul><li><strong>AT&amp;T</strong>：<code>sub source, destination</code><ul><li>示例：<code>sub $0xc, %esp</code> 表示从 <code>esp</code> 中减去 <code>0xc</code>。</li></ul></li><li><strong>Intel</strong>：<code>sub destination, source</code><ul><li>示例：<code>sub esp, 0xc</code></li></ul></li></ul><p><strong>4. <code>push</code>（压栈）</strong></p><ul><li>将数据压入栈中，栈指针 <code>esp</code> 向下移动。</li><li><strong>AT&amp;T 和 Intel 都是一样的写法</strong>：<ul><li>示例：<code>push %ebp</code> 表示将 <code>ebp</code> 的内容压入栈中，<strong><code>esp</code> 减少 4 字节（32 位系统）。</strong></li></ul></li></ul><p><strong>5. <code>pop</code>（出栈）</strong></p><ul><li>从栈中弹出数据，栈指针 <code>esp</code> 向上移动。</li><li><strong>AT&amp;T 和 Intel 都是一样的写法</strong>：<ul><li>示例：<code>pop %ebp</code> 表示将栈顶的值弹出，存储到 <code>ebp</code> 中，<strong><code>esp</code> 增加 4 字节（32 位系统）。</strong></li></ul></li></ul><p><strong>6. <code>call</code>（函数调用）</strong></p><ul><li>调用一个函数，将当前 <code>eip</code> 寄存器（指向下一条指令的地址）压入栈中，并跳转到指定的函数地址执行。</li><li><strong>AT&amp;T 和 Intel 都是一样的写法</strong>：<ul><li>示例：<code>call _Z4funci</code> 表示调用名为 <code>_Z4funci</code> 的函数。</li></ul></li></ul><p><strong>7. <code>ret</code>（返回）</strong></p><ul><li>从当前函数返回。执行时，恢复先前压入栈中的返回地址到 <code>eip</code>，并跳转到该地址继续执行。</li><li><strong>AT&amp;T 和 Intel 都是一样的写法</strong>：<ul><li>示例：<code>ret</code> 表示从当前函数返回。</li></ul></li></ul><p><strong>8. <code>lea</code>（加载有效地址）</strong></p><ul><li>计算表达式的内存地址，并将该地址加载到寄存器中。</li><li><strong>AT&amp;T</strong>：<code>lea source, destination</code><ul><li>示例：<code>lea -0xc(%ebp), %eax</code> 表示将 <code>ebp-0xc</code> 的地址加载到 <code>eax</code> 中。</li></ul></li><li><strong>Intel</strong>：<code>lea destination, source</code><ul><li>示例：<code>lea eax, [ebp-0xc]</code></li></ul></li></ul><p><strong>9. <code>jmp</code>（跳转）</strong></p><ul><li>无条件跳转到指定的地址继续执行。</li><li><strong>AT&amp;T 和 Intel 都是一样的写法</strong>：<ul><li>示例：<code>jmp _Z4funci</code> 表示跳转到 <code>_Z4funci</code> 函数开始执行。</li></ul></li></ul><p><strong>10. <code>cmp</code>（比较）</strong></p><ul><li>比较两个操作数，影响标志寄存器（flags）的状态，通常与条件跳转指令配合使用。</li><li><strong>AT&amp;T</strong>：<code>cmp source, destination</code><ul><li>示例：<code>cmp $0, %eax</code> 表示比较 <code>eax</code> 和 <code>0</code>。</li></ul></li><li><strong>Intel</strong>：<code>cmp destination, source</code><ul><li>示例：<code>cmp eax, 0</code></li></ul></li></ul><p><strong>11. <code>je</code> / <code>jne</code>（条件跳转）</strong></p><ul><li>条件跳转，基于前面的 <code>cmp</code> 指令结果：<ul><li><code>je</code>：等于时跳转（zero flag 置位）。</li><li><code>jne</code>：不等于时跳转（zero flag 未置位）。</li></ul></li><li><strong>AT&amp;T 和 Intel 都是一样的写法</strong>：<ul><li>示例：<code>je label</code> 或 <code>jne label</code> 表示根据比较结果进行跳转。</li></ul></li></ul><p>==<strong>注意：后面的汇编代码采用的都是AT&amp;T语法，最明显的区别即为与之前了解的source,destination的位置都是反过来的，先是source，后是destination</strong>==</p><h2 id="函数调用">函数调用</h2><h3 id="案例-11">案例</h3><img src="/2025/01/25/C5/image-20241016105217775.png" class="" title="image-20241016105217775"><img src="/2025/01/25/C5/image-20241016105345480.png" class="" title="image-20241016105345480"><p><strong>1. 栈帧 (Frame) 的概念</strong></p><ul><li><strong>栈帧 (Frame)</strong> 是每个函数调用在栈上分配的一段空间，保存函数的<strong>参数、局部变量、返回地址</strong>等信息。</li><li><strong>栈的分配</strong>：当一个函数（如<code>func</code>）被调用时，程序会在栈上创建一个新的栈帧。每次调用一个新函数，都会<strong>向下扩展</strong>栈。</li><li><strong>调用关系</strong>：<code>main</code>函数调用了<code>func</code>，因此会在栈上为<code>func</code>创建一个新的栈帧。</li></ul><p><strong>2. 寄存器 <code>ebp</code> 与 <code>esp</code> 的含义</strong></p><ol><li><p><strong><code>ebp</code> (Base Pointer)</strong></p><ul><li><strong>基址指针寄存器</strong>，用于存储当前函数栈帧的<strong>基地址</strong>（起始地址）。</li><li><strong>用途</strong>：函数内部的局部变量和参数的地址都是相对于<code>ebp</code>计算的，这样在函数执行过程中可以轻松找到这些变量的位置。</li><li>在函数调用时，**原调用者的<code>ebp</code>**也会被保存到当前栈帧，以便函数返回时恢复调用者的状态。</li></ul></li><li><p><strong><code>esp</code> (Stack Pointer)</strong></p><ul><li><strong>栈顶指针寄存器</strong>，指向<strong>当前栈的顶端</strong>。栈是<strong>向下生长</strong>的，因此每次压栈时<code>esp</code>会减少，而出栈时<code>esp</code>会增加。</li><li><strong>用途</strong>：<code>esp</code>用于管理动态内存分配，确保数据按顺序进栈出栈。</li></ul></li></ol><p><strong>3. 栈的结构与增长方向</strong></p><ul><li><strong>栈的增长方向</strong>：从 <strong>高地址向低地址</strong> 增长，如图中的红色箭头所示（<code>High</code> 到 <code>Low</code>）。</li><li>栈中的每一层栈帧表示一个函数的调用：<ul><li><strong>上层</strong>（高地址）：代表调用者（<code>main</code>）。</li><li><strong>下层</strong>（低地址）：代表被调用函数（<code>func</code>）。</li></ul></li></ul><p><strong>4. 函数调用时的栈管理过程</strong></p><ol><li><p><strong>main() 调用 func() 的过程</strong>：</p><ul><li>创建<code>func</code>的栈帧，并将调用者<code>main</code>的<code>ebp</code>存入<code>func</code>的栈帧中。</li><li><code>ebp</code>更新为<code>func</code>栈帧的基地址，用于定位<code>func</code>内部的局部变量和参数。</li><li><code>esp</code>指向<code>func</code>的栈帧顶端。</li></ul></li><li><p><strong>函数返回时</strong>：</p><ul><li>弹出<code>func</code>的栈帧，恢复<code>main</code>的<code>ebp</code>和<code>esp</code>。</li><li>控制权返回到<code>main</code>函数继续执行。</li></ul></li></ol><p><strong>5. 为什么需要使用 <code>ebp</code> 和 <code>esp</code>？</strong></p><ul><li>使用**<code>ebp</code><strong>，程序在执行函数内部时可以通过</strong>固定的基址指针**访问局部变量和参数。即使<code>esp</code>动态变化，<code>ebp</code>可以保持稳定，方便计算偏移量。</li><li>使用**<code>esp</code>**来管理栈顶，确保内存的动态分配和释放。</li></ul><p><strong>6. 函数调用的成本 (COST)</strong></p><ol><li><p><strong>栈帧的创建成本</strong>：</p><ul><li>每次调用新函数都会在栈上创建一个新的栈帧，并存储调用者的<code>ebp</code>。这个过程会带来一定的开销，尤其是在深度递归时。</li></ul></li><li><p><strong>栈帧的销毁成本</strong>：</p><ul><li>函数返回时，需要弹出栈帧并恢复调用者的寄存器状态，这也会带来开销。</li></ul></li></ol><h3 id="案例——汇编">案例——汇编</h3><img src="/2025/01/25/C5/image-20241016105440953.png" class="" title="image-20241016105440953"><ol><li><strong><code>fact</code> 函数的详细汇编逻辑</strong></li></ol><p><strong>C++代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fact</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n * <span class="built_in">fact</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>汇编代码逐行解析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">R1 = M[SP + 4];        // 1. 从栈中读取参数 n 到 R1 寄存器</span><br><span class="line">JNE R1, 0, PC + 12;    // 2. 如果 n != 0，跳转到 PC + 12 指令</span><br><span class="line">RV = 1;                // 3. 返回值 RV 设为 1（n == 0 时）</span><br><span class="line">RET;                   // 4. 返回上层调用</span><br><span class="line"></span><br><span class="line">R1 = M[SP + 4];        // 5. 再次加载参数 n（确保递归过程数据一致）</span><br><span class="line">R1 = R1 - 1;           // 6. 计算 n - 1</span><br><span class="line">SP = SP - 4;           // 7. 为新参数分配栈空间</span><br><span class="line">M[SP] = R1;            // 8. 将 n-1 压入栈</span><br><span class="line">CALL &lt;fact&gt;;           // 9. 递归调用 fact(n - 1)</span><br><span class="line">SP = SP + 4;           // 10. 恢复栈指针</span><br><span class="line">R1 = M[SP];            // 11. 从栈中取出返回值</span><br><span class="line">RV = R1 * RV;          // 12. 计算 n * fact(n-1)</span><br><span class="line">RET;                   // 13. 返回结果</span><br></pre></td></tr></table></figure><ol><li><p><strong><code>R1 = M[SP + 4];</code></strong></p><ul><li><strong>为什么再次加载参数 n？</strong><ul><li>每次递归调用都在新的栈帧中执行。即使我们已经在上层调用中加载了 <code>n</code>，当前递归实例中需要重新加载，以确保数据的正确性。此时的 <code>SP</code> 已经是当前递归调用的栈帧指针。</li></ul></li></ul></li><li><p><strong><code>foo</code> 函数 - 栈帧和局部变量管理</strong></p></li></ol><p><strong>C++代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">swap</span>(&amp;x, &amp;y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>汇编代码逐行解析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SP = SP - 8;       // 1. 为局部变量 x 和 y 分配 8 字节的栈空间</span><br><span class="line">M[SP + 4] = 1;     // 2. 将 x = 1 存入栈</span><br><span class="line">M[SP] = 2;         // 3. 将 y = 2 存入栈</span><br><span class="line">R1 = SP;           // 4. 记录当前栈指针位置</span><br><span class="line">R2 = SP + 4;       // 5. 获取 x 的地址</span><br><span class="line">SP = SP - 8;       // 6. 为 swap 函数调用准备栈空间</span><br><span class="line">M[SP + 4] = R1;    // 7. 将 y 的地址存入栈</span><br><span class="line">M[SP] = R2;        // 8. 将 x 的地址存入栈</span><br><span class="line">CALL &lt;swap&gt;;       // 9. 调用 swap 函数</span><br><span class="line">SP = SP + 8;       // 10. 恢复栈指针</span><br><span class="line">RET;               // 11. 返回</span><br></pre></td></tr></table></figure><ol start="3"><li><strong><code>swap</code> 函数 - 指针交换操作</strong></li></ol><p><strong>C++代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> *ap, <span class="type">int</span> *bp)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *ap;</span><br><span class="line">    *ap = *bp;</span><br><span class="line">    *bp = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>汇编代码逐行解析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SP = SP - 4;        // 1. 为临时变量 temp 分配 4 字节栈空间</span><br><span class="line">R1 = M[SP + 8];     // 2. 加载 ap（x 的地址）</span><br><span class="line">R2 = M[R1];         // 3. 加载 *ap（x 的值）</span><br><span class="line">M[SP] = R2;         // 4. 将 x 的值存入 temp</span><br><span class="line">R1 = M[SP + 12];    // 5. 加载 bp（y 的地址）</span><br><span class="line">R2 = M[R1];         // 6. 加载 *bp（y 的值）</span><br><span class="line">M[M[SP + 8]] = R2;  // 7. 将 y 的值赋给 x</span><br><span class="line">R2 = M[SP];         // 8. 从 temp 中加载原 x 的值</span><br><span class="line">M[M[SP + 12]] = R2; // 9. 将原 x 的值赋给 y</span><br><span class="line">SP = SP + 4;        // 10. 恢复栈指针</span><br><span class="line">RET;                // 11. 返回</span><br></pre></td></tr></table></figure><h2 id="参数传递机制">参数传递机制</h2><h3 id="案例1传参数">案例1传参数</h3><img src="/2025/01/25/C5/image-20241016113551482.png" class="" title="image-20241016113551482"><ol><li><strong>Pass by Value (值传递)</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> r = a + b;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    r = <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><strong>值传递（Pass by Value）</strong>：<ul><li>在调用函数时，传递的是<strong>参数的副本</strong>。这意味着函数接收到的不是原始变量，而是变量的拷贝。</li><li><strong><code>func</code> 函数中的变量 <code>a</code> 和 <code>b</code></strong> 是实参 <code>1</code> 和 <code>2</code> 的副本。对它们的任何修改不会影响原始变量。</li></ul></li></ul><p><strong>调用过程的内存操作：</strong></p><ol><li><p><strong>函数调用</strong>时，将 <code>1</code> 和 <code>2</code> 作为副本传递给 <code>func</code>。</p></li><li><p><strong>栈上开辟空间</strong>保存 <code>a</code> 和 <code>b</code> 这两个拷贝的值。</p></li><li><p><strong>函数体执行</strong>：<code>int r = a + b;</code> 计算结果为 <code>3</code>，并返回给 <code>main</code> 函数。</p></li><li><p><strong><code>main</code> 函数中的 <code>r</code></strong> 被赋值为 <code>3</code>。</p></li><li><p><strong>Pass by Reference (引用传递)</strong></p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;a)</span> </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">func</span>(r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><strong>引用传递（Pass by Reference）</strong>：<ul><li>在调用函数时，传递的是<strong>变量的引用</strong>，即指向原始变量的别名。</li><li>在 <strong><code>func</code> 函数中</strong>，<code>a</code> 是变量 <code>r</code> 的引用，因此对 <code>a</code> 的任何修改都会直接作用于原变量 <code>r</code>。</li></ul></li></ul><p><strong>调用过程的内存操作：</strong></p><ol><li><strong>调用 <code>func(r)</code> 时</strong>，<code>r</code> 的地址会被传递给函数 <code>func</code>。</li><li><strong><code>func</code> 函数中的参数 <code>a</code></strong> 是对 <code>r</code> 的引用，<strong><code>a</code> 和 <code>r</code> 实际上指向同一块内存地址</strong>。</li><li><strong>函数体执行</strong>：<code>a = 1;</code> 将 <code>r</code> 的值修改为 <code>1</code>。</li></ol><p><strong>两种传递方式的区别</strong></p><table><thead><tr><th><strong>特性</strong></th><th><strong>Pass by Value</strong></th><th><strong>Pass by Reference</strong></th></tr></thead><tbody><tr><td><strong>传递内容</strong></td><td>参数的副本</td><td>参数的引用（别名）</td></tr><tr><td><strong>影响原变量</strong></td><td>不会影响</td><td>会直接影响原变量</td></tr><tr><td><strong>适用场景</strong></td><td>数据量小且无需修改的情况</td><td>需要修改原始数据的情况</td></tr><tr><td><strong>内存消耗</strong></td><td>额外分配副本的空间</td><td>无需额外空间，使用<strong>变量原地址</strong></td></tr></tbody></table><h3 id="案例——汇编-2">案例——汇编</h3><img src="/2025/01/25/C5/image-20241016114019768.png" class="" title="image-20241016114019768"><img src="/2025/01/25/C5/image-20241016114602919.png" class="" title="image-20241016114602919"><ul><li>建议看PPT动画</li></ul><p><strong>1. 代码片段分析</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    r = <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> r = a + b;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 汇编指令和栈布局详解</strong></p><p><strong>函数调用前 (main 中)</strong></p><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td><strong>1</strong>. <code>sub $0x8, esp</code></td><td>在栈上为 <code>main</code> 中的局部变量预留 8 字节空间。</td></tr><tr><td><strong>2</strong>. <code>push $0x2</code></td><td>将参数 <code>2</code> 压栈（为 <code>b</code>）。</td></tr><tr><td><strong>3</strong>. <code>push $0x1</code></td><td>将参数 <code>1</code> 压栈（为 <code>a</code>）。</td></tr><tr><td><strong>4</strong>. <code>call _Z4funcii</code></td><td>调用 <code>func</code> 函数，保存返回地址到栈，并跳转到 <code>_Z4funcii</code>。</td></tr></tbody></table><ul><li><strong>解释</strong>：<br>在 <code>call</code> 指令时，返回地址会被压入栈中，这样函数返回后可以知道跳回哪里继续执行。</li></ul><hr><p><strong>进入 func 函数</strong></p><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td><strong>12</strong>. <code>push ebp</code></td><td>保存 <code>main</code> 的 <code>ebp</code>，用于返回时恢复。</td></tr><tr><td><strong>13</strong>. <code>mov esp, ebp</code></td><td>将当前栈顶指针保存到 <code>ebp</code>，作为当前帧的基地址。</td></tr><tr><td><strong>14</strong>. <code>sub $0x10, esp</code></td><td>在栈上为 <code>func</code> 中的局部变量分配 16 字节。</td></tr><tr><td><strong>15</strong>. <code>mov 0x8(ebp), edx</code></td><td>从栈帧中加载参数 <code>a</code>。</td></tr><tr><td><strong>16</strong>. <code>mov 0xc(ebp), eax</code></td><td>从栈帧中加载参数 <code>b</code>。</td></tr><tr><td><strong>17</strong>. <code>add edx, eax</code></td><td>执行 <code>a + b</code>，结果存入 <code>eax</code>。</td></tr><tr><td><strong>18</strong>. <code>mov eax, -0x4(ebp)</code></td><td>将计算结果存入局部变量 <code>r</code>。</td></tr><tr><td><strong>19</strong>. <code>mov -0x4(ebp), eax</code></td><td>准备将 <code>r</code> 返回给 <code>main</code>。</td></tr></tbody></table><ul><li><strong>解释</strong>：<ul><li>在函数的栈帧中，<code>ebp</code> 保存基址，<code>esp</code> 是栈顶指针。</li><li>参数 <code>a</code> 和 <code>b</code> 通过 <code>ebp</code> 的偏移量访问。</li></ul></li></ul><hr><p><strong>返回 main 函数</strong></p><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td><strong>20</strong>. <code>leave</code></td><td>恢复 <code>esp</code> 和 <code>ebp</code>，清理栈帧。</td></tr><tr><td><strong>21</strong>. <code>ret</code></td><td>从栈中弹出返回地址，并跳回 <code>main</code>。</td></tr></tbody></table><p><strong>3. 栈的布局</strong></p><ul><li><p><strong>main 函数的栈帧</strong>：</p><ul><li>局部变量 <code>r</code> 和参数通过栈分配，并存储在 <code>ebp</code> 的不同偏移量处。</li></ul></li><li><p><strong>func 函数的栈帧</strong>：</p><ul><li>栈中存储了 <code>a</code> 和 <code>b</code>，以及计算的局部变量 <code>r</code>。</li></ul></li></ul><hr><p><strong>4. 栈帧管理与返回地址</strong></p><ul><li><p><strong>为什么使用 <code>ebp</code></strong>：<br><code>ebp</code> 用于保存函数调用时的栈帧基地址，方便访问参数和局部变量。</p></li><li><p><strong>返回地址</strong>：<br><code>call</code> 指令会将返回地址压入栈中。<code>ret</code> 指令会从栈中弹出该地址，并跳回调用函数。</p></li></ul><h3 id="案例2传引用">案例2传引用</h3><img src="/2025/01/25/C5/image-20241016114625375.png" class="" title="image-20241016114625375"><img src="/2025/01/25/C5/image-20241016114705274.png" class="" title="image-20241016114705274"><p><strong>1. 代码分析</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">func</span>(r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;a)</span> </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><p><strong>main 函数</strong>：</p><ul><li>定义了一个整型变量 <code>r</code>，初始化为 <code>0</code>。</li><li>通过引用调用 <code>func</code>，把变量 <code>r</code> 的引用传递给 <code>func</code>。</li><li>运行后 <code>r</code> 的值将被修改为 <code>1</code>。</li></ul></li><li><p><strong>func 函数</strong>：</p><ul><li>接受一个整型变量的引用，并将其值设置为 <code>1</code>。</li></ul></li></ul><p><strong>2. 汇编代码与指令分析</strong></p><p><strong>函数调用前（main 函数中执行的指令）：</strong></p><table><thead><tr><th>汇编指令</th><th>作用</th></tr></thead><tbody><tr><td><strong>1</strong>. <code>sub $0xc, esp</code></td><td>为 <code>main</code> 的局部变量分配 12 字节的栈空间。</td></tr><tr><td><strong>2</strong>. <code>lea -0xc(ebp), eax</code></td><td>将变量 <code>r</code> 的地址加载到 <code>eax</code> 中。</td></tr><tr><td><strong>3</strong>. <code>push eax</code></td><td>将变量 <code>r</code> 的地址压入栈，作为引用传递给 <code>func</code>。</td></tr><tr><td><strong>4</strong>. <code>call _Z4funcRi</code></td><td>调用 <code>func</code>，并压入返回地址。</td></tr><tr><td><strong>5</strong>. <code>add $0x10, esp</code></td><td>清理栈，为参数回收 16 字节的空间。</td></tr></tbody></table><ul><li><strong>解释</strong>：<ul><li><strong><code>lea -0xc(ebp), eax</code></strong>：<code>lea</code> 指令用于计算 <code>r</code> 的地址（相对于 <code>ebp</code>）。这是引用传递的关键，因为 <code>func</code> 需要直接操作 <code>r</code> 的地址。</li><li><strong><code>push eax</code></strong>：将变量 <code>r</code> 的地址压栈，这保证了 <code>func</code> 能够直接访问并修改 <code>r</code>。</li></ul></li></ul><p><strong>进入 func 函数的指令：</strong></p><table><thead><tr><th>汇编指令</th><th>作用</th></tr></thead><tbody><tr><td><strong>11</strong>. <code>push ebp</code></td><td>保存上一层栈帧的基地址（<code>ebp</code>）。</td></tr><tr><td><strong>12</strong>. <code>mov esp, ebp</code></td><td>将当前栈顶保存到 <code>ebp</code>，作为当前函数的基地址。</td></tr><tr><td><strong>13</strong>. <code>mov 0x8(ebp), eax</code></td><td>从栈帧中加载参数 <code>a</code> 的地址（即 <code>r</code> 的地址）。</td></tr><tr><td><strong>14</strong>. <code>mov $0x1, (eax)</code></td><td>将 <code>1</code> 存入 <code>eax</code> 指向的地址，也就是修改了 <code>r</code> 的值为 <code>1</code>。</td></tr><tr><td><strong>15</strong>. <code>nop</code></td><td>空操作（可能用于对齐）。</td></tr><tr><td><strong>16</strong>. <code>pop ebp</code></td><td>恢复之前的栈帧基地址。</td></tr><tr><td><strong>17</strong>. <code>ret</code></td><td>从栈中弹出返回地址，并跳回 <code>main</code> 函数。</td></tr></tbody></table><ul><li><strong>解释</strong>：<ul><li><strong><code>mov 0x8(ebp), eax</code></strong>：这一步获取了引用传递的参数的地址。</li><li><strong><code>mov $0x1, (eax)</code></strong>：将 <code>1</code> 赋值给 <code>eax</code> 指向的地址，即修改了变量 <code>r</code> 的值。</li></ul></li></ul><p><strong>3. 栈布局分析</strong></p><ol><li><p><strong>调用前的栈布局（main 的栈帧）：</strong></p><ul><li>栈帧中存储了局部变量 <code>r</code> 及其地址（相对于 <code>ebp</code> 的偏移量为 -0xc）。</li><li><code>push</code> 后，将 <code>r</code> 的地址压入栈，供 <code>func</code> 使用。</li></ul></li><li><p><strong>进入 func 后的栈帧：</strong></p><ul><li>保存了 <code>ebp</code>，并将 <code>esp</code> 移动到 <code>ebp</code>，形成 <code>func</code> 的新栈帧。</li><li>参数 <code>r</code> 的地址通过 <code>0x8(ebp)</code> 访问。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++高级程序设计笔记（C6）</title>
      <link href="/2025/01/25/C6/"/>
      <url>/2025/01/25/C6/</url>
      
        <content type="html"><![CDATA[<h1>C6</h1><h2 id="运行时环境">运行时环境</h2><h3 id="示例">示例</h3><img src="/2025/01/25/C6/image-20241025183945501.png" class="" title="image-20241025183945501"><p>该PPT列出了几种常见的 <strong>函数调用约定</strong>，每一种调用约定决定了函数的参数传递方式、调用者与被调用者之间如何管理堆栈、以及如何清理参数等。</p><ol><li><strong><code>__cdecl</code>（C declaration）</strong></li></ol><ul><li><p><strong>特点</strong>：</p><ul><li>参数从右向左压栈。</li><li>调用者负责清理堆栈。</li><li>支持可变参数（如 <code>printf</code>、<code>scanf</code> 等）。</li></ul></li><li><p><strong>典型使用场景</strong>：</p><ul><li>是C语言的默认调用约定，常用于编写跨平台代码，特别是在 Windows 和 Linux 环境下。</li></ul></li><li><p><strong>堆栈清理方式</strong>：</p><ul><li>调用函数后，调用者通过调整 <code>esp</code> 寄存器来清理堆栈上的参数。</li></ul></li><li><p><strong>例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong><code>__stdcall</code>（Standard Call）</strong></li></ol><ul><li><p><strong>特点</strong>：</p><ul><li>参数从右向左压栈。</li><li>被调用者负责清理堆栈。</li><li>不支持可变参数。</li></ul></li><li><p><strong>典型使用场景</strong>：</p><ul><li><code>__stdcall</code> 是 Windows API 中大多数函数的默认调用约定。</li><li>在 Windows 操作系统中调用 <code>Win32</code> API 函数时经常使用这种调用方式。</li></ul></li><li><p><strong>堆栈清理方式</strong>：</p><ul><li>被调用函数负责清理堆栈参数，调用者无需再做额外的清理操作。</li></ul></li><li><p><strong>例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __stdcall <span class="title function_">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><strong><code>__fastcall</code>（Fast Call）</strong></li></ol><ul><li><p><strong>特点</strong>：</p><ul><li>部分参数通过寄存器传递，而不是通过堆栈（通常是 <code>ecx</code> 和 <code>edx</code> 寄存器先用于传递前两个参数，剩余参数则依然从右向左压栈）。</li><li>被调用者负责清理堆栈。</li><li>不支持可变参数。</li></ul></li><li><p><strong>典型使用场景</strong>：</p><ul><li><code>__fastcall</code> 主要用于提升函数调用的效率，尤其是在调用频繁或开销较大的函数时减少堆栈操作的负担。</li></ul></li><li><p><strong>堆栈清理方式</strong>：</p><ul><li>被调用函数负责清理堆栈。</li></ul></li><li><p><strong>例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li><strong><code>__thiscall</code>（This Call）</strong></li></ol><ul><li><p><strong>特点</strong>：</p><ul><li>特别用于 C++ 类成员函数的调用。</li><li><code>this</code> 指针通过 <code>ecx</code> 寄存器传递。</li><li>其他参数从右向左压栈。</li><li>被调用者负责清理堆栈。</li></ul></li><li><p><strong>典型使用场景</strong>：</p><ul><li>仅在 C++ 的类成员函数调用中使用，主要处理 <code>this</code> 指针。</li></ul></li><li><p><strong>堆栈清理方式</strong>：</p><ul><li>被调用函数负责清理堆栈。</li></ul></li><li><p><strong>例子</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> __thiscall <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>总结：</p><p>这几种函数调用约定决定了函数如何传递参数和谁来管理堆栈资源，适用于不同的应用场景。<code>__cdecl</code> 适用于需要支持可变参数的函数，<code>__stdcall</code> 是Windows API的默认调用方式，<code>__fastcall</code> 通过寄存器传递参数以提高效率，而 <code>__thiscall</code> 则是专门为 C++ 的成员函数设计的调用约定。在实际使用中，编译器根据调用约定生成相应的函数调用和堆栈管理代码。</p><h2 id="stdcall">stdcall</h2><h3 id="示例-2">示例</h3><img src="/2025/01/25/C6/image-20241025190606713.png" class="" title="image-20241025190606713"><ol><li><strong><code>main</code> 函数调用栈及汇编代码</strong></li></ol><ul><li><p><strong>第1行 (<code>sub $0x8, esp</code>)</strong>: 减少 <code>esp</code> 寄存器，预留8字节的空间给局部变量。</p><ul><li>栈布局：栈顶减少 8 个字节，为局部变量 <code>r</code> 等分配空间。</li></ul></li><li><p><strong>第2行 (<code>push $0x2</code>)</strong>: 将值 <code>2</code> 压入栈中，作为参数传递给 <code>func</code>。</p><ul><li>栈布局：参数 <code>2</code> 压入栈中。</li></ul></li><li><p><strong>第3行 (<code>push $0x1</code>)</strong>: 将值 <code>1</code> 压入栈中，作为第二个参数传递给 <code>func</code>。</p><ul><li>栈布局：参数 <code>1</code> 压入栈中。</li></ul></li><li><p>==这里从右往左入栈==</p></li><li><p><strong>第4行 (<code>call _Z4funcii</code>)</strong>: 调用 <code>func</code> 函数，这个指令相当于两个操作：</p><ul><li>首先，<code>push eip</code>，将返回地址（即 <code>call</code> 之后的指令地址）压入栈中。</li><li>然后 <code>jmp</code> 跳转到 <code>func</code> 的入口。</li></ul></li><li><p><strong>第5行 (<code>add $0x8, esp</code>)</strong>: 恢复栈指针，将传递给 <code>func</code> 的参数弹出栈。</p><ul><li>栈布局：释放 8 字节栈空间，恢复栈顶。</li></ul></li><li><p><strong>第6行 (<code>mov eax, -0xc(ebp)</code>)</strong>: 将<code>eax</code> 的值存储到 <code>r</code> 中。</p></li></ul><ol start="2"><li><code>func</code> <strong>函数的栈及汇编代码</strong></li></ol><ul><li><p><strong>第12行 (<code>push ebp</code>)</strong>: 将当前的 <code>ebp</code> 压入栈中，以保存上一层调用栈的基地址。</p><ul><li>栈布局：<code>ebp</code> 被压入栈，当前函数可以使用它恢复调用者的上下文。</li></ul></li><li><p><strong>第13行 (<code>mov esp, ebp</code>)</strong>: 将 <code>esp</code> 的值赋给 <code>ebp</code>，以便 <code>ebp</code> 指向当前栈帧的起始位置。</p></li><li><p><strong>第14行 (<code>sub $0x10, esp</code>)</strong>: 为 <code>func</code> 的局部变量预留栈空间。</p></li><li><p><strong>第15行 (<code>mov 0x8(ebp), edx</code>)</strong>: 从 <code>ebp+8</code> 偏移量获取第一个参数 <code>a</code> 的值，并存入 <code>edx</code>。</p></li><li><p><strong>第16行 (<code>mov 0xc(ebp), eax</code>)</strong>: 从 <code>ebp+12</code> 偏移量获取第二个参数 <code>b</code> 的值，并存入 <code>eax</code>。</p></li><li><p><strong>第17行 (<code>add edx, eax</code>)</strong>: 将两个参数相加，结果存储在 <code>eax</code> 中。</p></li><li><p><strong>第18行 (<code>mov eax, -0x4(ebp)</code>)</strong>: 将相加结果存储到 <code>func</code> 栈帧的 <code>r</code> 变量中。</p></li><li><p><strong>第19行 (<code>mov -0x4(ebp), eax</code>)</strong>: 将 <code>r</code> 的值再次加载到 <code>eax</code> 中，准备返回。</p></li><li><p><strong>第20行 (<code>leave</code>)</strong>: 恢复调用者的栈帧，执行 <code>mov esp, ebp</code> 和 <code>pop ebp</code>，恢复栈和基址。</p></li><li><p><strong>第21行 (<code>ret</code>)</strong>: 从栈中弹出返回地址并跳转到调用点。</p></li></ul><ol start="3"><li><strong>栈的布局</strong></li></ol><p>右侧的栈图展示了 <code>main</code> 和 <code>func</code> 函数在调用时栈的变化：</p><ul><li>在调用 <code>func</code> 之前，<code>main</code> 函数的局部变量 <code>r</code>、传递给 <code>func</code> 的参数 <code>1</code> 和 <code>2</code> 依次被压入栈中。</li><li>调用 <code>func</code> 之后，返回地址 <code>ret_addr</code> 和 <code>ebp_main</code>（用于保存调用者 <code>main</code> 的栈帧基址）被压入栈中。</li><li><code>func</code> 函数执行完毕后，返回值 <code>r=3</code> 被存储在栈帧中，并将其值返回给 <code>main</code>。</li></ul><ol start="4"><li><strong>关于 <code>stdcall</code> 调用约定</strong></li></ol><p>此PPT中的 <code>__attribute__((stdcall))</code> 强调了使用 <code>stdcall</code> 调用约定，它的特点是：</p><ul><li><p>函数参数从右向左压栈。</p></li><li><p>被调用者（即 <code>func</code>）负责清理参数，这也是 <code>ret $0x8</code> 的作用，清理 8 字节参数。</p></li><li><p><code>ret $0x8</code> 的作用是：</p><ul><li><strong>从栈中弹出返回地址</strong>：通常的 <code>ret</code> 指令会从栈中弹出返回地址并跳转到该地址，这是函数返回的标准操作。</li><li><strong>清理参数</strong>：<code>ret $0x8</code> 的 <code>$0x8</code> 表示在返回前<strong>清理栈中的 8 个字节，也就是说调用该函数时，函数传递的参数占用了栈中的 8 个字节</strong>。在返回之前，<code>ret $0x8</code> 会将栈指针 <code>esp</code> 增加 8（移除这 8 个字节的参数），然后再将控制权交还给调用者。</li></ul></li></ul><h2 id="可变参数">可变参数</h2><h3 id="示例-3">示例</h3><img src="/2025/01/25/C6/image-20241025192028716.png" class="" title="image-20241025192028716"><p>这张PPT展示了C++中的可变参数函数（variadic functions），即函数可以接收可变数量的参数，常用于实现类似<code>printf</code>这样的函数。</p><p><strong>上半部分（宏定义和内部实现）</strong></p><ul><li><p><strong><code>typedef char *va_list;</code></strong>: 定义了<code>va_list</code>类型，表示可变参数列表的指针，用于访问函数中的可变参数。</p></li><li><p><strong><code>#define _INTSIZEOF(x)</code></strong>: 这个宏计算一个类型的大小，并将其调整为<code>sizeof(int)</code>的倍数。通过这个宏确保了参数的对齐，特别是在处理参数大小不同的数据类型时非常重要。</p><ul><li>公式 <code>(sizeof(x) + sizeof(int) - 1) &amp; ~(sizeof(int) - 1)</code> 的作用是：<ul><li>先加上<code>sizeof(int) - 1</code>确保<code>sizeof(x)</code>向上取整为<code>sizeof(int)</code>的倍数；</li><li>通过与操作符按位取整，确保计算出的结果是<code>sizeof(int)</code>的倍数。</li></ul></li><li>具体来说，即先用+sizeof(int)-1模拟向上取整（作二进制考虑，sizeof(int)-1即为11，最大即3，二进制11，和为110），而后与111111100进行&amp;操作，即把最后两位清空为0，即为对应的向上取整后<strong>4的倍数</strong></li></ul></li><li><p><code>#define va_start(ap, v) (ap = (va_list)&amp;v + _INTSIZEOF(v))</code></p><p>这个宏用于初始化 <code>va_list</code> 类型的变量 <code>ap</code>，使其指向第一个可变参数的地址。</p><ul><li><code>ap</code>：是函数中的 <code>va_list</code> 类型变量，表示当前参数列表的指针。</li><li><code>v</code>：是可变参数列表之前的最后一个已知参数。</li><li><code>(va_list)&amp;v</code>：取变量 <code>v</code> 的地址，然后将其强制转换为 <code>va_list</code> 类型。由于 <code>va_list</code> 是指针类型，所以它指向 <code>v</code> 的内存地址。</li><li><code>_INTSIZEOF(v)</code>：计算 <code>v</code> 的对齐大小，即它在栈中的占用空间。</li><li><code>ap = (va_list)&amp;v + _INTSIZEOF(v)</code>：将 <code>ap</code> 设置为 <code>v</code> 的地址加上 <code>v</code> 所占用的对齐大小。这样 <code>ap</code> 就指向第一个可变参数的地址了。</li></ul></li><li><p><code>#define va_arg(ap, t) (*(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)))</code></p><p>这个宏用于获取下一个可变参数的值，并将 <code>va_list</code>（即 <code>ap</code>）指向下一个参数的位置。</p><ul><li><code>ap</code>：指向当前可变参数的指针。</li><li><code>t</code>：表示下一个参数的类型。</li><li><code>ap += _INTSIZEOF(t)</code>：首先，将 <code>ap</code> 增加 <code>t</code> 类型的对齐大小，指向下一个参数的位置。</li><li><code>- _INTSIZEOF(t)</code>：然后将指针回退一个 <code>t</code> 类型的大小，得到当前参数的起始地址。</li><li><code>*(t *)(...)</code>：将 <code>ap</code> 当前位置的内存解释为类型 <code>t</code>，并通过解引用 <code>*</code> 获取这个参数的值。</li></ul></li><li><p><code>#define va_end(ap) (ap = (va_list)0)</code></p><p>这个宏用于结束可变参数的访问，将 <code>va_list</code> 设置为 <code>0</code>，表示不再访问可变参数。</p><ul><li><code>ap = (va_list)0</code>：将 <code>ap</code> 设置为 <code>0</code>，即释放对可变参数列表的访问。</li></ul></li></ul><p><strong>下半部分（代码示例）</strong></p><ol><li><p><strong><code>void MyPrint(char *s, ...)</code></strong>:</p><ul><li>定义了一个可变参数函数<code>MyPrint</code>，它可以接收一个字符串和任意数量的后续参数。</li><li><code>va_list marker; va_start(marker, s);</code> 初始化可变参数列表，<code>marker</code>将用于访问这些参数。</li><li>通过遍历字符串<code>s</code>，逐个检查字符。如果字符是<code>%</code>，则根据接下来的字符来决定如何处理可变参数。<ul><li>例如，如果是<code>%f</code>，那么使用<code>va_arg(marker, double)</code>读取一个<code>double</code>类型的参数。</li><li>如果是<code>%d</code>，读取一个<code>int</code>类型的参数。</li><li>如果是<code>%c</code>，读取一个<code>char</code>类型的参数。</li></ul></li></ul></li><li><p><strong>循环和<code>switch</code>语句</strong>:</p><ul><li>当检测到<code>%</code>符号时，会进入<code>switch</code>，根据紧随的字符决定如何处理。</li><li><code>%f</code> 会输出浮点数， <code>%d</code> 会输出整数， <code>%c</code> 会输出字符。</li></ul></li><li><p><strong><code>va_end(marker)</code></strong>: 在函数的最后，通过<code>va_end</code>结束可变参数处理。</p></li></ol><p><strong><code>main()</code>函数中的例子：</strong></p><p>在<code>main()</code>中调用<code>MyPrint</code>函数，传递的参数是一个字符串和具体的参数值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MyPrint</span>(<span class="string">&quot;double: %f integer: %d string: %c&quot;</span>, <span class="number">1.1</span>, <span class="number">100</span>, <span class="string">&#x27;A&#x27;</span>);</span><br></pre></td></tr></table></figure><p>该函数将会根据格式化字符串依次输出浮点数、整数和字符。</p><p><strong>格式化攻击（攻击风险）：</strong></p><p>这里提到了<strong>格式化串攻击</strong>（format string attack），这是一种常见的漏洞攻击手段。通过操纵格式化字符串，攻击者可以导致程序意外的行为，甚至访问未授权的内存空间。特别是当使用不受控制的用户输入作为格式化串时，可能会导致安全问题。</p><p><strong>右上角公式：</strong></p><p>PPT 右上角的公式部分展示了三种不同的用于对齐整数的表达式，目的是<strong>将 <code>x</code> 向上对齐到 <code>n</code> 的倍数</strong>。</p><ol><li><code>[(x + n - 1) / n] * n</code></li></ol><p>这是一个典型的对齐操作，旨在将 <code>x</code> 向上对齐到 <code>n</code> 的倍数。</p><ul><li><code>x + n - 1</code>：通过加上 <code>n - 1</code>，确保任何不满足对齐条件的数都能被&quot;进位&quot;到下一个倍数。</li><li><code>(x + n - 1) / n</code>：将 <code>x + n - 1</code> 除以 <code>n</code>，表示 <code>x</code> 已经接近的那个 <code>n</code> 的倍数。</li><li><code>[...]*n</code>：最终将结果乘以 <code>n</code>，从而得到对齐后的值。</li></ul><ol start="2"><li><code>((x + n - 1) / n) * n</code></li></ol><p>这是上面公式的另一种写法，表达的是相同的逻辑：将 <code>x</code> 向上对齐到 <code>n</code> 的倍数。</p><ul><li><code>x + n - 1</code>：如上，加上 <code>n - 1</code> 以确保非倍数的数被向上取整。</li><li><code>(x + n - 1) / n</code>：求出除以 <code>n</code> 后的整数部分。</li><li><code>(...)*n</code>：最后乘以 <code>n</code> 得出结果。</li></ul><p>这个表达式的作用与第一个表达式完全相同。</p><ol start="3"><li><code>(x + n - 1) &amp; ~(n - 1)</code></li></ol><p>这个表达式使用位运算来实现对齐操作，它的效率更高，尤其是在底层的二进制系统中进行位运算时。</p><ul><li><code>x + n - 1</code>：同样，通过加上 <code>n - 1</code>，确保 <code>x</code> 能被向上对齐。</li><li><code>n - 1</code>：<code>n</code> 是对齐的倍数，因此 <code>n - 1</code> 会创建一个掩码，例如，如果 <code>n = 4</code>，则 <code>n - 1 = 3</code>，即 <code>0000...0011</code>。</li><li><code>~(n - 1)</code>：按位取反操作将掩码的低位置为 0，而高位为 1。例如，<code>~(3)</code> 会得到 <code>...11111100</code>。</li><li><code>&amp; ~(n - 1)</code>：对 <code>x + n - 1</code> 进行按位与操作，使得低位的未对齐部分被清零，高位保持不变，从而得到对齐后的值。</li></ul><p><strong>示例</strong>：</p><p>假设 <code>x = 7</code>，<code>n = 4</code>，即希望将 <code>7</code> 向上对齐到 <code>4</code> 的倍数：</p><ul><li><code>x + n - 1 = 7 + 4 - 1 = 10</code></li><li><code>n - 1 = 3</code>，二进制表示为 <code>0000...0011</code></li><li><code>~(n - 1) = ...11111100</code></li><li><code>10 &amp; ~3 = 10 &amp; 252 = 8</code> （二进制：<code>1010 &amp; 11111100 = 1000</code>）</li></ul><p>最终结果是 <code>8</code>，同样是将 <code>7</code> 向上对齐到 8。</p><p><strong>总结：</strong></p><ul><li>前两个公式使用的是四则运算的方式进行对齐，核心是通过加法和除法来确保 <code>x</code> 被向上对齐到 <code>n</code> 的倍数。</li><li>第三个公式使用位运算来实现对齐，通过掩码操作来清除未对齐的低位，从而更高效地实现对齐，<strong>尤其适合 <code>n</code> 是 2 的幂的情况。</strong></li></ul><p>这三个表达式的核心思想是相同的，都是为了确保 <code>x</code> 被向上对齐到 <code>n</code> 的倍数，但第三个表达式在硬件层面的实现中效率更高。</p><h2 id="fastcall">fastcall</h2><h3 id="示例-4">示例</h3><img src="/2025/01/25/C6/image-20241025194415653.png" class="" title="image-20241025194415653"><img src="/2025/01/25/C6/image-20241025194830206.png" class="" title="image-20241025194830206"><p>这张PPT展示了使用 <code>__fastcall</code> 调用约定下，函数参数如何通过寄存器传递，函数栈帧的构建，以及函数返回值的处理。它结合了C语言代码和对应的汇编指令。我们详细解释其中的每个细节：</p><ol><li>C代码</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    r = <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((fastcall))</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>func()</code> 使用 <code>__fastcall</code> 调用约定，它的参数 <code>a</code> 和 <code>b</code> 会<strong>通过寄存器传递</strong>，而不是通过堆栈传递（通常参数是通过堆栈传递的）。</li></ul><ol start="2"><li><strong>函数调用和栈帧分析</strong></li></ol><p><code>main</code> 函数部分：</p><ol><li><p><code>mov $0x2, edx</code></p><ul><li>将常量 <code>2</code> 赋值给寄存器 <code>edx</code>。这是参数 <code>b</code> 的值。</li></ul></li><li><p><code>mov $0x1, ecx</code></p><ul><li>将常量 <code>1</code> 赋值给寄存器 <code>ecx</code>。这是参数 <code>a</code> 的值。</li></ul></li><li><p><code>call _Z4funcii</code></p><ul><li>调用函数 <code>func</code>，跳转到 <code>_Z4funcii</code> 的地址。这条指令将 <code>eip</code>（指令指针）压入堆栈，并跳转到 <code>func</code> 的入口。</li></ul></li><li><p><code>mov eax, -0xc(ebp)</code></p><ul><li>将 <code>eax</code> 寄存器（<code>func</code> 函数返回的值）的值存储到 <code>main</code> 函数的栈帧中的局部变量 <code>r</code>。这里 <code>-0xc(ebp)</code> 是 <code>r</code> 在 <code>main</code> 函数栈中的位置。</li></ul></li></ol><p><code>func</code> 函数部分：</p><ol start="11"><li><code>push ebp</code></li></ol><ul><li>保存 <code>ebp</code>（当前栈帧的基地址），准备为新函数建立栈帧。</li></ul><ol start="12"><li><code>mov esp, ebp</code></li></ol><ul><li>设置 <code>ebp</code> 为当前 <code>esp</code>，从而创建新的栈帧。<code>ebp</code> 用来固定访问参数和局部变量的基地址。</li></ul><ol start="13"><li><code>sub $0x18, esp</code></li></ol><ul><li>在栈上为局部变量分配空间。这里是分配了 <code>0x18</code> 字节。</li></ul><ol start="14"><li><code>mov ecx, -0x14(ebp)</code></li></ol><ul><li>将寄存器 <code>ecx</code>（对应 <code>a</code> 的值）保存到 <code>func</code> 函数的栈中，位置为 <code>-0x14(ebp)</code>。</li></ul><ol start="15"><li><code>mov edx, -0x18(ebp)</code></li></ol><ul><li>将寄存器 <code>edx</code>（对应 <code>b</code> 的值）保存到 <code>func</code> 函数的栈中，位置为 <code>-0x18(ebp)</code>。</li></ul><ol start="16"><li><code>mov -0x14(ebp), edx</code></li></ol><ul><li>将 <code>a</code> 的值从栈中取回到 <code>edx</code> 寄存器。</li></ul><ol start="17"><li><code>mov -0x18(ebp), eax</code></li></ol><ul><li>将 <code>b</code> 的值从栈中取回到 <code>eax</code> 寄存器。</li></ul><ol start="18"><li><code>add edx, eax</code></li></ol><ul><li>执行 <code>a + b</code> 的运算，将结果存入 <code>eax</code>。此时 <code>eax</code> 中存储了函数的返回值。</li></ul><ol start="19"><li><code>mov eax, -0x4(ebp)</code></li></ol><ul><li>将 <code>eax</code>（即 <code>a + b</code> 的结果）存储到函数 <code>func</code> 的返回值位置，即栈帧中 <code>ebp</code> 的 <code>-0x4</code> 偏移处。</li></ul><ol start="20"><li><code>leave</code></li></ol><ul><li>归还栈帧，恢复调用函数的 <code>ebp</code>，即 <code>mov esp, ebp; pop ebp</code> 的简写。</li></ul><ol start="21"><li><code>ret</code></li></ol><ul><li>返回调用者，恢复 <code>eip</code>（指令指针），即从 <code>_Z4funcii</code> 返回到 <code>main</code> 函数继续执行。</li></ul><h3 id="示例-5">示例</h3><img src="/2025/01/25/C6/image-20241025194842012.png" class="" title="image-20241025194842012"><p>这张PPT展示了使用 <code>__fastcall</code> 调用约定下，如何处理<strong>包含三个参数</strong>的函数调用过程，以及其在栈中的变化。我们将对C代码、汇编指令和栈的布局进行详细分析。</p><p><strong>1. C代码部分</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    r = <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 调用带有三个参数的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((fastcall))</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;  <span class="comment">// 返回三个参数的和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>func()</code> 函数使用 <code>__fastcall</code> 调用约定，这意味着<strong>前两个参数 <code>a</code> 和 <code>b</code> 是通过寄存器传递，而第三个参数 <code>c</code> 通过堆栈传递</strong>。</li></ul><ol start="2"><li>汇编指令和栈帧分析</li></ol><p><code>main</code> 函数部分：</p><ol><li><p><code>sub $0xc, esp</code></p><ul><li>为局部变量和栈帧分配12个字节的空间。</li></ul></li><li><p><code>push $0x3</code></p><ul><li><strong>将常量 <code>3</code> 压入栈中。因为 <code>__fastcall</code> 调用约定下，第三个参数 <code>c</code> 是通过堆栈传递的。</strong></li></ul></li></ol><p><code>function</code> 函数部分：</p><ol><li>其实关键点就在于第21行将存在栈中的参数3移到eax中参与运算</li></ol><h2 id="按名字调用-按值-结果调用">按名字调用/按值-结果调用</h2><h3 id="示例-6">示例</h3><img src="/2025/01/25/C6/image-20241025200538398.png" class="" title="image-20241025200538398"><p>这张PPT讨论了两种常见的参数传递方式——<strong>Call by Name</strong> 和 <strong>Call by Value-Result</strong>，并展示了它们在运行时的行为差异。</p><ol><li><strong>Call by Name</strong> （按名字调用）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">p</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    ++i; </span><br><span class="line">    ++x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>]; </span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span>; </span><br><span class="line">a[<span class="number">2</span>] = <span class="number">2</span>; </span><br><span class="line"><span class="built_in">p</span>(a[i]);</span><br></pre></td></tr></table></figure><p><strong>解释</strong></p><ul><li><p><strong>Call by Name</strong> 的意思是：参数不是立即被计算的，而是在需要的时候才进行求值，这也称为<strong>延迟求值（Delayed Evaluation）</strong>。</p></li><li><p>在上面的代码中，<code>p(a[i])</code>将数组元素<code>a[i]</code>作为参数传递给函数<code>p</code>。但在“按名字调用”模式下，传递的不是实际的值，而是一个类似表达式的引用。也就是说，每次在<code>p()</code>函数内部使用参数时，都会动态地重新计算<code>a[i]</code>的值。</p><p>具体步骤：</p><ol><li><code>a[1] = 1;</code> 将<code>a[1]</code>赋值为1。</li><li><code>a[2] = 2;</code> 将<code>a[2]</code>赋值为2。</li><li><code>p(a[i])</code> 传递的是一个表达式，代表数组<code>a[i]</code>，由于<code>i</code>初始化为<code>1</code>，因此<code>a[i]</code>在开始时等于<code>a[1]</code>，即值<code>1</code>。</li><li>在函数<code>p()</code>中，<code>++i</code> 将全局变量<code>i</code>加1，这时<code>i = 2</code>。</li><li>紧接着的<code>++x</code> 实际上是对<code>a[i]</code>的操作，因为此时<code>i</code>的值已经是2，所以操作的其实是<code>a[2]</code>。因此<code>a[2]</code>从<code>2</code>变成了<code>3</code>。</li></ol><p>这就是<strong>Call by Name</strong>的特点：<strong>参数不是值本身，而是一个表达式，延迟到使用时才求值</strong>。这种机制可能会导致函数内部改变调用时传入的变量（如<code>i</code>）后，参数的值也会变化。</p></li></ul><p><strong>总结</strong></p><ul><li><strong>延迟求值（Delayed Evaluation）</strong>：在<code>p(a[i])</code>的调用过程中，<strong><code>a[i]</code>是在<code>p()</code>内部求值的，每次访问时都会动态计算<code>a[i]</code>的值</strong>。因此，在<code>i</code>变化时，<code>a[i]</code>的值也随之改变。</li></ul><ol start="2"><li><strong>Call by Value-Result</strong> （按值-结果调用）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">p</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    ++x; </span><br><span class="line">    ++y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">p</span>(a, a);</span><br></pre></td></tr></table></figure><p><strong>解释</strong></p><ul><li><p><strong>Call by Value-Result</strong> 是一种参数传递方式，首先将传递的实参<strong>按值</strong>复制到形参中，函数对这些形参进行操作。函数结束时，再将形参的值<strong>返回并更新</strong>到原来的实参中，因此也称为<strong>Copy-Restore</strong> 模式。</p></li><li><p>在上面的代码中，<code>p(a, a)</code> 将变量<code>a</code>的值传递两次，分别给函数<code>p()</code>的参数<code>x</code>和<code>y</code>。此时，<code>x</code>和<code>y</code>是独立的局部变量，它们的初始值都是<code>a</code>的值，即<code>1</code>。</p><p>具体步骤：</p><ol><li><code>a = 1;</code> 初始化变量<code>a</code>的值为1。</li><li><code>p(a, a)</code> 调用函数<code>p()</code>，由于是<strong>按值-结果</strong>调用，首先将<code>a</code>的值复制给<code>x</code>和<code>y</code>。</li><li>在函数<code>p()</code>中，<code>++x</code> 将<code>x</code>的值增加1，所以<code>x</code>变为2。</li><li>紧接着的<code>++y</code> 也将<code>y</code>的值增加1，所以<code>y</code>变为2。</li><li>函数<code>p()</code>执行完毕后，<code>x</code>和<code>y</code>的值都恢复到外部的变量<code>a</code>中，即将局部变量的修改结果复制回去。因此，<code>a</code>最终的值是<strong>2</strong>。</li></ol></li></ul><p><strong>总结</strong></p><ul><li><strong>Copy-Restore</strong>：在<code>p(a, a)</code>的调用过程中，<code>x</code>和<code>y</code>在函数内部是局部的副本，函数结束后，它们的值会恢复到实际参数中。这种方式会导致变量被修改两次，如果传递的是同一个变量，它的最终值是两次修改后的结果。</li></ul><p><strong>3. 比较和总结</strong></p><ul><li><p><strong>Call by Name（按名字调用）</strong>：参数按表达式传递，每次使用时都会重新计算表达式的值。这种方式的最大特点是延迟求值，参数的值随时可能变化，具体取决于调用时的上下文。</p></li><li><p><strong>Call by Value-Result（按值-结果调用）</strong>：参数传递时，传递的是值的副本，函数修改的是局部变量，函数结束时再将结果复制回实际参数。其特点是函数返回后，参数的值会被更新为函数内部的结果。</p></li></ul><p>==注意：上述两个都不是C++的实际传参机制，只是两个概念==</p><ul><li>C++是call by value和call by reference</li></ul><h2 id="函数原型">函数原型</h2><h3 id="示例-7">示例</h3><img src="/2025/01/25/C6/image-20241025201514887.png" class="" title="image-20241025201514887"><ul><li>==函数原型其实就是函数声明，排在文件最前面那个==</li></ul><ol><li><strong>遵循先定义后使用原则</strong></li></ol><ul><li><p><strong>解释</strong>：在C++中，函数必须要先声明或者定义，才能在程序的其他部分使用。这意味着，当你在代码的某处调用函数时，编译器必须已经知道该函数的存在，包括它的返回类型、参数类型等。否则，编译器将无法解析该函数调用。</p></li><li><p><strong>函数原型的作用</strong>：函数原型告诉编译器有关函数的信息，包括返回类型和参数类型，因此函数可以在函数定义之前调用。这是函数原型的主要作用。</p></li></ul><ol start="2"><li><strong>自由安排函数定义位置</strong></li></ol><ul><li><p><strong>解释</strong>：函数原型允许开发者将函数定义和声明分开，这样可以在多个源文件中调用同一个函数，并自由安排函数定义的位置。例如，程序可以在文件的开头包含一个函数原型声明，然后在另一个文件中实际定义这个函数。这种灵活性提高了代码的组织性和可维护性。</p></li><li><p><strong>实例</strong>：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数调用</span></span><br><span class="line">    <span class="built_in">printMessage</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>printMessage()</code>的原型在函数定义之前已经声明，所以它可以在<code>main()</code>中被调用，即使实际定义是在<code>main()</code>函数之后。</p></li></ul><ol start="3"><li><strong>语句：只需参数类型，无需参数名称</strong></li></ol><ul><li><p><strong>解释</strong>：函数原型只需要指定参数的类型，而不要求提供参数的名称。比如 <code>void f(int, int);</code>，这里只描述了函数<code>f</code>接受两个<code>int</code>类型的参数，并不关心参数的名称。编译器只需要知道参数的类型即可。</p></li><li><p><strong>详细说明</strong>：在函数原型中省略参数名称的做法使得函数声明更加简洁。通常这种省略仅在声明时使用，而在实际的函数定义中，还是需要给参数命名的，便于在函数体内使用这些参数。</p><p>示例：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，函数原型 <code>void add(int, int);</code> 仅指定了两个 <code>int</code> 参数的类型，而在函数定义中，参数名称 <code>a</code> 和 <code>b</code> 被实际使用。</p></li></ul><ol start="4"><li><strong>编译器检查</strong></li></ol><ul><li><strong>解释</strong>：编译器在编译阶段会检查函数调用的合法性。也就是说，当你调用一个函数时，编译器会根据函数原型检查传递的参数是否与原型中的参数类型匹配。原型中的返回类型和参数类型定义了函数的&quot;接口&quot;，编译器将根据这些信息验证函数调用的正确性。</li></ul><ol start="5"><li><strong>示例：void f(int, int);</strong></li></ol><ul><li><p><strong>解释</strong>：这个函数原型 <code>void f(int, int);</code> 表示一个名为 <code>f</code> 的函数，它没有返回值（返回类型是 <code>void</code>），并接受两个 <code>int</code> 类型的参数。尽管参数名称被省略，但它仍然能告诉编译器函数的签名，并且调用该函数时，编译器会根据这个原型进行检查。</p><p>在实际定义函数时，通常会给参数起名称：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y: &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数重载与多态">函数重载与多态</h2><h3 id="示例-8">示例</h3><img src="/2025/01/25/C6/image-20241025202102216.png" class="" title="image-20241025202102216"><ol><li><strong>函数重载（Overloading）</strong></li></ol><p><strong>重载的原则：</strong></p><ul><li><p><strong>同名，参数不同</strong>：在C++中，函数重载允许在同一个作用域中定义多个名称相同但参数列表不同的函数。参数列表的不同可以表现为：</p><ul><li>参数的<strong>个数</strong>不同。</li><li>参数的<strong>类型</strong>不同。</li><li>参数的<strong>顺序</strong>不同（当类型不相同时）。</li></ul><p>但是<strong>返回类型</strong>并不能作为区分重载函数的标准，因为编译器只根据函数名和参数列表来确定调用哪个函数。返回类型并不包含在函数的签名中。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span></span>;       <span class="comment">// 打印整数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> x)</span></span>;    <span class="comment">// 打印浮点数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>; <span class="comment">// 打印两个整数</span></span><br></pre></td></tr></table></figure><p>这些函数的名字都是 <code>print</code>，但是由于它们的参数列表不同，因此它们可以共存，且编译器能够根据调用时传递的参数类型和数量来选择调用哪个函数。</p></li></ul><p><strong>匹配原则：</strong></p><ul><li><p><strong>严格匹配</strong>：当编译器寻找函数时，<strong>首先会</strong>尝试严格匹配传入参数和可用的重载函数的参数。如果找到完全匹配的函数，就调用它。</p></li><li><p><strong>内部转换</strong>：如果没有严格匹配，编译器会尝试进行隐式转换，如从<code>int</code>到<code>double</code>、从<code>float</code>到<code>double</code>等基础类型的转换。它会寻找可以通过隐式类型转换得到的重载函数。</p></li><li><p><strong>用户定义的转换</strong>：如果基础类型的转换也没有找到匹配的函数，编译器可能会尝试调用用户定义的类型转换函数（如通过<code>operator</code>重载实现的转换）来进行参数转换。</p></li></ul><p><strong>模棱两可的情况：</strong></p><p>PPT中的例子提到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">long</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">double</span>)</span></span>; </span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>);  <span class="comment">// ambiguous</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>f(10)</code> 调用会引发编译错误，因为 <code>10</code> 是 <code>int</code> 类型，但编译器不知道应该将 <code>int</code> 转换为 <code>long</code> 还是 <code>double</code>。这就是所谓的**模棱两可（ambiguous）**问题。由于<code>long</code>和<code>double</code>都是<code>int</code>的合理转换目标，编译器无法确定调用哪个版本的<code>f()</code>。</p><p>解决这种模棱两可的问题的一种方法是显式地指定类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(<span class="built_in">static_cast</span>&lt;<span class="type">long</span>&gt;(<span class="number">10</span>));  <span class="comment">// 明确调用 long 版本</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>符号表（Name Mangling）</strong></li></ol><p><strong>符号表的概念：</strong></p><ul><li><p><strong>Name Mangling</strong> 是C++编译器用来解决函数重载的技术。由于C语言不支持函数重载，因此在链接C++程序时，<strong>编译器会通过修改函数的名字来包含参数类型等信息，确保每个重载函数都有一个唯一的符号</strong>。这就是所谓的符号改编（Name Mangling）。</p></li><li><p>在PPT中，<code>int func(int d)</code> 被改编为 <code>_Z4funci</code>。这是C++编译器对函数名称的改编形式，<strong>它将函数的参数类型编码进符号名中，确保每个重载函数都有唯一的符号</strong>。</p></li></ul><p><strong>与 C 语言的兼容：</strong></p><ul><li><strong>extern “C”</strong>：PPT中提到 <code>extern &quot;C&quot; void foo();</code> 这是用来告诉编译器不要对 <code>foo</code> 进行符号改编（Name Mangling），以便与C语言进行互操作。C语言不支持函数重载，因此C语言的符号命名是简单的，而C++使用符号改编来支持其复杂的特性。</li><li><strong>使用<code>extern &quot;C&quot;</code>可以确保C++编译器生成的符号与C语言兼容，通常用于C++代码与C语言库之间的交互</strong>。例如，链接C语言的库文件时，就需要通过<code>extern &quot;C&quot;</code>来防止C++的符号改编。</li></ul><ol start="3"><li><strong>多态性（Polymorphism）</strong></li></ol><p>多态性是C++面向对象编程的重要概念，它允许一个函数或对象表现出不同的行为。这里的多态性是指通过<strong>函数重载</strong>实现的静态多态（编译时多态），即同名函数根据不同的参数执行不同的代码。</p><ul><li><p><strong>编译时多态</strong>：在函数重载中，编译器在编译时就能确定调用哪个函数，因此这是静态多态的一种表现。</p></li><li><p><strong>运行时多态</strong>：另一种多态是通过**虚函数（virtual function）**实现的动态多态。在运行时，程序会根据实际的对象类型来选择调用的函数版本。</p></li></ul><h2 id="带默认参数的函数">带默认参数的函数</h2><h3 id="示例-9">示例</h3><img src="/2025/01/25/C6/image-20241025203334681.png" class="" title="image-20241025203334681"><ol><li><strong>带默认参数的函数</strong></li></ol><p><strong>默认参数的声明</strong></p><ul><li><p><strong>函数原型中给出</strong>：默认参数通常在**函数声明（函数原型）**中给出，也就是说，可以在函数的声明部分为某些参数提供默认值，而在调用函数时可以选择是否传递这些参数。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">(<span class="type">int</span> x = <span class="number">10</span>)</span></span>; <span class="comment">// 函数声明</span></span><br></pre></td></tr></table></figure><p>在这个例子中，参数<code>x</code>有一个默认值<code>10</code>，这意味着如果在调用函数时不传递<code>x</code>，函数会自动使用这个默认值。</p></li><li><p><strong>定义中给出</strong>：如果在函数声明中没有提供默认参数，也可以在函数定义中给出。但要注意：<strong>默认参数只能在声明或定义中提供一次，不能重复给定。</strong></p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">(<span class="type">int</span> x)</span></span>;  <span class="comment">// 声明中没有默认值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">(<span class="type">int</span> x = <span class="number">10</span>)</span> </span>&#123;  <span class="comment">// 定义中给出默认值</span></span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重点</strong>：PPT中提到的“函数原型中给出”这一点表明，<strong>通常我们在函数声明中设置默认参数，这样函数可以在定义之前被调用。</strong></p></li></ul><p><strong>默认参数的顺序</strong></p><ul><li><p><strong>从右到左</strong>：默认参数必须从参数列表的最右侧开始提供，不能跳过中间的参数。例如，不能为第一个参数提供默认值而不给第二个参数提供默认值。</p><p>正确的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y = <span class="number">10</span>)</span></span>;  <span class="comment">// y有默认值</span></span><br></pre></td></tr></table></figure><p>错误的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">(<span class="type">int</span> x = <span class="number">5</span>, <span class="type">int</span> y)</span></span>;  <span class="comment">// 错误，y没有默认值，x有默认值</span></span><br></pre></td></tr></table></figure><p>原因在于，C++的函数调用时从左到右匹配参数，如果你给第一个参数设定默认值却不给第二个参数设定默认值，那么在调用时编译器会不知道如何匹配这些参数。</p></li></ul><p><strong>不间断的默认参数</strong></p><ul><li><p>如果某个参数有默认值，那么它右侧的所有参数也必须有默认值，才能使默认参数顺序保持一致。这是为了确保函数调用时的参数匹配不会产生歧义。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">example</span><span class="params">(<span class="type">int</span> a = <span class="number">1</span>, <span class="type">int</span> b = <span class="number">2</span>, <span class="type">int</span> c = <span class="number">3</span>)</span></span>;  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>如果第一个或第二个参数有默认值，而第三个没有，就会产生问题。</p></li></ul><ol start="2"><li><strong>默认参数与函数重载</strong></li></ol><p>PPT提到<strong>重载的补充</strong>，这意味着默认参数可以与函数重载一起使用，但在某些情况下可能会引发**模棱两可（ambiguous）**的问题。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;           <span class="comment">// 声明1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>, <span class="type">int</span> = <span class="number">2</span>)</span></span>;  <span class="comment">// 声明2</span></span><br></pre></td></tr></table></figure><ul><li>当你调用 <code>f(10)</code> 时，编译器无法确定到底应该调用哪个版本的 <code>f()</code>，因为 <code>f(10)</code> 同时满足这两个声明的条件：<ul><li>它可以调用声明1，因为 <code>f(int)</code> 只需要一个参数；</li><li>它也可以调用声明2，因为 <code>f(int, int = 2)</code> 提供了一个默认参数，因此只传递一个参数也是可以的。</li></ul></li></ul><p>这种情况会导致模棱两可的错误，编译器无法确定使用哪个版本的函数。为了避免这种情况，函数重载和默认参数的使用必须谨慎。</p><ol start="3"><li><strong>函数重载与默认参数的实际区别</strong></li></ol><ul><li><p><strong>默认参数和函数重载是两种不同的机制</strong>。默认参数是指在函数声明中为参数提供默认值，使得函数调用时可以省略部分参数，而函数重载是通过相同的函数名和不同的参数列表来定义多个函数。</p><p><strong>函数重载示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>默认参数示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>它们可以同时使用，但如果使用不当会导致编译器无法区分函数调用，从而导致编译错误。</p></li></ul><h2 id="inline">inline</h2><h3 id="示例-10">示例</h3><img src="/2025/01/25/C6/image-20241025203633682.png" class="" title="image-20241025203633682"><img src="/2025/01/25/C6/image-20241025203749044.png" class="" title="image-20241025203749044"><p>这两张PPT共同探讨了**函数的执行与成本（COST）<strong>和</strong>内联函数（inline function）**的概念。我们可以从执行时的堆栈、数据段与内联函数的使用入手，详细解释其中涉及的概念和问题。</p><p><strong>第一张PPT：函数执行与内存模型</strong></p><ol><li><strong>Q1: 能否不降低可读性的前提下，降低COST？</strong></li></ol><ul><li><p>这里的<strong>COST</strong>（成本）指的是函数调用的开销。函数调用时涉及的成本主要包括：</p><ul><li><strong>栈操作</strong>：每次函数调用都会在栈上分配局部变量的空间，同时保存返回地址和其他必要的上下文信息。</li><li><strong>参数传递</strong>：参数通过栈或者寄存器传递，尤其是较大的数据结构，传递时会增加开销。</li><li><strong>跳转和返回</strong>：调用函数需要进行跳转并在结束时返回。</li></ul><p><strong>优化方向</strong>：</p><ul><li><strong>使用内联函数</strong>：在不增加代码复杂度的前提下，可以通过使用内联函数来减少函数调用的开销。<strong>内联函数会将函数体直接插入调用点，避免了栈操作和跳转</strong>，因此能够降低调用开销（COST）。</li></ul></li></ul><ol start="2"><li><strong>Q2: 使用Lib需要注意什么？</strong></li></ol><ul><li>这个问题涉及到在使用外部库（Lib）时需要注意的事项。可能需要关注以下几点：<ul><li><strong>内存分配</strong>：图中展示了堆（Heap）和栈（Stack）的分布。库中的某些操作可能会分配堆内存（例如使用<code>malloc</code>）。要确保正确地管理内存，避免内存泄漏。</li><li><strong>库的依赖</strong>：使用外部库时要了解该库的依赖项，确保在编译和链接时正确配置这些依赖。</li><li><strong>ABI（应用二进制接口）兼容性</strong>：在不同的系统或者编译器之间，库的接口需要保持一致，尤其是在跨平台开发时，要确保库的ABI兼容。</li></ul></li></ul><ol start="3"><li><strong>Q3: 执行性能？</strong></li></ol><ul><li><p>这个问题考察的是代码执行的性能，特别是堆栈与代码段的配合。</p><ul><li><strong>代码段</strong>（Code）：包含函数的机器指令，属于只读区域（R）。</li><li><strong>数据段</strong>（Data）：包含全局变量、静态变量等可读写数据（RW）。</li><li><strong>堆</strong>（Heap）：动态分配的内存区域（如<code>malloc</code>），存放动态数据。</li><li><strong>栈</strong>（Stack）：用于函数调用时存储局部变量、参数和返回地址，是最常见的动态区域。</li></ul><p><strong>执行性能的提升</strong>：</p><ul><li>减少栈上不必要的操作，合理管理堆内存。</li><li>通过<strong>内联函数减少调用开销</strong>，减少不必要的动态内存分配操作。</li><li>优化局部变量和全局变量的使用，合理安排数据段和栈的使用。</li></ul></li></ul><p><strong>PPT中涉及的内存模型</strong></p><ul><li><strong>静态符号表</strong>：展示了静态变量和全局变量的内存地址（例如<code>x</code>和<code>d</code>），这些变量位于数据段。</li><li><strong>代码段</strong>：表示函数的机器代码存放的位置，多个函数调用共享代码段，只有在执行时才会跳转到对应的地址执行。</li></ul><p><strong>第二张PPT：内联函数（inline function）</strong></p><ol><li><strong>目的</strong></li></ol><ul><li><p><strong>提高可读性</strong>：使用内联函数可以减少代码冗余。将常用的小函数标记为<code>inline</code>，编译器会在函数调用处直接插入函数体，避免传统函数调用的跳转，既简化了代码结构，又提高了代码的可读性。</p></li><li><p><strong>提高效率</strong>：通过<strong>消除函数调用的栈操作、参数传递和跳转返回操作</strong>，内联函数可以提高性能。尤其在<strong>频繁调用的小函数场景</strong>下，内联函数能显著降低开销。</p></li></ul><ol start="2"><li><strong>实现方法</strong></li></ol><ul><li><p><strong>编译器优化</strong>：当声明一个函数为<code>inline</code>时，编译器会试图将函数的代<strong>码直接插入到每个调用点</strong>，而不是通过函数调用的传统方式。这是一种<strong>编译期的优化</strong>，不会影响运行时的行为。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">add</span>(<span class="number">5</span>, <span class="number">3</span>);  <span class="comment">// 编译时，add函数的代码会被直接插入到此处</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><strong>限制</strong></li></ol><ul><li><p><strong>递归</strong>：内联函数<strong>不能用于</strong>递归调用。如果递归函数被内联，将会导致无限扩展，最终使编译器无法处理。</p></li><li><p><strong>函数指针</strong>：当使用函数指针调用函数时，内联优化是无效的。因为函数指针的调用是动态的，而内联函数的插入是静态的。</p></li></ul><ol start="4"><li><strong>内联函数的使用场景</strong></li></ol><ul><li><p><strong>小型、频繁调用的函数</strong>：内联函数适合于小型且频繁调用的函数，例如getter、setter等。这些函数通常具有较少的逻辑，编译器可以轻松地将它们直接插入到调用点，从而避免函数调用的额外开销。</p></li><li><p><strong>需要提高性能的场景</strong>：内联函数可以显著减少函数调用的开销，尤其在性能敏感的代码中，频繁调用的小函数可以使用<code>inline</code>关键字。</p></li></ul><h3 id="示例-11">示例</h3><img src="/2025/01/25/C6/image-20241025204232656.png" class="" title="image-20241025204232656"><p>这张PPT通过一个<code>inline</code>函数的示例，展示了<strong>内联函数如何在编译过程中优化函数调用</strong>。右侧的汇编代码展示了函数<code>ascii</code>的内联过程，并且特别标注了<code>pushl $0x31</code>这一指令</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ascii</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    r = <span class="built_in">ascii</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;r = %d\n&quot;</span>, r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>关键点：<code>pushl $0x31</code></strong></li></ol><ul><li>在没有内联优化的情况下，<code>ascii('1')</code>会生成一次函数调用，通过跳转执行<code>ascii</code>函数体，然后返回ASCII值。</li><li>由于<code>ascii</code>是内联函数，编译器直接将<code>'1'</code>的ASCII值插入到调用点。因此，<code>pushl $0x31</code>这一行代码说明了<strong>编译器已经将字符<code>'1'</code>的ASCII值<code>49</code>直接嵌入到汇编代码中，而不需要通过函数调用来获得。</strong></li></ul><ol start="2"><li><strong>汇编中的.LCO</strong></li></ol><ul><li><code>.LCO</code> 表示用于<code>printf</code>的字符串<code>&quot;r = %d\n&quot;</code>的地址，它是编译器为这个字符串分配的符号。在调用<code>printf</code>时，字符串地址会被压入栈中，后续的<code>call printf</code>会使用这个地址进行格式化输出。</li></ul><h3 id="示例-12">示例</h3><img src="/2025/01/25/C6/image-20241025204633116.png" class="" title="image-20241025204633116"><ol><li><strong>适用场景</strong></li></ol><ul><li><strong>频繁调用、小段代码</strong>： 内联函数适用于<strong>频繁调用、简单且短小的代码段</strong>。特别是那些逻辑简单的函数，例如访问器（getters）、设置器（setters）等，因为它们经常被调用，且函数体非常小，使用内联函数可以显著减少开销。</li><li><strong>注意</strong>：并不是所有函数都适合内联。对于复杂的大型函数，内联并不能显著提高性能，反而可能导致代码膨胀，使得生成的机器代码变得臃肿，反而可能影响性能。因此，编译器也会在实际内联时进行权衡。</li></ul><ol start="2"><li><strong>“仅仅是请求”</strong></li></ol><ul><li><p>PPT中的红色文字“<strong>仅仅是请求</strong>”强调了一个重要的事实：在C++中，<code>inline</code> 关键字<strong>只是对编译器的建议，并不是强制指令</strong>。编译器最终会根据实际情况决定是否将函数内联。<strong>有些情况下，即使你声明了<code>inline</code>，编译器可能仍然不会将函数内联</strong>，比如函数过于复杂，或编译器认为内联并不会提高性能。</p></li><li><p>同样，编译器也可以将没有标记为<code>inline</code>的函数内联化。这完全取决于编译器的优化策略。</p></li></ul><h3 id="示例-13">示例</h3><img src="/2025/01/25/C6/image-20241025205028780-17298606291021.png" class="" title="image-20241025205028780"><ol><li><strong>明智地运用Inlining</strong></li></ol><p><strong>只是对编译系统的提示</strong></p><p>PPT强调内联函数只是对编译器的<strong>建议</strong>，编译器并不一定会按照程序员的请求将函数内联。即使使用了<code>inline</code>关键字，编译器会根据具体情况决定是否将函数内联化，这取决于函数的复杂度、编译器的优化设置和目标架构。</p><p>以下几种情况可能会让<strong>编译器拒绝将函数内联</strong>：</p><ul><li><p><strong>Big/complex functions</strong>：</p><ul><li>如果函数过大或者包含复杂的逻辑（如复杂的循环、<code>switch</code>语句等），编译器通常不会将其内联。内联的目的是为了提高执行效率，而复杂的函数内联后可能会导致代码膨胀，反而降低性能。</li></ul></li><li><p><strong>Function pointer</strong>：</p><ul><li>如果函数是通过<strong>函数指针</strong>调用的，编译器无法内联。函数指针在运行时才会被解析，编译器无法在编译时将代码插入到调用点。因此，内联只能用于直接调用的函数。</li></ul></li></ul><ol start="2"><li><strong>编译器的处理方式（Outlined）</strong></li></ol><ul><li><p><strong>static function</strong>：</p><ul><li>在某些情况下，编译器可能会选择将函数编译为静态函数而不是内联。这意味着编译器生成的目标代码中函数仍然作为一个独立的实体，而不是直接插入到调用点。这种处理方式常用于那些不适合内联的函数。</li></ul></li><li><p><strong>recompile/link vs rebuild</strong>：</p><ul><li>这里提到的<strong>重新编译</strong>和<strong>重建</strong>，是指当程序修改后重新生成目标文件时，编译器会决定是否需要重新内联处理。如果代码发生了较大的变更，编译器可能会选择重新链接整个程序，而不是简单地内联。重新编译和重新链接的过程对于大型项目可能会影响构建时间，因此在使用内联时也要考虑到构建时间的成本。</li></ul></li></ul><ol start="3"><li><strong>内联函数的缺点</strong></li></ol><p>尽管内联函数有提高执行效率的优点，但它也有一些缺点。PPT列出了几个关键问题：</p><p><strong>增加目标代码（object code）</strong></p><ul><li>内联函数的一个显著问题是<strong>代码膨胀</strong>。当编译器将函数体插入到每一个调用点时，函数调用的次数越多，插入的代码就越多。这会导致目标代码（object code）变得非常大，尤其是对于那些频繁调用的函数。代码膨胀可能导致更大的可执行文件，并且会占用更多的内存。</li></ul><p><strong>病态的换页（thrashing）</strong></p><ul><li>代码膨胀可能导致<strong>病态的换页</strong>（thrashing）。这是一个性能问题，当程序频繁调用内联函数，生成的大量代码可能导致CPU的指令缓存不够用，迫使系统频繁在内存和缓存之间换页。这会显著降低系统的性能，因为换页是一个非常昂贵的操作，特别是当系统处理大量内联代码时。</li></ul><p><strong>降低指令缓存命中率（instruction cache hit rate）</strong></p><ul><li>当内联函数导致目标代码变大时，会增加指令缓存的压力，降低缓存的<strong>命中率</strong>。指令缓存的命中率越高，程序的执行效率越高。内联函数可能会导致代码分布更加分散，降低CPU在高速缓存中存储指令的效果，进而导致更多的缓存未命中（cache miss），使得程序的运行效率下降。</li></ul><ol start="4"><li><strong>时间局部性与空间局部性</strong></li></ol><ul><li><p><strong>时间局部性</strong>：内联函数有可能影响<strong>时间局部性</strong>，即同一块数据或代码在较短时间内多次使用。如果内联函数导致了代码膨胀，增加了指令缓存的压力，可能会降低时间局部性，使得系统在执行相同指令时需要更多的时间。</p></li><li><p><strong>空间局部性</strong>：内联函数同样可能影响<strong>空间局部性</strong>，即相邻的数据或指令能够存储在一起并被快速访问。代码膨胀可能使得相邻指令分布在内存的不同位置，破坏了空间局部性，从而降低了系统的性能。</p></li></ul><h2 id="ROP攻击">ROP攻击</h2><h3 id="示例-14">示例</h3><img src="/2025/01/25/C6/image-20241025205711187.png" class="" title="image-20241025205711187"><p>这张PPT展示了与**ROP攻击（Return-Oriented Programming）**相关的内存布局和代码执行流程。ROP是一种常见的攻击技术，攻击者利用已有的合法代码片段来进行恶意操作，而不需要直接注入新的恶意代码。</p><ol><li><strong>CODE段：现有的代码片段</strong></li></ol><p>在图的左侧，有三个函数 <code>Func1</code>、<code>Func2</code> 和 <code>Func3</code>，它们是程序中的正常代码片段，位于代码段（Code Segment）中。攻击者并不会直接修改这些函数的代码，而是利用这些函数中的小片段来执行恶意代码。</p><p><strong>Func1：</strong></p><ul><li><code>push ebp</code> 和 <code>mov esp, ebp</code> 是典型的栈帧设置操作，设置当前栈帧。</li><li><code>sub $0x10, esp</code> 为局部变量分配栈空间。</li><li><code>mov (ebp+0xc), eax</code> 和 <code>mov (ebp+0x8), edx</code> 读取函数参数。</li><li><code>add edx, eax</code> 执行简单的加法操作。</li><li><code>ret</code> 是函数返回指令，它会从栈中弹出返回地址，跳转到该地址继续执行代码。</li></ul><p><strong>Func2 和 Func3：</strong></p><ul><li>这些函数类似，执行一些计算操作后，最终会通过 <code>ret</code> 返回。这里标记了多个内存地址，如 <code>bad_addr1</code>、<code>bad_addr2</code> 和 <code>bad_addr3</code>，这些地址是攻击者准备利用的“合法”代码片段的入口。</li></ul><p><strong>恶意利用（Malicious Code）</strong></p><ul><li>在ROP攻击中，攻击者并不会注入整个恶意代码段，而是利用程序中现有的“片段”——即这些合法的函数返回地址和指令组合。</li><li><code>bad_addr1</code>、<code>bad_addr2</code> 和 <code>bad_addr3</code> 是ROP攻击中攻击者利用的“gadget”代码片段，这些片段通常由一两条指令和一个<code>ret</code>指令组成。攻击者通过改变栈上的返回地址，控制程序的执行流，使程序执行这些片段中的指令。</li></ul><ol start="2"><li><strong>STACK段：栈上的结构</strong></li></ol><p>图的右侧是栈（Stack）的结构，显示了执行过程中栈上的数据变化。在正常情况下，函数调用时会将返回地址和局部变量等内容存储在栈中，但在ROP攻击中，栈上的内容会被攻击者修改，用于执行恶意指令。</p><ul><li><p><strong><code>ebp_main</code> 和 <code>esp_main</code></strong>：这些是栈顶和栈帧基址寄存器的当前状态。在正常情况下，它们指向当前函数的局部变量和返回地址。</p></li><li><p><strong><code>Bad_addr</code></strong>：这是攻击者插入栈中的恶意地址，指向恶意的指令或者“gadget”代码片段。通过修改返回地址，攻击者使得程序返回时跳转到这些恶意的地址，执行任意指令。</p></li><li><p><strong><code>mal_inst</code></strong>：栈中还保存了攻击者的恶意指令序列，这些指令可能是攻击者想要执行的恶意操作。</p></li></ul><ol start="3"><li><strong>HEAP段：堆内存结构</strong></li></ol><p>图中右下方是堆（Heap）结构，显示了与ROP攻击相关的堆内存布局。堆上保存了一些恶意指令（<code>mal_inst</code>）和一些地址（<code>bad_addr1</code>、<code>bad_addr2</code> 等）。</p><ul><li>在某些情况下，攻击者可能利用堆中的数据作为攻击的一部分，通过溢出或者其它漏洞，将恶意代码片段插入堆中，并通过ROP技术跳转到堆中的恶意地址。</li></ul><ol start="4"><li><p><strong>ROP攻击流程</strong></p></li><li><p><strong>利用栈溢出或漏洞</strong>：</p><ul><li>攻击者首先利用栈溢出或者其它漏洞，将恶意数据写入栈中。正常情况下，栈上保存的是函数的返回地址和局部变量，但在ROP攻击中，攻击者会覆盖这些返回地址，使得函数返回时跳转到攻击者指定的“gadget”代码片段。</li></ul></li><li><p><strong>跳转到恶意地址</strong>：</p><ul><li>攻击者精心构造的栈布局会包含指向合法代码中的小片段（gadget）的地址，如图中的<code>bad_addr1</code>、<code>bad_addr2</code>、<code>bad_addr3</code>。当函数执行<code>ret</code>指令时，程序会跳转到这些地址，执行攻击者想要的操作。</li></ul></li><li><p><strong>控制程序执行流</strong>：</p><ul><li>通过一系列的“gadget”，攻击者可以控制程序的执行流，并执行任意恶意操作。这些操作可能包括修改内存、执行系统命令、甚至完全接管受害者系统。</li></ul></li><li><p><strong>恶意地址和指令的利用</strong></p></li></ol><ul><li><p><strong>bad_addr1、bad_addr2、bad_addr3</strong>：这些是恶意利用的合法代码片段的入口地址。每一个<code>bad_addr</code>都指向一个代码片段，这些片段会执行一些操作后通过<code>ret</code>返回，接着程序会继续执行下一个恶意地址。</p></li><li><p><strong>Malicious Code</strong>：攻击者利用这些地址，执行构建好的恶意代码序列。</p></li></ul><ol start="6"><li><strong>总结：ROP攻击的原理</strong></li></ol><ul><li>ROP攻击是一种通过合法代码片段执行恶意操作的攻击方式，攻击者利用栈溢出或其它漏洞改变栈上的返回地址。</li><li>攻击者通过修改栈上的数据，让程序跳转到合法代码中的小片段，这些小片段称为“gadget”，每个gadget执行少量指令并通过<code>ret</code>返回。</li><li>通过精心构造的gadget链，攻击者可以实现任意指令执行，控制程序行为，而无需直接注入完整的恶意代码。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++高级程序设计笔记（C2-1）</title>
      <link href="/2025/01/25/CPP-2-1/"/>
      <url>/2025/01/25/CPP-2-1/</url>
      
        <content type="html"><![CDATA[<h1>CPP-2-1</h1><h2 id="面向对象">面向对象</h2><h3 id="示例">示例</h3><img src="/2025/01/25/CPP-2-1/image-20241128195449916.png" class="" title="image-20241128195449916"><h2 id="封装">封装</h2><img src="/2025/01/25/CPP-2-1/image-20241218201740547.png" class="" title="image-20241218201740547"><img src="/2025/01/25/CPP-2-1/image-20241218201754849.png" class="" title="image-20241218201754849"><img src="/2025/01/25/CPP-2-1/image-20241218201846172.png" class="" title="image-20241218201846172"><h2 id="构造函数">构造函数</h2><img src="/2025/01/25/CPP-2-1/image-20241218202223114.png" class="" title="image-20241218202223114"><p><strong>public与private访问控制</strong></p><p><strong>（1）默认构造函数的访问权限</strong></p><ul><li>构造函数通常是 <code>public</code> 的，以便类的对象可以在外部被创建。</li><li>但是，可以将构造函数设置为 <code>private</code>，以<strong>禁止类外部创建对象</strong>。这种方式通常用于<strong>单例模式</strong>。</li></ul><p><strong>示例：将构造函数定义为 <code>private</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Example</span>() &#123;  <span class="comment">// 私有构造函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Constructor is called!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 通过静态方法提供对象创建的途径</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Example <span class="title">createObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Example</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Example obj; // 错误！无法直接调用私有构造函数</span></span><br><span class="line">    Example obj = Example::<span class="built_in">createObject</span>(); <span class="comment">// 通过静态方法创建对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor is called!</span><br></pre></td></tr></table></figure><p><strong>解析</strong>：</p><ul><li>将构造函数设置为 <code>private</code> 后，外部无法直接创建对象。</li><li>可以通过类内部的静态方法间接创建对象，这种机制在<strong>单例模式</strong>中常用。</li></ul><p><strong>5. <code>=default</code> 关键字</strong></p><ul><li><code>=default</code> 是C++11引入的新特性，用于显式要求编译器生成默认构造函数或其他默认函数。</li><li>使用 <code>=default</code> 可以让代码更清晰，显式地表示构造函数是默认实现。</li></ul><p><strong>示例：使用 <code>=default</code> 声明默认构造函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>() = <span class="keyword">default</span>; <span class="comment">// 显式要求编译器提供默认构造函数</span></span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">int</span> x) &#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Parameterized Constructor: x = &quot;</span> &lt;&lt; x &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Example obj1;    <span class="comment">// 调用默认构造函数</span></span><br><span class="line">    <span class="function">Example <span class="title">obj2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 调用带参数的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Parameterized Constructor: x = 10</span><br></pre></td></tr></table></figure><img src="/2025/01/25/CPP-2-1/image-20241218202635663.png" class="" title="image-20241218202635663"><h2 id="成员初始化表">成员初始化表</h2><img src="/2025/01/25/CPP-2-1/image-20241218202729014.png" class="" title="image-20241218202729014"><p><strong>1. 什么是成员初始化表？</strong></p><p><strong>成员初始化表</strong>（Member Initialization List）是<strong>构造函数</strong>中的一种特殊机制，它用于在构造函数的<strong>函数体执行之前</strong>初始化类中的<strong>数据成员</strong>。</p><p><strong>语法格式</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ClassName</span>(参数列表) : 成员<span class="number">1</span>(值), 成员<span class="number">2</span>(值), ... &#123;</span><br><span class="line">    <span class="comment">// 构造函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>成员名(值)</code> 的部分就是<strong>成员初始化表</strong>。</li><li>在构造函数体执行之前，类的成员会按照初始化表中的顺序进行初始化。</li></ul><p>-<strong>2. 成员初始化表的执行顺序</strong></p><ul><li><strong>先执行成员初始化表中的初始化操作</strong>。</li><li>然后执行构造函数体中的代码。</li><li><strong>成员的初始化顺序</strong>是按照<strong>类中数据成员的声明顺序</strong>决定的，而不是初始化表中出现的顺序。</li></ul><p><strong>3. 成员初始化表的优势</strong></p><ol><li><strong>高效</strong>：直接初始化成员，而不是先默认初始化再赋值，避免了多余的操作，<strong>提高性能</strong>。</li><li><strong>必须使用</strong>：对于某些特殊类型的成员（如 <code>const</code> 成员、引用成员、没有默认构造函数的类类型成员），只能通过初始化表进行初始化。</li><li><strong>减少编译器负担</strong>：编译器直接进行初始化，减少编译器的生成代码量。</li></ol><p><strong>4. 重要使用场景</strong></p><p><strong>（1）初始化 <code>const</code> 成员</strong></p><p><code>const</code> 成员在类对象创建时必须初始化，且只能通过<strong>初始化表</strong>进行初始化。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> val;  <span class="comment">// const成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x) &#123;  <span class="comment">// 使用初始化表初始化const成员</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Const value initialized to &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Example <span class="title">obj</span><span class="params">(<span class="number">100</span>)</span></span>;  <span class="comment">// 初始化const成员为100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Const value initialized to 100</span><br></pre></td></tr></table></figure><p><strong>解析</strong>：</p><ul><li><code>const</code> 成员 <code>val</code> 不能在构造函数体中赋值，只能通过<strong>初始化表</strong>完成初始化。</li></ul><p><strong>（2）初始化引用成员</strong></p><p>引用类型的成员（<code>int&amp;</code>）必须在定义时初始化，且不能被重新赋值，因此只能通过<strong>初始化表</strong>来初始化。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>&amp; ref;  <span class="comment">// 引用成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">int</span>&amp; x) : <span class="built_in">ref</span>(x) &#123;  <span class="comment">// 使用初始化表初始化引用成员</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Reference initialized to &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">42</span>;</span><br><span class="line">    <span class="function">Example <span class="title">obj</span><span class="params">(value)</span></span>;  <span class="comment">// 引用成员指向value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reference initialized to 42</span><br></pre></td></tr></table></figure><p><strong>解析</strong>：</p><ul><li>引用成员 <code>ref</code> 通过成员初始化表被初始化为 <code>value</code>，不能在构造函数体中赋值。</li></ul><p><strong>（3）初始化没有默认构造函数的类对象</strong></p><p>如果类成员是另一个没有默认构造函数的类对象，必须在初始化表中显式调用其构造函数。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> x) : <span class="built_in">data</span>(x) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B initialized with data = &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    B b;  <span class="comment">// 成员对象</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> val) : <span class="built_in">b</span>(val) &#123;  <span class="comment">// 使用初始化表显式调用B的构造函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A&#x27;s constructor called&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B initialized with data = 10</span><br><span class="line">A&#x27;s constructor called</span><br></pre></td></tr></table></figure><p><strong>解析</strong>：</p><ul><li>类 <code>B</code> 没有默认构造函数，所以必须通过初始化表显式调用 <code>B(int x)</code>。</li><li>在类 <code>A</code> 的构造函数中，成员对象 <code>b</code> 使用初始化表初始化为 <code>val</code>。</li></ul><p><strong>（4）初始化基本数据类型与默认值</strong></p><p>在PPT中的 <code>class A</code> 示例中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="type">int</span>&amp; z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">y</span>(<span class="number">1</span>), <span class="built_in">z</span>(x), <span class="built_in">x</span>(<span class="number">0</span>) &#123;  <span class="comment">// 成员初始化表</span></span><br><span class="line">        x = <span class="number">100</span>;  <span class="comment">// 构造函数体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：</p><ol><li><strong><code>y(1)</code></strong>：<code>y</code> 是 <code>const</code> 成员，必须在初始化表中初始化。</li><li><strong><code>z(x)</code></strong>：<code>z</code> 是引用类型，必须在初始化表中初始化，<code>z</code> 引用了 <code>x</code>。</li><li><strong><code>x(0)</code></strong>：直接通过初始化表将 <code>x</code> 初始化为 0，然后在构造函数体中将 <code>x</code> 赋值为 100。</li></ol><p><strong>5. 代码示例：成员初始化表的顺序</strong></p><p>成员初始化的顺序是按照<strong>成员声明的顺序</strong>，而不是初始化表中的顺序。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>() : <span class="built_in">b</span>(<span class="number">2</span>), <span class="built_in">a</span>(b + <span class="number">3</span>) &#123;  <span class="comment">// 初始化顺序是a -&gt; b（按声明顺序）</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Example obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>（可能有意外）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 3, b = 2</span><br></pre></td></tr></table></figure><p><strong>解析</strong>：</p><ul><li>虽然在初始化表中 <code>b</code> 被初始化在前面，但实际上 <code>a</code> 会先被初始化，因为类中数据成员的声明顺序是 <code>a</code> 在 <code>b</code> 之前。</li><li>因此，<code>a</code> 初始化时 <code>b</code> 还未被赋值，导致 <code>a = 3</code>（未使用 <code>b</code> 的最新值）。</li></ul><p><strong>图片右侧的 <code>class CString</code> 表达的含义</strong></p><p>右侧的 <code>class CString</code> 主要是想说明<strong>成员初始化表</strong>的使用方法，尤其是当类包含<strong>动态内存分配</strong>时，如何在构造函数中正确初始化成员变量。</p><p><strong>代码分析</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CString</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p;   <span class="comment">// 指向动态分配的字符数组</span></span><br><span class="line">    <span class="type">int</span> size;  <span class="comment">// 字符数组的大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CString</span>(<span class="type">int</span> x) : <span class="built_in">size</span>(x), <span class="built_in">p</span>(<span class="keyword">new</span> <span class="type">char</span>[size]) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>代码解释</strong></p><ol><li><strong>成员变量 <code>p</code> 和 <code>size</code></strong>：<ul><li><code>size</code> 是一个整数变量，用于保存字符数组的大小。</li><li><code>p</code> 是一个指针，指向动态分配的字符数组。</li></ul></li><li><strong>构造函数 <code>CString(int x)</code></strong>：<ul><li><strong><code>: size(x)</code></strong>：使用<strong>成员初始化表</strong>将 <code>size</code> 初始化为构造函数参数 <code>x</code>。</li><li><strong><code>p(new char[size])</code></strong>：动态分配一个字符数组，大小为 <code>size</code>，并将其地址赋给 <code>p</code>。</li></ul></li><li><strong>构造函数体为空</strong>：<ul><li>成员变量的初始化完全通过<strong>成员初始化表</strong>完成。</li><li>这样避免了在构造函数体内先默认初始化 <code>p</code> 和 <code>size</code>，然后再进行赋值，提升了效率。</li></ul></li></ol><p><strong><code>CString</code> 的要点</strong></p><ul><li><strong>动态内存管理</strong>：通过 <code>new</code> 在堆上动态分配内存。</li><li>成员初始化表的必要性：<ul><li>如果直接在构造函数体内给 <code>p</code> 赋值，<code>p</code> 会被默认初始化为 <code>nullptr</code>，然后再赋值，这样会增加不必要的操作。</li><li>使用初始化表可以直接初始化 <code>p</code> 和 <code>size</code>，更加高效。</li></ul></li><li>总结：<ul><li><code>size</code> 通过成员初始化表被赋值为 <code>x</code>。</li><li><code>p</code> 通过成员初始化表直接初始化为 <code>new char[size]</code>，避免了冗余操作。</li></ul></li></ul><p><strong>2. <code>class A</code> 中的 <code>int x&#123;0&#125;</code> 的含义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>解释</strong></p><ul><li><strong><code>int x&#123;0&#125;;</code></strong> 是 C++11 引入的<strong>统一初始化语法</strong>（也称为<strong>列表初始化</strong>）。</li><li>它的作用是将变量 <code>x</code> 初始化为 <code>0</code>。</li><li>相比传统的 <code>int x = 0;</code>，<code>int x&#123;0&#125;;</code> 更加安全，因为它可以避免<strong>窄化转换</strong>（narrowing conversion）。</li></ul><p><strong><code>int x&#123;0&#125;</code> 的特点</strong></p><ol><li>安全性更高：<ul><li>统一初始化 <code>&#123;&#125;</code> 会进行严格的类型检查，防止不安全的隐式类型转换。</li></ul></li></ol><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a&#123;<span class="number">3.5</span>&#125;;  <span class="comment">// 错误！编译时会报错，3.5不能隐式转换为int</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">3.5</span>; <span class="comment">// 正确！但会丢失小数部分</span></span><br></pre></td></tr></table></figure><ol><li>初始化的类型统一：<ul><li>这种 <code>&#123;&#125;</code> 语法适用于类成员、局部变量、数组等场景，统一了 C++ 中的初始化方式。</li></ul></li></ol><img src="/2025/01/25/CPP-2-1/image-20241218203416391.png" class="" title="image-20241218203416391"><img src="/2025/01/25/CPP-2-1/image-20241218203448033.png" class="" title="image-20241218203448033"><h2 id="析构函数">析构函数</h2><img src="/2025/01/25/CPP-2-1/image-20241218203504595.png" class="" title="image-20241218203504595"><img src="/2025/01/25/CPP-2-1/image-20241218205120098.png" class="" title="image-20241218205120098"><p><strong>1. 析构函数的概念</strong></p><p><strong>析构函数</strong>（Destructor）是一个特殊的成员函数，当对象的生命周期结束时（例如离开作用域或被 <code>delete</code> 删除），<strong>系统会自动调用析构函数</strong>，用于清理对象占用的资源。</p><p><strong>析构函数的特点</strong></p><ol><li>名称与类名相同，但前面加 <code>~</code>：<ul><li>例如：<code>~ClassName();</code></li></ul></li><li><strong>没有返回值</strong>，也没有参数。</li><li><strong>系统自动调用</strong>：当对象消亡时，析构函数会被自动调用。</li><li><strong>释放非内存资源</strong>：如关闭文件、释放动态内存、释放网络连接等。</li></ol><p><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Constructor called&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Example</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destructor called&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Example obj;  <span class="comment">// 创建对象</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Inside main()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  <span class="comment">// 对象生命周期结束，自动调用析构函数</span></span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor called</span><br><span class="line">Inside main()</span><br><span class="line">Destructor called</span><br></pre></td></tr></table></figure><p><strong>解析</strong>：</p><ul><li>构造函数 <code>Example()</code> 在对象创建时被调用。</li><li>析构函数 <code>~Example()</code> 在对象消亡时被调用，完成资源清理。</li></ul><p><strong>2. 析构函数的作用</strong></p><ul><li><strong>自动释放资源</strong>：对象消亡时，自动释放对象所占的资源。</li><li><strong>非内存资源管理</strong>：如关闭文件、释放数据库连接等。</li><li><strong>手动释放内存</strong>：如释放 <code>new</code> 分配的动态内存，防止内存泄漏。</li></ul><p><strong>3. PPT中的代码分析</strong></p><p><strong>代码片段：class A</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123; <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ~<span class="built_in">A</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>代码解释</strong></p><ol><li><strong><code>A()</code></strong>：<ul><li>公有的构造函数，允许创建对象。</li></ul></li><li><strong><code>~A()</code></strong>：<ul><li>私有的析构函数，<strong>禁止外部代码直接删除对象</strong>，以确保对象生命周期由类本身控制。</li></ul></li><li><strong><code>destroy()</code> 方法</strong>：<ul><li>通过 <code>delete this;</code> 来手动销毁对象。</li><li><code>delete this;</code> 的使用要<strong>非常小心</strong>，确保对象是在堆上分配的，否则会引发未定义行为。</li></ul></li></ol><p><strong><code>delete this;</code> 的问题与用法</strong></p><p><strong>问题</strong>：</p><ul><li>如果对象不是在堆上创建的，<code>delete this;</code> 会导致未定义行为。</li><li>因此，必须保证对象是通过 <code>new</code> 分配在堆上的。</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A *p = <span class="keyword">new</span> <span class="built_in">A</span>();  <span class="comment">// 堆上创建对象</span></span><br><span class="line">p-&gt;<span class="built_in">destroy</span>();    <span class="comment">// 调用destroy()方法，delete this删除对象</span></span><br></pre></td></tr></table></figure><p><strong>错误用法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A obj;  <span class="comment">// 栈上创建对象</span></span><br><span class="line">obj.<span class="built_in">destroy</span>();  <span class="comment">// 错误！delete this 会导致未定义行为</span></span><br></pre></td></tr></table></figure><p><strong>4. RAII vs GC</strong></p><p><strong>RAII（Resource Acquisition Is Initialization）</strong></p><p>RAII 是C++中资源管理的重要原则：</p><ul><li><strong>资源获取即初始化</strong>：在构造函数中获取资源（如动态内存、文件句柄），在析构函数中释放资源。</li><li><strong>自动管理资源</strong>：通过对象的生命周期自动释放资源，避免内存泄漏。</li></ul><p><strong>示例：RAII 原则</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileHandler</span> &#123;</span><br><span class="line">    fstream file;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FileHandler</span>(<span class="type">const</span> string&amp; filename) &#123;</span><br><span class="line">        file.<span class="built_in">open</span>(filename, ios::out);</span><br><span class="line">        <span class="keyword">if</span> (file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;File opened successfully!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">FileHandler</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            file.<span class="built_in">close</span>();</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;File closed in destructor.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">FileHandler <span class="title">fh</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>;  <span class="comment">// 构造函数打开文件，析构函数关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File opened successfully!</span><br><span class="line">File closed in destructor.</span><br></pre></td></tr></table></figure><p><strong>解析</strong>：</p><ul><li>构造函数中打开文件，析构函数中自动关闭文件。</li><li>RAII 避免了手动释放资源的复杂性，提高了代码的安全性。</li></ul><p><strong>GC（垃圾回收）</strong></p><p><strong>GC（Garbage Collection）</strong> 是 Java 等语言中自动内存管理的一种机制：</p><ul><li>通过自动检测不再使用的对象来释放内存。</li><li><strong>优点</strong>：程序员无需手动管理内存。</li><li>缺点：<ul><li>效率较低。</li><li>不适用于需要精确控制资源释放的场景。</li></ul></li></ul><p><strong>PPT中的对比</strong>：</p><ul><li><strong>C++：RAII</strong>，程序员可以手动控制资源的获取与释放。</li><li><strong>Java：GC</strong>，通过 <code>finalize()</code> 等机制自动进行垃圾回收。</li></ul><hr><p><strong>5. Better Solution：避免 <code>delete this</code> 带来的风险</strong></p><p>PPT 提供了一种更好的解决方案：通过<strong>静态方法</strong>来释放堆上分配的对象。</p><p><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">free</span><span class="params">(A *p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> p;  <span class="comment">// 释放对象</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;&#125;  <span class="comment">// 私有析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A *p = <span class="keyword">new</span> <span class="built_in">A</span>();    <span class="comment">// 在堆上创建对象</span></span><br><span class="line">    A::<span class="built_in">free</span>(p);        <span class="comment">// 使用静态方法释放对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>：</p><ul><li>析构函数是私有的，禁止外部直接使用 <code>delete</code>。</li><li>提供了一个 <code>free()</code> 静态方法来释放对象，确保对象的释放安全可控。</li><li>避免了 <code>delete this;</code> 可能导致的未定义行为。</li></ul><img src="/2025/01/25/CPP-2-1/image-20241218204406784.png" class="" title="image-20241218204406784"><h2 id="拷贝构造函数">拷贝构造函数</h2><img src="/2025/01/25/CPP-2-1/image-20241218204525826.png" class="" title="image-20241218204525826"><p><strong>1. 拷贝构造函数的定义</strong></p><p><strong>拷贝构造函数</strong>（Copy Constructor）用于<strong>创建新对象</strong>时，用<strong>同一类的另一个对象</strong>来对新对象进行初始化。</p><p><strong>基本语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ClassName</span>(<span class="type">const</span> ClassName&amp; other);</span><br></pre></td></tr></table></figure><ul><li><strong><code>const ClassName&amp;</code></strong>：参数必须是引用类型，通常加 <code>const</code>，以避免不必要的修改和无限递归调用。</li><li><strong>自动调用</strong>：在某些情况下系统会自动调用拷贝构造函数。</li></ul><p><strong>2. 拷贝构造函数的调用时机</strong></p><p>拷贝构造函数会在以下几种情况下自动调用：</p><ol><li><p><strong>用一个对象初始化另一个对象时</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a;          <span class="comment">// 调用默认构造函数</span></span><br><span class="line">A b = a;      <span class="comment">// 调用拷贝构造函数</span></span><br></pre></td></tr></table></figure></li><li><p><strong>对象作为函数参数传递时（值传递）</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(A a)</span></span>;  <span class="comment">// 形参是A类型对象，会调用拷贝构造函数</span></span><br><span class="line">A obj;</span><br><span class="line"><span class="built_in">f</span>(obj);       <span class="comment">// 传递对象时调用拷贝构造函数</span></span><br></pre></td></tr></table></figure></li><li><p><strong>对象作为函数返回值时（值返回）</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">return</span> a;  <span class="comment">// 返回局部对象时调用拷贝构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A obj = <span class="built_in">f</span>();</span><br></pre></td></tr></table></figure></li><li><p><strong>对象被显式拷贝时</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A obj1;</span><br><span class="line"><span class="function">A <span class="title">obj2</span><span class="params">(obj1)</span></span>;  <span class="comment">// 调用拷贝构造函数</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>3. 拷贝构造函数的默认实现</strong></p><p>如果用户<strong>没有显式定义</strong>拷贝构造函数，编译器会提供一个<strong>默认拷贝构造函数</strong>。</p><p><strong>默认拷贝构造函数的行为</strong></p><ul><li><strong>逐个成员拷贝</strong>：默认拷贝构造函数会对对象的每个成员执行<strong>逐个拷贝</strong>（Member-wise Initialization）。</li><li><strong>浅拷贝</strong>：对于指针成员，默认拷贝构造函数只会拷贝指针的地址，而不会分配新的内存空间。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *p) &#123;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(p) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认拷贝构造函数（浅拷贝）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">String</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] str;  <span class="comment">// 释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    String s2 = s1;  <span class="comment">// 调用默认拷贝构造函数（浅拷贝）</span></span><br><span class="line"></span><br><span class="line">    s<span class="number">1.</span><span class="built_in">display</span>();</span><br><span class="line">    s<span class="number">2.</span><span class="built_in">display</span>();  <span class="comment">// 问题：s1 和 s2 指向同一块内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出（可能导致问题）：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure><p><strong>问题分析</strong></p><ul><li>默认拷贝构造函数进行的是<strong>浅拷贝</strong>，导致两个对象的 <code>str</code> 指针指向同一块内存。</li><li>当 <code>s1</code> 和 <code>s2</code> 析构时，会释放同一块内存，造成<strong>重复释放</strong>（Undefined Behavior）。</li></ul><p><strong>4. 深拷贝的解决方案</strong></p><p>为了解决浅拷贝问题，我们需要<strong>自定义拷贝构造函数</strong>，实现<strong>深拷贝</strong>。</p><p><strong>示例：实现深拷贝</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 带参数的构造函数</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *p) &#123;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(p) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义拷贝构造函数：实现深拷贝</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String &amp;other) &#123;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.str) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str, other.str);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copy Constructor Called&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">String</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] str;  <span class="comment">// 释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    String s2 = s1;  <span class="comment">// 调用自定义拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">    s<span class="number">1.</span><span class="built_in">display</span>();</span><br><span class="line">    s<span class="number">2.</span><span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copy Constructor Called</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure><p><strong>解释</strong></p><ul><li>自定义拷贝构造函数分配新的内存空间，确保 <code>s1</code> 和 <code>s2</code> 拥有独立的内存。</li><li>避免了浅拷贝导致的重复释放问题。</li></ul><p><strong>5. 拷贝构造函数 = <code>delete</code></strong></p><p>PPT中的 <code>A(const A&amp; a) = delete;</code> 是C++11引入的新特性，表示<strong>禁止使用拷贝构造函数</strong>。</p><p><strong>用途</strong></p><ul><li>禁止对象被拷贝，防止不期望的拷贝操作。</li><li>常用于管理资源的类，如单例模式。</li></ul><p><strong>示例：禁止拷贝构造</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; a) = <span class="keyword">delete</span>;  <span class="comment">// 禁止拷贝构造</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Object A&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="comment">// A b = a;  // 错误！拷贝构造被删除</span></span><br><span class="line">    a.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：编译错误</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: use of deleted function ‘A::A(const A&amp;)’</span><br></pre></td></tr></table></figure><img src="/2025/01/25/CPP-2-1/image-20241218205133125.png" class="" title="image-20241218205133125"><ul><li>左边是浅拷贝，容易出现悬挂指针</li><li>右边则是重写了拷贝构造，是深拷贝</li></ul><img src="/2025/01/25/CPP-2-1/image-20241218205457637.png" class="" title="image-20241218205457637"><p><strong>1. 默认拷贝构造函数</strong></p><p><strong>默认拷贝构造函数</strong>是由编译器自动生成的拷贝构造函数，其行为是<strong>逐个成员拷贝</strong>（<strong>Member-wise Initialization</strong>）。</p><p><strong>代码示例：包含成员对象的类</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; x = y = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123; x++; y++; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">    A a;  <span class="comment">// 成员对象</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123; z = <span class="number">0</span>; &#125;  <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">B</span>(<span class="type">const</span> B&amp; b) : <span class="built_in">a</span>(b.a) &#123; z = b.z; &#125;  <span class="comment">// 自定义拷贝构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123; z++; a.<span class="built_in">inc</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：</p><ol><li><p><strong><code>class A</code></strong>：</p><ul><li>拥有默认构造函数 <code>A()</code> 和成员函数 <code>inc()</code>。</li></ul></li><li><p><strong><code>class B</code></strong>：</p><ul><li><p>包含 <code>A</code> 类型的成员对象 <code>a</code> 和整型变量 <code>z</code>。</p></li><li><p>自定义拷贝构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">B</span>(<span class="type">const</span> B&amp; b) : <span class="built_in">a</span>(b.a) &#123; z = b.z; &#125;</span><br></pre></td></tr></table></figure><ul><li><code>: a(b.a)</code> 调用了 <code>A</code> 类的<strong>拷贝构造函数</strong>来初始化成员对象 <code>a</code>。</li><li>逐个拷贝成员变量 <code>z</code>。</li></ul></li></ul></li><li><p><strong>默认拷贝构造函数的行为</strong>：</p><ul><li>如果未提供自定义拷贝构造函数，编译器会提供一个<strong>默认拷贝构造函数</strong>，对每个成员执行逐个拷贝。</li></ul></li></ol><hr><p><strong>执行示例与结果</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B b1;     <span class="comment">// 调用默认构造函数</span></span><br><span class="line">b<span class="number">1.</span><span class="built_in">inc</span>(); <span class="comment">// 修改 b1 的成员值</span></span><br><span class="line"></span><br><span class="line"><span class="function">B <span class="title">b2</span><span class="params">(b1)</span></span>; <span class="comment">// 调用拷贝构造函数</span></span><br></pre></td></tr></table></figure><p><strong>内存状态变化</strong>：</p><ul><li>b1 初始状态：<ul><li><code>b1.z = 0, b1.a.x = 0, b1.a.y = 0</code></li></ul></li><li>b1 调用 <code>inc()</code> 后：<ul><li><code>b1.z = 1, b1.a.x = 1, b1.a.y = 1</code></li></ul></li><li>b2 通过拷贝构造函数初始化：<ul><li><code>b2.z = 1</code>（拷贝 <code>b1.z</code>）</li><li><code>b2.a</code>使用 <code>A</code>的默认拷贝构造函数，拷贝 <code>b1.a</code>的成员值：<ul><li><code>b2.a.x = 1, b2.a.y = 1</code></li></ul></li></ul></li></ul><p><strong>输出注释</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b1.z = b1.a.x = b1.a.y = 1</span></span><br><span class="line"><span class="comment">// b2.z = 1, b2.a.x = 1, b2.a.y = 1</span></span><br></pre></td></tr></table></figure><p><strong>2. 自定义拷贝构造函数</strong></p><p>当类中包含成员对象时，拷贝构造函数需要显式调用成员对象的拷贝构造函数，否则会使用默认拷贝行为。</p><p><strong>关键语法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">B</span>(<span class="type">const</span> B&amp; b) : <span class="built_in">a</span>(b.a) &#123; z = b.z; &#125;</span><br></pre></td></tr></table></figure><p><strong>含义</strong>：</p><ul><li><code>: a(b.a)</code>：<ul><li>显式调用 <code>A</code> 类的拷贝构造函数来初始化成员对象 <code>a</code>。</li></ul></li><li><code>z = b.z;</code>：<ul><li>拷贝整型成员 <code>z</code> 的值。</li></ul></li></ul><h2 id="移动构造函数">移动构造函数</h2><img src="/2025/01/25/CPP-2-1/image-20241219112842361.png" class="" title="image-20241219112842361"><p><strong>1. 什么是移动构造函数？</strong></p><p><strong>移动构造函数</strong>是C++11引入的一种特殊构造函数，用于通过**“转移资源”<strong>而不是</strong>拷贝资源<strong>来初始化对象，从而提升效率。移动构造函数主要用于</strong>右值对象**的处理。</p><p><strong>定义形式</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ClassName</span>(ClassName&amp;&amp; other);</span><br></pre></td></tr></table></figure><ul><li>参数为<strong>右值引用</strong>（<code>ClassName&amp;&amp;</code>）。</li><li>用于接收临时对象或右值，并通过“转移”资源的所有权而非拷贝资源来初始化新对象。</li></ul><p><strong>2. 移动构造函数的实现</strong></p><p><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="type">char</span>* p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* str) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(p, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">String</span>(String&amp;&amp; s) : <span class="built_in">p</span>(s.p) &#123;</span><br><span class="line">        s.p = <span class="literal">nullptr</span>;  <span class="comment">// 使源对象指针置为空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">String</span>() &#123; <span class="keyword">delete</span>[] p; &#125;  <span class="comment">// 析构函数释放资源</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p)</span><br><span class="line">            std::cout &lt;&lt; p &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Empty string&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">s1</span><span class="params">(<span class="string">&quot;test&quot;</span>)</span></span>;         <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    String s2 = std::<span class="built_in">move</span>(s1); <span class="comment">// 调用移动构造函数</span></span><br><span class="line"></span><br><span class="line">    s<span class="number">1.</span><span class="built_in">display</span>();  <span class="comment">// 输出：Empty string</span></span><br><span class="line">    s<span class="number">2.</span><span class="built_in">display</span>();  <span class="comment">// 输出：test</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Empty string</span><br><span class="line">test</span><br></pre></td></tr></table></figure><p><strong>执行流程</strong></p><ol><li>普通构造函数：<ul><li><code>s1</code> 的构造函数动态分配内存并初始化为 <code>&quot;test&quot;</code>。</li></ul></li><li>移动构造函数：<ul><li><code>s2</code> 调用移动构造函数，直接转移了 <code>s1</code> 的内存地址 <code>p</code>。</li><li>将 <code>s1.p</code> 置为 <code>nullptr</code>，避免重复释放资源。</li></ul></li><li>析构函数：<ul><li><code>s1</code> 的析构函数释放 <code>nullptr</code>（无操作）。</li><li><code>s2</code> 的析构函数释放动态分配的内存 <code>&quot;test&quot;</code>。</li></ul></li></ol><p><strong>3. 为什么需要移动构造函数？</strong></p><ol><li><strong>避免不必要的深拷贝</strong>：<ul><li>普通拷贝构造函数需要分配新的内存，并拷贝原对象的数据。</li><li>移动构造函数直接转移资源，避免了内存分配和拷贝操作。</li></ul></li><li><strong>处理右值对象</strong>：<ul><li>临时对象（右值）本身没有持久化需求，可以直接转移其资源。</li></ul></li><li><strong>提升性能</strong>：<ul><li>移动构造函数避免了深拷贝操作，大幅提升性能，特别是在处理<strong>动态内存分配</strong>和<strong>容器扩容</strong>时。</li></ul></li></ol><p><strong>4. PPT中涉及的知识点</strong></p><p><strong>（1）右值与右值引用</strong></p><ul><li>右值：表达式的临时值，没有明确的变量名。<ul><li>例如：<code>5</code>、<code>x + 2</code>、<code>string(&quot;test&quot;)</code>。</li></ul></li><li><strong>右值引用</strong>：<code>T&amp;&amp;</code> 用于绑定右值，用于区分<strong>左值</strong>和<strong>右值</strong>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;       <span class="comment">// x 是左值</span></span><br><span class="line"><span class="type">int</span>&amp; y = x;      <span class="comment">// 左值引用</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; z = <span class="number">5</span>;     <span class="comment">// 右值引用，只能绑定右值</span></span><br></pre></td></tr></table></figure><p><strong>（2）移动构造函数的调用场景</strong></p><p>==<strong>返回值优化</strong>==？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">generate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;test&quot;</span>);  <span class="comment">// 返回临时对象（右值）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string s = <span class="built_in">generate</span>();  <span class="comment">// 调用移动构造函数</span></span><br></pre></td></tr></table></figure><ul><li><code>generate()</code> 返回临时对象 <code>string(&quot;test&quot;)</code>，是右值。</li><li>移动构造函数通过“转移资源”而不是“深拷贝”来初始化对象 <code>s</code>。</li></ul><p><strong>容器扩容</strong></p><p>在标准容器（如 <code>std::vector</code>）中，元素的移动构造可以大幅提升扩容性能。</p><p><strong>（3）std::move</strong></p><p><strong>std::move 的作用</strong></p><ul><li>将左值<strong>显式转换为右值</strong>，以触发移动构造函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">s1</span><span class="params">(<span class="string">&quot;test&quot;</span>)</span></span>;</span><br><span class="line">String s2 = std::<span class="built_in">move</span>(s1);  <span class="comment">// 调用移动构造函数</span></span><br></pre></td></tr></table></figure><ul><li><code>std::move(s1)</code> 将 <code>s1</code> 转换为右值，使 <code>s2</code> 调用移动构造函数。</li></ul><p><strong>（4）const 引用绑定右值</strong></p><p>PPT中提到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> string&amp; name = <span class="built_in">generate</span>(); <span class="comment">// OK</span></span><br><span class="line">string&amp;&amp; name = <span class="built_in">generate</span>();      <span class="comment">// Also OK</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>const string&amp;</code></strong>：<ul><li>可以绑定右值和左值，常用于只读操作。</li><li><code>generate()</code> 返回右值，<code>const string&amp;</code> 绑定右值是合法的。</li></ul></li><li><strong><code>string&amp;&amp;</code></strong>：<ul><li>专门绑定右值。</li><li>适合需要修改右值或通过移动构造函数优化性能的场景。</li></ul></li></ul><p><strong>（5）函数的右值引用参数</strong></p><p>PPT中涉及到的函数原型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; r)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>右值引用参数的意义</strong></p><ul><li>接收右值，避免不必要的拷贝。</li><li>结合 <code>std::move</code>，可以将左值转为右值，触发移动构造函数或移动赋值操作。</li></ul><p><strong><code>const string&amp;</code> 和 <code>string&amp;</code> 是否可以绑定右值？</strong></p><p><strong>1. 左值、右值与引用的基础概念</strong></p><ul><li><strong>左值（Lvalue）</strong>：有名字的、可以取地址的对象。<ul><li>例如：<code>int x = 5;</code> 中的 <code>x</code> 是左值。</li></ul></li><li><strong>右值（Rvalue）</strong>：没有名字、不能直接取地址的临时值。<ul><li>例如：<code>5</code>、<code>x + 1</code> 是右值。</li></ul></li><li><strong>左值引用（<code>T&amp;</code>）</strong>：只能绑定到左值。</li><li><strong>右值引用（<code>T&amp;&amp;</code>）</strong>：只能绑定到右值。</li></ul><p><strong>2. <code>const string&amp;</code> 可以绑定右值</strong></p><p>是的，<code>const string&amp;</code> <strong>可以绑定右值</strong>。</p><p><strong>原因</strong></p><p><code>const</code> 修饰的左值引用可以绑定到<strong>临时对象（右值）</strong>，以延长临时对象的生命周期，直到引用离开作用域。</p><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> string&amp; ref = <span class="built_in">string</span>(<span class="string">&quot;Hello, World!&quot;</span>);  <span class="comment">// 右值绑定到 const 左值引用</span></span><br><span class="line">    cout &lt;&lt; ref &lt;&lt; endl;  <span class="comment">// 输出：Hello, World!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行过程</strong></p><ol><li><code>string(&quot;Hello, World!&quot;)</code> 是一个临时对象（右值）。</li><li>使用 <code>const string&amp;</code> 引用绑定该右值。</li><li>临时对象的生命周期被延长，直到引用 <code>ref</code> 离开作用域。</li></ol><p><strong>限制：为什么需要 <code>const</code>？</strong></p><p>如果不加 <code>const</code>，编译器不允许绑定右值，因为右值表示的是临时对象，可能会被销毁。而非 <code>const</code> 引用允许修改被引用的对象，无法保证临时对象的安全。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string&amp; ref = <span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>);  <span class="comment">// 错误：非 const 左值引用不能绑定右值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>错误信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: invalid initialization of non-const reference of type &#x27;string&amp;&#x27; from an rvalue of type &#x27;string&#x27;</span><br></pre></td></tr></table></figure><p><strong>3. <code>string&amp;</code> 不能绑定右值</strong></p><p>非 <code>const</code> 左值引用（<code>string&amp;</code>）只能绑定到左值，不能绑定右值。</p><p><strong>原因</strong></p><ul><li>右值是一个临时对象，可能会被销毁。</li><li>非 <code>const</code> 引用允许修改被引用的对象，但修改右值是无意义的（因为右值即将被销毁）。</li></ul><p><strong>4. 右值引用（<code>string&amp;&amp;</code>）可以绑定右值</strong></p><p>为了解决右值绑定的问题，C++11 引入了<strong>右值引用（<code>T&amp;&amp;</code>）</strong>，它专门用于绑定右值。</p><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string&amp;&amp; rref = <span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>);  <span class="comment">// 右值引用绑定右值</span></span><br><span class="line">    rref += <span class="string">&quot;, World!&quot;</span>;               <span class="comment">// 允许修改右值</span></span><br><span class="line">    cout &lt;&lt; rref &lt;&lt; endl;             <span class="comment">// 输出：Hello, World!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行过程</strong></p><ol><li>临时对象 <code>string(&quot;Hello&quot;)</code> 是右值，可以绑定到右值引用 <code>string&amp;&amp; rref</code>。</li><li><strong>可以对右值引用 <code>rref</code> 进行修改，因为右值引用拥有右值的所有权</strong>。</li><li>临时对象的生命周期被延长，直到引用离开作用域。</li></ol><p><strong>5. 总结</strong></p><table><thead><tr><th>类型</th><th>是否可以绑定左值</th><th>是否可以绑定右值</th></tr></thead><tbody><tr><td><code>T&amp;</code>（左值引用）</td><td>✅ 可以</td><td>❌ 不可以</td></tr><tr><td><code>const T&amp;</code>（常量左值引用）</td><td>✅ 可以</td><td>✅ 可以</td></tr><tr><td><code>T&amp;&amp;</code>（右值引用）</td><td>❌ 不可以</td><td>✅ 可以</td></tr></tbody></table><p><strong>总结规则</strong></p><ol><li><strong><code>const T&amp;</code> 可以绑定右值</strong>，临时对象的生命周期会被延长到引用的作用域结束。</li><li><strong><code>T&amp;</code> 不能绑定右值</strong>，只能绑定左值。</li><li><strong><code>T&amp;&amp;</code> 专门用于绑定右值</strong>，适用于移动语义和右值优化。</li></ol><h2 id="动态内存">动态内存</h2><img src="/2025/01/25/CPP-2-1/image-20241219113715537.png" class="" title="image-20241219113715537"><p><strong>1. 操作系统中的内存分区</strong></p><p>操作系统提供两种主要的内存分配区域：<strong>栈（Stack）</strong> 和 <strong>堆（Heap）</strong>，它们用于不同类型的内存管理。</p><p><strong>栈（Stack）</strong></p><ul><li><p><strong>特点</strong>：</p><ul><li>栈内存用于存储<strong>局部变量</strong>和<strong>按值传递的函数参数</strong>。</li><li>分配和释放由编译器自动完成。</li><li>内存分配速度快，但容量有限。</li></ul></li><li><p><strong>应用</strong>：</p><ul><li><p>局部变量，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;  <span class="comment">// 存储在栈中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数参数（按值传递时）。</p></li></ul></li><li><p><strong>栈的特性</strong>：</p><ul><li><strong>后进先出（LIFO）</strong>：内存分配按调用顺序进行，函数结束时自动回收。</li></ul></li></ul><p><strong>堆（Heap）</strong></p><ul><li><p>特点：</p><ul><li>堆内存用于动态分配内存。</li><li>开发者通过<strong>显式操作</strong>分配和释放内存。</li><li>容量大，但分配速度相对较慢。</li></ul></li><li><p>应用：</p><ul><li><p>动态分配的大对象或数据结构，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>];  <span class="comment">// 在堆中分配100个整数的数组</span></span><br></pre></td></tr></table></figure></li><li><p>堆内存需要开发者<strong>手动释放</strong>，否则会导致<strong>内存泄漏</strong>。</p></li></ul></li></ul><p><strong>2. C语言中的动态内存</strong></p><p>C语言通过以下函数实现动态内存管理：</p><p><strong>malloc()</strong></p><ul><li><p><strong>用途</strong>：从堆中分配指定大小的内存，返回一块未初始化的内存地址。</p></li><li><p>原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure></li><li><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 分配5个整数的空间</span></span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>free()</strong></p><ul><li><p><strong>用途</strong>：释放由 <code>malloc()</code> 分配的内存。</p></li><li><p>原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span>* ptr)</span>;</span><br></pre></td></tr></table></figure></li><li><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(ptr);  <span class="comment">// 释放动态分配的内存</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>注意事项</strong></p><ol><li>必须匹配 <code>malloc()</code> 和 <code>free()</code>，否则会导致<strong>内存泄漏</strong>。</li><li>释放后，不要再使用该指针（悬挂指针问题）。</li></ol><p><strong>3. C++中的动态内存</strong></p><p>C++ 提供了更高级的动态内存管理方式：<strong><code>new</code></strong> 和 <strong><code>delete</code></strong>。</p><p><strong>new</strong></p><ul><li><p><strong>用途</strong>：从堆中分配内存，并初始化对象。</p></li><li><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T* ptr = <span class="keyword">new</span> T;            <span class="comment">// 为单个对象分配内存</span></span><br><span class="line">T* ptr = <span class="keyword">new</span> T[size];      <span class="comment">// 为数组分配内存</span></span><br></pre></td></tr></table></figure></li><li><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>;          <span class="comment">// 分配一个整数</span></span><br><span class="line">*p = <span class="number">10</span>;                   <span class="comment">// 初始化为10</span></span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];     <span class="comment">// 分配一个整数数组</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>delete</strong></p><ul><li><p><strong>用途</strong>：释放由 <code>new</code> 分配的内存。</p></li><li><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> ptr;                <span class="comment">// 释放单个对象</span></span><br><span class="line"><span class="keyword">delete</span>[] ptr;              <span class="comment">// 释放数组</span></span><br></pre></td></tr></table></figure></li><li><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p;                  <span class="comment">// 释放单个整数</span></span><br><span class="line"><span class="keyword">delete</span>[] arr;              <span class="comment">// 释放整数数组</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>注意事项</strong></p><ol><li>必须匹配 <code>new</code> 和 <code>delete</code>。</li><li>使用 <code>delete</code> 释放动态分配的对象后，最好将指针置为 <code>nullptr</code>，避免悬挂指针问题。</li></ol><p><strong>C++中的动态内存 vs C语言</strong></p><table><thead><tr><th>特性</th><th>C语言</th><th>C++</th></tr></thead><tbody><tr><td>分配函数</td><td><code>malloc()</code></td><td><code>new</code></td></tr><tr><td>释放函数</td><td><code>free()</code></td><td><code>delete</code> / <code>delete[]</code></td></tr><tr><td>是否需要强制转换</td><td>是</td><td>否</td></tr><tr><td>是否支持对象构造与析构</td><td>否</td><td>是</td></tr></tbody></table><p><strong>4. 示例代码：C++动态内存管理</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 动态分配一个整数</span></span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    *p = <span class="number">42</span>;  <span class="comment">// 初始化</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态分配一个数组</span></span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        arr[i] = i * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;arr[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放动态内存</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Value: 42</span><br><span class="line">arr[0] = 0</span><br><span class="line">arr[1] = 10</span><br><span class="line">arr[2] = 20</span><br><span class="line">arr[3] = 30</span><br><span class="line">arr[4] = 40</span><br></pre></td></tr></table></figure><p><strong>5. 常见问题</strong></p><p><strong>（1）内存泄漏</strong></p><ul><li><p>动态分配的内存如果未被释放，会造成<strong>内存泄漏</strong>。</p></li><li><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">p = <span class="literal">nullptr</span>;  <span class="comment">// 原来的内存未释放，泄漏</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>（2）悬挂指针</strong></p><ul><li><p>动态分配的内存被释放后，指针仍然指向该内存，称为<strong>悬挂指针</strong>。</p></li><li><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">*p = <span class="number">42</span>;  <span class="comment">// 悬挂指针，未定义行为</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>6. 总结</strong></p><p><strong>操作系统的内存分区</strong></p><ol><li><strong>栈（Stack）</strong>：用于局部变量和函数参数，自动管理。</li><li><strong>堆（Heap）</strong>：用于动态分配内存，开发者手动管理。</li></ol><p><strong>C语言动态内存</strong></p><ul><li><code>malloc()</code>：分配动态内存。</li><li><code>free()</code>：释放动态内存。</li></ul><p><strong>C++动态内存</strong></p><ul><li><code>new</code>：分配动态内存，并自动调用构造函数。</li><li><code>delete</code>：释放动态内存，并自动调用析构函数。</li></ul><h2 id="动态对象">动态对象</h2><img src="/2025/01/25/CPP-2-1/image-20241219114254387.png" class="" title="image-20241219114254387"><p><strong>1. 动态对象是什么？</strong></p><p>动态对象是通过<strong>动态内存分配</strong>在**堆（Heap）**中创建的对象。与局部变量或静态对象不同，动态对象的生命周期完全由开发者控制，需要显式分配和释放内存。</p><p><strong>动态对象的特点</strong></p><ol><li><strong>在堆中分配</strong>：<ul><li>使用 <code>new</code> 操作符为对象分配内存。</li><li>与栈上对象相比，动态对象的生命周期不会随函数退出而自动销毁。</li></ul></li><li><strong>显式释放内存</strong>：<ul><li>使用 <code>delete</code> 操作符释放动态分配的内存。</li><li>如果不释放，会导致内存泄漏。</li></ul></li></ol><p><strong>2. 为什么需要 <code>new</code> 和 <code>delete</code> 操作符？</strong></p><p>在 C++ 中，<code>new</code> 和 <code>delete</code> 的引入是为了解决以下问题：</p><p><strong>（1）动态分配内存，构造和析构自动调用</strong></p><ul><li>C++ 中的类通常需要构造函数和析构函数来完成对象的初始化和销毁。</li><li><strong><code>new</code> 和 <code>delete</code></strong> 不仅用于动态分配和释放内存，还会自动调用类的构造函数和析构函数。</li></ul><p><strong>示例：动态对象的构造与析构</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>() &#123; cout &lt;&lt; <span class="string">&quot;Constructor called!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">Example</span>() &#123; cout &lt;&lt; <span class="string">&quot;Destructor called!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Example* obj = <span class="keyword">new</span> Example;  <span class="comment">// 动态分配对象，并调用构造函数</span></span><br><span class="line">    <span class="keyword">delete</span> obj;                  <span class="comment">// 释放对象，并调用析构函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor called!</span><br><span class="line">Destructor called!</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><ol><li><pre><code>new Example<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   ：</span><br><span class="line"></span><br><span class="line">   - 在堆上分配内存，并调用 `Example` 的构造函数。</span><br><span class="line"></span><br><span class="line">2. ```</span><br><span class="line">   delete obj</span><br></pre></td></tr></table></figure>：- 调用对象的析构函数，然后释放内存。</code></pre></li></ol><p><strong>（2）与 C 的 <code>malloc()</code> 和 <code>free()</code> 的区别</strong></p><p>在 C 中，<code>malloc()</code> 和 <code>free()</code> 只能分配和释放内存，但无法调用构造函数和析构函数。C++ 的 <code>new</code> 和 <code>delete</code> 是 <code>malloc()</code> 和 <code>free()</code> 的改进版本，适用于面向对象的内存管理。</p><p><strong>对比表</strong></p><table><thead><tr><th>特性</th><th><code>malloc()</code> / <code>free()</code></th><th><code>new</code> / <code>delete</code></th></tr></thead><tbody><tr><td>内存分配</td><td>手动分配，返回 <code>void*</code></td><td>自动分配，返回正确类型</td></tr><tr><td>类型安全</td><td>❌ 需要强制转换</td><td>✅ 不需要强制转换</td></tr><tr><td>构造函数/析构函数调用</td><td>❌ 不支持</td><td>✅ 自动调用</td></tr></tbody></table><p><strong>（3）管理动态内存的灵活性</strong></p><ol><li>堆上的对象可以在函数结束后继续存在，适用于需要跨函数使用的对象。</li><li>在运行时动态创建对象，适合处理未知大小的数据结构，例如链表、树等。</li></ol><img src="/2025/01/25/CPP-2-1/image-20241219114637371.png" class="" title="image-20241219114637371"><img src="/2025/01/25/CPP-2-1/image-20241219114732640.png" class="" title="image-20241219114732640"><p><strong>1. <code>new</code> 操作符的基本概念</strong></p><p><strong><code>new</code> 的作用</strong></p><ul><li><code>new</code> 是 C++ 中用于动态分配内存的操作符。</li><li>可以用于创建<strong>基本类型</strong>（如 <code>int</code>、<code>float</code> 等）和<strong>类对象</strong>。</li><li>动态分配的内存位于堆（heap）中，而不是栈（stack）。</li></ul><p><strong>2. <code>new</code> 的用法</strong></p><p><strong>语法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type* ptrName = <span class="keyword">new</span> type;                <span class="comment">// 调用默认构造函数</span></span><br><span class="line">type* ptrName = <span class="keyword">new</span> <span class="built_in">type</span>(params);       <span class="comment">// 调用带参数构造函数</span></span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><ol><li><code>type*</code>：<ul><li>表示返回的指针类型。</li><li>动态分配的内存地址会存储在 <code>ptrName</code> 中。</li></ul></li><li><code>new type</code>：<ul><li>在堆中分配 <code>sizeof(type)</code> 大小的内存，并调用 <code>type</code> 的默认构造函数。</li></ul></li><li><code>new type(params)</code>：<ul><li>调用 <code>type</code> 的带参数构造函数进行初始化。</li></ul></li></ol><p><strong>3. 使用 <code>new</code> 创建对象</strong></p><p><strong>（1）创建基本类型的动态对象</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>;         <span class="comment">// 动态分配内存，未初始化</span></span><br><span class="line">    *p = <span class="number">42</span>;                  <span class="comment">// 手动初始化</span></span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;       <span class="comment">// 输出：42</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> p;                 <span class="comment">// 释放动态内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">42</span><br></pre></td></tr></table></figure><p><strong>（2）创建类对象的动态对象</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>() &#123; cout &lt;&lt; <span class="string">&quot;Default Constructor Called&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">int</span> x) &#123; cout &lt;&lt; <span class="string">&quot;Parameterized Constructor Called with &quot;</span> &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">Example</span>() &#123; cout &lt;&lt; <span class="string">&quot;Destructor Called&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Example* obj1 = <span class="keyword">new</span> Example;        <span class="comment">// 调用默认构造函数</span></span><br><span class="line">    Example* obj2 = <span class="keyword">new</span> <span class="built_in">Example</span>(<span class="number">10</span>);    <span class="comment">// 调用带参数构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> obj1;  <span class="comment">// 调用析构函数并释放内存</span></span><br><span class="line">    <span class="keyword">delete</span> obj2;  <span class="comment">// 调用析构函数并释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Default Constructor Called</span><br><span class="line">Parameterized Constructor Called with 10</span><br><span class="line">Destructor Called</span><br><span class="line">Destructor Called</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p><strong><code>new</code> 的特点</strong></p><ol><li>用于动态分配内存，支持基本类型和类对象。</li><li>对于类对象，会自动调用构造函数完成初始化。</li></ol><p><strong><code>delete</code> 的特点</strong></p><ol><li>用于释放动态分配的内存。</li><li>对于类对象，会自动调用析构函数完成清理。</li></ol><p><strong>语法对比</strong></p><table><thead><tr><th>操作</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>创建单个对象</td><td><code>int* p = new int(42);</code></td><td>动态分配一个整数，初始化为 42</td></tr><tr><td>创建类对象</td><td><code>Example* obj = new Example(10);</code></td><td>动态分配类对象，调用构造函数</td></tr><tr><td>释放单个对象</td><td><code>delete p;</code></td><td>调用析构函数并释放内存</td></tr></tbody></table><img src="/2025/01/25/CPP-2-1/image-20241219184925693.png" class="" title="image-20241219184925693"><p><strong>1. 动态分配的关键点</strong></p><p><strong>动态对象是匿名的</strong></p><ul><li>使用 <code>new</code> 操作符动态分配的对象<strong>没有名字</strong>，只能通过指针访问。</li><li>指针保存的是动态分配对象的地址，指针本身有名字（例如：<code>intPtr</code>、<code>carPtr</code>），但动态分配的内存没有直接的标识符。</li></ul><p><strong>指针大小与数据大小无关</strong></p><ul><li>无论动态分配的对象有多大，指针的大小在同一系统中是固定的（通常是 4 字节或 8 字节，取决于系统的架构）。</li></ul><p><strong>2. PPT中的注意事项</strong></p><p><strong>（1）动态分配对象是匿名的</strong></p><ul><li><p>动态分配的对象没有名字，只能通过指针访问。</p></li><li><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Car* carPtr = <span class="keyword">new</span> <span class="built_in">Car</span>(<span class="string">&quot;Nissan&quot;</span>, <span class="string">&quot;Pulsar&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><code>carPtr</code> 是指针变量的名字。</li><li>动态分配的 <code>Car</code> 对象在堆中，没有直接的名字。</li></ul></li></ul><p><strong>（2）指针大小与对象大小无关</strong></p><ul><li>在 32 位系统中，所有指针占用 4 字节。</li><li>在 64 位系统中，所有指针占用 8 字节。</li><li>动态分配的对象大小与指针大小无关：<ul><li>例如，<code>int</code> 占用 4 字节，<code>Car</code> 类可能占用几十字节，但指向它们的指针大小固定。</li></ul></li></ul><p><strong>3. 动态分配的生命周期</strong></p><ol><li><p>动态分配的对象存在于堆中：</p><ul><li>由 <code>new</code> 分配的内存不受作用域限制，必须显式释放。</li></ul></li><li><p>销毁时调用析构函数：</p><ul><li><p>使用 <code>delete</code> 释放动态对象时，会自动调用析构函数。</p></li><li><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> carPtr;  <span class="comment">// 调用 carPtr 指向对象的析构函数</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>总结</strong></p><p><strong>动态分配的核心特点</strong></p><ol><li>使用 <code>new</code> 动态分配内存，并返回对象地址。</li><li>动态对象是匿名的，只能通过指针访问。</li><li>指针大小固定，与动态分配对象的大小无关。</li><li>必须使用 <code>delete</code> 显式释放动态分配的内存。</li></ol><img src="/2025/01/25/CPP-2-1/image-20241219185630315.png" class="" title="image-20241219185630315"><ul><li><p><code>malloc</code> 仅分配原始的内存空间，但不会初始化对象。</p></li><li><p><code>free</code> 只释放内存，但不会调用析构函数。</p></li></ul><img src="/2025/01/25/CPP-2-1/image-20241219193944689.png" class="" title="image-20241219193944689"><p><code>delete</code> 是 C++ 中用于释放动态分配的内存的操作符。它既可以用于<strong>基本数据类型</strong>的动态内存，也可以用于<strong>类对象</strong>的动态内存。</p><p><strong>特点</strong></p><ol><li><strong>调用析构函数</strong>（如果是类对象）。</li><li>释放内存：<ul><li>释放动态分配的堆内存，使得这块内存可以被重新分配。</li></ul></li><li>防止内存泄漏：<ul><li>通过释放不再使用的内存，避免程序长期运行时耗尽内存。</li></ul></li></ol><img src="/2025/01/25/CPP-2-1/image-20241219194159145.png" class="" title="image-20241219194159145"><img src="/2025/01/25/CPP-2-1/image-20241219195349924.png" class="" title="image-20241219195349924"><img src="/2025/01/25/CPP-2-1/image-20241219195417202.png" class="" title="image-20241219195417202"><h2 id="const成员">const成员</h2><img src="/2025/01/25/CPP-2-1/image-20241219195517779.png" class="" title="image-20241219195517779"><img src="/2025/01/25/CPP-2-1/image-20241219195533209.png" class="" title="image-20241219195533209"><p><strong>1. <code>const</code> 成员的核心概念</strong></p><p><strong>（1）什么是 <code>const</code> 成员？</strong></p><ol><li><code>const</code> 数据成员：<ul><li>用 <code>const</code> 修饰的类成员变量，在初始化后不能被修改。</li><li>必须通过构造函数初始化。</li></ul></li><li><code>const</code> 成员函数：<ul><li>在函数声明和定义时以 <code>const</code> 关键字结尾的成员函数。</li><li>特点：<ul><li>保证不会修改类的成员变量（除 <code>mutable</code> 修饰的变量外）。</li><li>只能被 <code>const</code> 对象调用。</li></ul></li></ul></li></ol><p><strong>（2）示例代码</strong></p><p><strong>类成员的定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x1, <span class="type">int</span> y1) : <span class="built_in">x</span>(x1), <span class="built_in">y</span>(y1) &#123;&#125;  <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;                            <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>;                   <span class="comment">// const 成员函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>void f()</code> 是一个普通成员函数，可以修改 <code>x</code> 和 <code>y</code>。</li><li><code>void show() const</code> 是一个 <code>const</code> 成员函数，不能修改类的任何数据成员。</li></ul><p><strong>2. <code>const</code> 成员函数的行为</strong></p><p><strong>（1）普通成员函数</strong></p><ul><li><p>普通成员函数可以修改类的成员变量。</p></li><li><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x = <span class="number">1</span>;  <span class="comment">// 修改类的成员变量</span></span><br><span class="line">    y = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>（2）<code>const</code> 成员函数</strong></p><ul><li><p><code>const</code> 成员函数不能修改类的成员变量。</p></li><li><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y;  <span class="comment">// 只能读取成员变量，不能修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>3. <code>const</code> 对象与成员函数</strong></p><p><strong>（1）<code>const</code> 对象的特点</strong></p><ul><li><code>const</code> 对象是被声明为 <code>const</code> 的类对象。</li><li>限制：<ul><li>只能调用 <code>const</code> 成员函数。</li><li><strong>不能调用普通成员函数</strong>，因为普通成员函数可能会修改对象的状态。</li></ul></li></ul><p><strong>示例代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> A <span class="title">a</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;  <span class="comment">// 定义一个 const 对象</span></span><br><span class="line">a.<span class="built_in">f</span>();            <span class="comment">// 错误，不能调用普通成员函数</span></span><br><span class="line">a.<span class="built_in">show</span>();         <span class="comment">// 正确，可以调用 const 成员函数</span></span><br></pre></td></tr></table></figure><ul><li>解释：<ul><li><code>a.f()</code> 会被编译器拒绝，因为 <code>f()</code> 不是 <code>const</code> 成员函数，可能会修改 <code>a</code> 的成员变量。</li><li><code>a.show()</code> 是合法的，因为 <code>show()</code> 是 <code>const</code> 成员函数，保证不会修改 <code>a</code>。</li></ul></li></ul><p><strong>（2）<code>const</code> 成员函数的隐式 <code>this</code> 指针</strong></p><ul><li>普通成员函数的 <code>this</code> 指针类型是 <code>A*</code>。</li><li><code>const</code> 成员函数的 <code>this</code> 指针类型是 <code>const A*</code>。</li><li>因此，<code>const</code> 成员函数只能访问 <code>const</code> 成员，不能修改成员变量。</li></ul><p><strong>函数声明示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(A* <span class="type">const</span> <span class="keyword">this</span>)</span></span>;          <span class="comment">// 普通成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> A* <span class="type">const</span> <span class="keyword">this</span>)</span></span>; <span class="comment">// const 成员函数</span></span><br></pre></td></tr></table></figure><p><strong>4. <code>mutable</code> 关键字的作用</strong></p><p><strong>（1）<code>mutable</code> 修饰的成员变量</strong></p><ul><li>即使在 <code>const</code> 对象中，<code>mutable</code> 修饰的成员变量也可以被修改。</li><li>用途：<ul><li>用于需要在逻辑上保持 <code>const</code>，但某些成员变量需要修改的场景。</li></ul></li></ul><p><strong>（2）示例代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> count;  <span class="comment">// 使用 mutable 修饰</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        count++;  <span class="comment">// 修改 mutable 成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> A a;</span><br><span class="line">    a.<span class="built_in">show</span>();  <span class="comment">// 修改了 count，合法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong></p><ul><li><code>count</code> 是一个 <code>mutable</code> 成员变量，可以在 <code>const</code> 对象中被修改。</li><li><code>show()</code> 是一个 <code>const</code> 成员函数，但可以合法地修改 <code>mutable</code> 成员变量。</li></ul><p><strong>5. 编译器的角色</strong></p><p>PPT 中提到 <code>compiler</code>：</p><ul><li>作用：<ul><li>编译器会检查 <code>const</code> 规则，确保：<ol><li><code>const</code> 成员函数不会修改成员变量。</li><li><code>const</code> 对象只能调用 <code>const</code> 成员函数。</li></ol></li><li>如果违反规则，编译器会报错。</li></ul></li></ul><p><strong>6. 右侧代码的解析</strong></p><p><strong>代码部分</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span>&amp; indirect_int;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">indirect_int</span>(*<span class="keyword">new</span> <span class="type">int</span>)&#123; ... &#125;  <span class="comment">// 构造函数，动态分配 int</span></span><br><span class="line">    ~<span class="built_in">A</span>() &#123; <span class="keyword">delete</span> &amp;indirect_int; &#125;       <span class="comment">// 析构函数，释放内存</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span> </span>&#123; indirect_int++; &#125;   <span class="comment">// const 成员函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><ol><li>动态分配内存：<ul><li><code>A()</code> 构造函数使用 <code>new</code> 动态分配内存，并初始化 <code>indirect_int</code>（引用类型）。</li></ul></li><li>析构函数：<ul><li><code>~A()</code> 析构函数释放动态分配的内存，避免内存泄漏。</li></ul></li><li><code>f()</code> 是一个 const 成员函数：<ul><li>虽然是 <code>const</code> 成员函数，但它<strong>通过引用 <code>indirect_int</code> 修改了动态分配的内存。</strong></li><li>因为 <code>indirect_int</code> 是一个引用，而<strong>引用所指向的值可以修改，因此不会违反 <code>const</code> 规则</strong>。</li></ul></li></ol><p><strong>7. 总结</strong></p><p><strong><code>const</code> 成员函数的特点</strong></p><ol><li>保证成员函数不会修改成员变量（除 <code>mutable</code> 成员外），引用变量的引用值也可以被修改。</li><li>可以被 <code>const</code> 对象调用。</li><li>隐式 <code>this</code> 指针为 <code>const A*</code>。</li></ol><p><strong><code>const</code> 对象的限制</strong></p><ol><li>只能调用 <code>const</code> 成员函数。</li><li>保证对象的状态在生命周期内不会改变。</li></ol><p><strong>注意点</strong></p><ul><li><code>mutable</code> 关键字允许在 <code>const</code> 对象中修改成员变量。</li><li>编译器会严格检查 <code>const</code> 规则，确保代码安全性和逻辑正确性。</li></ul><p><strong>为什么 <code>void f() const &#123; indirect_int++; &#125;</code> 是合法的？</strong></p><p><strong>1. 引用（<code>int&amp;</code>）成员变量的本质</strong></p><p>引用（<code>int&amp;</code>）是一个别名，它本质上是对另一块内存的间接访问。一个引用成员变量（例如 <code>int&amp; indirect_int</code>）有以下特点：</p><ol><li>引用本身不可变：<ul><li>一旦一个引用被初始化，它就永久绑定到所引用的对象。</li><li>引用的绑定不能被改变，也就是说，你不能让 <code>indirect_int</code> 引用一个新的整数。</li></ul></li><li>引用指向的值可以修改：<ul><li><strong>引用的指向不可以改变，但它所绑定的内存内容是可以被修改的。</strong></li></ul></li></ol><p>因此，<code>indirect_int++</code> 并不是在改变引用的绑定，而是在改变引用所指向的对象的值。</p><p><strong>2. <code>const</code> 成员函数的限制</strong></p><p>在 C++ 中，<code>const</code> 成员函数的作用是：</p><ul><li>保证不会修改当前对象的<strong>成员变量</strong>，除非这些成员变量被 <code>mutable</code> 修饰。</li></ul><p>当你将成员函数声明为 <code>const</code> 时，编译器会隐式地将 <code>this</code> 指针视为 <code>const</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>隐式等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> A* <span class="type">const</span> <span class="keyword">this</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>如何影响成员变量？</strong></p><ol><li>普通成员变量：<ul><li>普通的非引用成员变量在 <code>const</code> 成员函数中是不可修改的，因为 <code>this</code> 被视为 <code>const</code>。</li></ul></li><li>引用成员变量：<ul><li>引用成员变量本质上是对其他内存的别名。在 <code>const</code> 成员函数中，你不能修改引用的绑定（即让它指向别的对象），但你可以修改它所引用的内容。</li><li>换句话说，<strong><code>const</code> 限制的是引用本身的绑定，而不是它所指向的值。</strong></li></ul></li></ol><p>因此，在 <code>void f() const</code> 中，修改 <code>indirect_int</code> 所引用的值是合法的，因为没有违反 <code>const</code> 的规则。</p><p><strong>3. 为什么编译器允许这种操作？</strong></p><p>在代码中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    indirect_int++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>const</code> 的行为限制</strong></p><ul><li>编译器只会限制对<strong>成员变量本身</strong>的直接修改，而不会限制通过引用或指针间接修改它们所指向的值。</li><li><code>indirect_int</code> 是一个引用，因此修改它指向的值<strong>并不是直接修改成员变量本身</strong>，而是<strong>通过引用间接修改了另一块内存</strong>。</li></ul><p><strong>示例</strong></p><p>等价于以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>&amp; indirect_int = value;</span><br><span class="line">indirect_int++;  <span class="comment">// 这是合法的，因为引用的值可以修改</span></span><br></pre></td></tr></table></figure><p>在这里，<code>value</code> 是引用绑定的真实对象，而 <code>indirect_int</code> 只是 <code>value</code> 的别名。</p><p><strong>总结</strong></p><p><strong>为什么合法？</strong></p><ol><li><code>indirect_int</code> 是一个引用，<code>const</code> 成员函数只限制引用本身的绑定（即 <code>indirect_int</code> 必须一直绑定到同一对象），但不限制引用所指向的对象的修改。</li><li>因此，<code>indirect_int++</code> 实际上是通过引用间接修改了引用所指向的值，这符合 <code>const</code> 成员函数的规则。</li></ol><p><strong>关键点</strong></p><ol><li><code>const</code> 成员函数中的限制作用于成员变量本身，而不作用于通过指针或引用间接访问的内容。</li><li>引用的行为类似于指针，<code>const</code> 不限制对引用所指向值的修改。</li></ol><h3 id="const-A-const-this">const A* const this</h3><p>在 <code>const A* const this</code> 中，两个 <code>const</code> 分别修饰了不同的内容，具有不同的意义。</p><p><strong>1. <code>const A*</code> 的含义</strong></p><ul><li><strong><code>const A*</code> 表示 <code>this</code> 指针指向的是一个 <code>const A</code> 类型的对象</strong>。</li><li>换句话说，<strong><code>this</code> 指针指向的对象是常量，不能通过 <code>this</code> 修改对象的成员变量</strong>（除非成员变量是 <code>mutable</code>）。</li></ul><p>在成员函数中，<code>this</code> 指针是隐式传递的。对于 <code>const</code> 成员函数，<code>this</code> 的类型被隐式转换为 <code>const A*</code>，表示当前对象是只读的，成员函数不能修改这个对象的非 <code>mutable</code> 成员变量。</p><p><strong>示例代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">        x = <span class="number">42</span>;  <span class="comment">// 错误：不能修改 `const` 对象的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>在 <code>f()</code> 中，<code>this</code> 是 <code>const A*</code> 类型，因此成员变量 <code>x</code> 被视为只读。</li></ul><p><strong>2. 第二个 <code>const</code> 的含义</strong></p><ul><li><strong><code>const this</code> 表示 <code>this</code> 指针本身是常量</strong>。</li><li>换句话说，<code>this</code> 指针的地址不能被修改。</li></ul><p>在 C++ 中，<code>this</code> 指针默认是一个普通的指针，可以被用来表示当前对象的地址。但在 <code>const</code> 成员函数中，<code>this</code> 指针本身是只读的，不能被重新赋值。</p><p><strong>完整解释 <code>const A* const this</code></strong></p><ol><li>第一个 <code>const</code>：<ul><li>修饰 <code>A</code>，表示 <code>this</code> 指针指向的对象是 <code>const</code>，对象的非 <code>mutable</code> 成员变量不能被修改。</li></ul></li><li>第二个 <code>const</code>：<ul><li>修饰 <code>this</code> 指针本身，表示 <code>this</code> 指针的地址是 <code>const</code>，不能被修改。</li></ul></li></ol><p><strong>3. 举例说明</strong></p><p><strong>非 <code>const</code> 成员函数的 <code>this</code> 指针</strong></p><p>对于普通成员函数，<code>this</code> 是一个非 <code>const</code> 指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="comment">/* `this` 的类型是 A* */</span> &#125;</span><br></pre></td></tr></table></figure><p><strong><code>const</code> 成员函数的 <code>this</code> 指针</strong></p><p>对于 <code>const</code> 成员函数，<code>this</code> 是一个指向 <code>const</code> 对象的常量指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">/* `this` 的类型是 const A* const */</span> &#125;</span><br></pre></td></tr></table></figure><p>这意味着：</p><ol><li>不能通过 <code>this</code> 修改当前对象的非 <code>mutable</code> 成员变量。</li><li>不能修改 <code>this</code> 指针本身（即不能改变它指向的地址）。</li></ol><p><strong>4. 示例：两个 <code>const</code> 的作用</strong></p><p>以下代码展示了两个 <code>const</code> 的实际作用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> y;  <span class="comment">// `mutable` 成员可以在 `const` 对象中修改</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val), <span class="built_in">y</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modifyX</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// x = 10;  // 错误：`x` 是非 `mutable` 成员，不能在 `const` 成员函数中修改</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modifyY</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        y = <span class="number">10</span>;  <span class="comment">// 正确：`y` 是 `mutable` 成员，可以修改</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changeThisPointer</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this = nullptr;  // 错误：`this` 是 `const` 指针，不能修改指针本身的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> A <span class="title">obj</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    obj.<span class="built_in">modifyY</span>();  <span class="comment">// 修改 `mutable` 成员变量</span></span><br><span class="line">    obj.<span class="built_in">print</span>();    <span class="comment">// 输出：x = 5, y = 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = 5, y = 10</span><br></pre></td></tr></table></figure><p><strong>解释</strong></p><ol><li><code>modifyX()</code> 试图修改非 <code>mutable</code> 成员变量 <code>x</code>，被编译器拒绝。</li><li><code>modifyY()</code> 修改了 <code>mutable</code> 成员变量 <code>y</code>，是合法的。</li><li><code>changeThisPointer()</code> 试图修改 <code>this</code> 指针本身的地址，编译器拒绝。</li></ol><p><strong>5. 总结</strong></p><ul><li><code>const A*</code>：<ul><li>限制 <code>this</code> 指针指向的对象是 <code>const</code>，不能修改对象的非 <code>mutable</code> 成员变量。</li></ul></li><li><code>const this</code>：<ul><li>限制 <code>this</code> 指针本身是只读的，不能重新赋值 <code>this</code>。</li></ul></li></ul><p><code>const A* const this</code> 是 <code>const</code> 成员函数中 <code>this</code> 指针的默认类型，确保：</p><ol><li>对象的状态在函数执行期间不会被修改。</li><li><code>this</code> 指针不会被改变。</li></ol><h2 id="静态成员">静态成员</h2><img src="/2025/01/25/CPP-2-1/image-20241219201748108.png" class="" title="image-20241219201748108"><p><strong>1. 什么是静态成员？</strong></p><p><strong>静态成员变量</strong></p><ul><li>定义： 静态成员变量是用 <code>static</code> 修饰的类成员变量。<ul><li>它<strong>属于类本身</strong>，而不是属于某个特定的对象。</li><li>无论创建了多少个类的对象，静态成员变量只会有一份共享的存储空间。</li></ul></li><li>特点：<ol><li>静态成员变量是类的全局属性，不属于具体的某个对象。</li><li>静态成员变量在所有类对象间共享（<strong>对一个对象修改，其他对象看到的值也会改变</strong>）。</li><li>静态成员变量在程序运行时分配内存，只有一份实例。</li></ol></li></ul><p><strong>静态成员函数</strong></p><ul><li><strong>定义</strong>： 静态成员函数是用 <code>static</code> 修饰的类成员函数。<ul><li>它<strong>只能访问静态成员变量</strong>，不能访问非静态成员变量。</li><li>它不依赖于类的对象，<strong>可以通过类名直接调用</strong>。</li></ul></li><li><strong>特点</strong>：<ol><li>静态成员函数<strong>属于类本身</strong>，而不是类的某个对象。</li><li>静态成员函数没有 <code>this</code> 指针。</li><li>它<strong>只能访问类的静态成员</strong>（包括静态成员变量和其他静态成员函数）。</li></ol></li></ul><p><strong>2. 为什么需要静态成员？</strong></p><p>PPT 中提出的问题：</p><ul><li>“同一个类的不同对象如何共享变量？”<ul><li>静态成员提供了一种机制，允许同一个类的不同对象共享一份数据，而无需将这些变量定义为全局变量。</li></ul></li></ul><p><strong>问题分析</strong></p><ol><li><strong>为什么不能用全局变量？</strong><ul><li>全局变量对于整个程序是可见的，可能会被其他不相关的代码误修改，从而导致数据污染（缺乏数据保护）。</li><li>名字可能冲突，容易引起命名污染。</li></ul></li><li><strong>静态成员的优势</strong><ul><li>静态成员属于类，而不是全局空间，具有更好的封装性。</li><li>静态成员可以通过类名访问，具有清晰的语义。</li></ul></li></ol><p><strong>3. 静态成员变量的声明与定义</strong></p><p><strong>声明</strong></p><p>静态成员变量需要在<strong>类内声明</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;  <span class="comment">// 声明静态成员变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>定义</strong></p><p>静态成员变量需要在<strong>类外定义</strong>（并初始化）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A::count = <span class="number">0</span>;  <span class="comment">// 定义并初始化</span></span><br></pre></td></tr></table></figure><p><strong>调用</strong></p><ol><li><p>静态成员函数可以通过类名直接调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A::<span class="built_in">display</span>();</span><br></pre></td></tr></table></figure></li><li><p>也可以通过对象调用，但不推荐：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">a.<span class="built_in">display</span>();  <span class="comment">// 不推荐</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>4. 静态成员的特点</strong></p><p><strong>静态成员变量</strong></p><ol><li>共享性：<ul><li>静态成员变量只有一份拷贝，所有对象共享。</li></ul></li><li>作用域：<ul><li>在<strong>类的作用域内声明，在类外定义和初始化</strong>。</li></ul></li><li>生命周期：<ul><li>静态成员变量的生命周期贯穿整个程序运行。</li></ul></li></ol><p><strong>静态成员函数</strong></p><ol><li>独立性：<ul><li>静态成员函数与对象无关，可以通过类名调用。</li></ul></li><li>限制性：<ul><li>静态成员函数<strong>无法访问非静态成员变量和函数</strong>。</li></ul></li></ol><p><strong>总结</strong></p><p><strong>静态成员的用途</strong></p><ol><li>跨对象共享数据：<ul><li>静态成员变量提供了一种机制，让同一个类的不同对象可以共享数据。</li></ul></li><li>与类相关的操作：<ul><li>静态成员函数用于执行与整个类相关的操作（例如计数、管理共享资源）。</li></ul></li></ol><p><strong>注意事项</strong></p><ul><li><strong>静态成员变量在类外定义时，不能使用 <code>static</code> 关键字</strong>。</li><li>静态成员函数不能访问非静态成员。</li></ul><img src="/2025/01/25/CPP-2-1/image-20241219203834940.png" class="" title="image-20241219203834940"><hr><p><strong>特点</strong></p><ol><li><strong>类对象共享</strong>：<ul><li>静态成员变量是类的全局属性，所有对象共享同一份数据。</li><li>无论创建多少个对象，静态成员变量在内存中只存储一次。</li></ul></li><li><strong>唯一拷贝</strong>：<ul><li>静态成员变量属于类，而不是属于类的某个对象。</li><li>所有对象都可以访问和修改它，但它只存在一份。</li></ul></li><li><strong>生命周期长</strong>：<ul><li>静态成员变量的生命周期从程序开始到结束。</li><li>在整个程序运行期间，静态成员变量始终保存在内存中。</li></ul></li><li><strong>作用域受控（遵循类访问控制）</strong>：<ul><li>静态成员变量的访问权限受类的访问控制符（如 <code>public</code>、<code>protected</code>、<code>private</code>）的限制。</li><li>这种机制避免了直接暴露全局变量所带来的安全问题。</li></ul></li></ol><img src="/2025/01/25/CPP-2-1/image-20241219204200675.png" class="" title="image-20241219204200675"><img src="/2025/01/25/CPP-2-1/image-20241219204340241.png" class="" title="image-20241219204340241"><img src="/2025/01/25/CPP-2-1/image-20241219204401833.png" class="" title="image-20241219204401833"><h3 id="单例模式">单例模式</h3><img src="/2025/01/25/CPP-2-1/image-20241219204739421.png" class="" title="image-20241219204739421"><h2 id="友元">友元</h2><img src="/2025/01/25/CPP-2-1/image-20241219205101183.png" class="" title="image-20241219205101183"><p><strong>1. 什么是友元？</strong></p><p>在 C++ 中，类的 <strong><code>private</code></strong> 和 <strong><code>protected</code></strong> 成员默认只能被该类的成员函数（包括构造函数、析构函数）和其派生类的成员函数访问。<strong>友元</strong> 的引入打破了这个限制，使得其他函数或类可以访问指定类的 <code>private</code> 和 <code>protected</code> 成员。</p><ul><li><strong>友元是类的特殊成员</strong>，允许外部函数或其他类访问它的私有成员。</li><li>友元关系不是对等的：<ul><li>如果 <code>ClassA</code> 是 <code>ClassB</code> 的友元，<code>ClassB</code> 不能自动成为 <code>ClassA</code> 的友元。</li></ul></li></ul><p><strong>为什么需要友元？</strong></p><ul><li>默认情况下，类的私有成员只能通过该类的公共方法访问。</li><li>在某些情况下，这种封装限制可能会降低程序的效率或灵活性。<ul><li>例如，两个类需要共享内部信息协作，或者外部函数需要操作类的私有数据。</li></ul></li><li>使用友元可以提高访问效率，简化代码。</li></ul><p><strong>2. 友元的定义与声明</strong></p><p>在 C++ 中，可以通过 <strong><code>friend</code></strong> 关键字声明友元。友元可以是：</p><ol><li><strong>普通函数</strong>（全局函数或类外的独立函数）。</li><li><strong>另一个类</strong>（使该类的所有成员函数成为当前类的友元）。</li><li><strong>类的成员函数</strong>（使另一个类的某个成员函数成为当前类的友元）。</li></ol><p><strong>友元函数的声明</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> ReturnType <span class="title">FunctionName</span><span class="params">(Parameters)</span></span>; <span class="comment">// 声明友元函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>友元类的声明</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">FriendClass</span>; <span class="comment">// 声明友元类</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>友元成员函数的声明</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> ReturnType <span class="title">FriendClass::MemberFunctionName</span><span class="params">(Parameters)</span></span>; <span class="comment">// 声明友元成员函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>3. PPT 示例解析</strong></p><p>PPT 上提到以下几个关键点：</p><ul><li><strong>普通访问限制</strong>：<ul><li>类的外部函数不能直接访问类的 <code>private</code> 成员变量。</li><li>必须通过类的 <code>public</code> 方法访问。</li><li>这种方式可能会增加额外的访问开销，缺乏灵活性。</li></ul></li><li><strong>解决方案</strong>：通过友元机制，可以让外部函数或类直接访问类的 <code>private</code> 成员。</li></ul><p><strong>矩阵和向量的示例</strong></p><p>PPT 中提到：</p><blockquote><p><strong>例：矩阵类（Matrix）、向量类（Vector）和全局函数（<code>multiply</code>）实现矩阵和向量相乘。</strong></p></blockquote><hr><p><strong>代码示例</strong></p><p>假设我们要实现矩阵和向量相乘，矩阵类和向量类中的数据存储在 <code>private</code> 成员中。如果不使用友元，外部函数 <code>multiply</code> 无法直接访问矩阵和向量的私有数据。</p><p>通过友元机制，可以解决这一问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向量类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩阵类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; mat; <span class="comment">// 矩阵数据</span></span><br><span class="line">    <span class="type">int</span> rows, cols;          <span class="comment">// 行数和列数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Matrix</span>(<span class="type">int</span> r, <span class="type">int</span> c) : <span class="built_in">rows</span>(r), <span class="built_in">cols</span>(c), <span class="built_in">mat</span>(r, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c, <span class="number">0</span>)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setElement</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        mat[r][c] = value; <span class="comment">// 设置矩阵元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; row : mat) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> val : row) &#123;</span><br><span class="line">                cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> vector&lt;<span class="type">int</span>&gt; <span class="title">multiply</span><span class="params">(<span class="type">const</span> Matrix&amp; m, <span class="type">const</span> Vector&amp; v)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向量类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec; <span class="comment">// 向量数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>(<span class="type">int</span> size) : <span class="built_in">vec</span>(size, <span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setElement</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        vec[index] = value; <span class="comment">// 设置向量元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : vec) &#123;</span><br><span class="line">            cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> vector&lt;<span class="type">int</span>&gt; <span class="title">multiply</span><span class="params">(<span class="type">const</span> Matrix&amp; m, <span class="type">const</span> Vector&amp; v)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局友元函数：矩阵和向量相乘</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">multiply</span><span class="params">(<span class="type">const</span> Matrix&amp; m, <span class="type">const</span> Vector&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m.cols != v.vec.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;Matrix columns must match Vector size&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(m.rows, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 矩阵乘以向量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m.rows; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m.cols; ++j) &#123;</span><br><span class="line">            result[i] += m.mat[i][j] * v.vec[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 2x3 矩阵</span></span><br><span class="line">    <span class="function">Matrix <span class="title">mat</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    mat.<span class="built_in">setElement</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    mat.<span class="built_in">setElement</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    mat.<span class="built_in">setElement</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    mat.<span class="built_in">setElement</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    mat.<span class="built_in">setElement</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">    mat.<span class="built_in">setElement</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Matrix:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    mat.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个大小为 3 的向量</span></span><br><span class="line">    <span class="function">Vector <span class="title">vec</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    vec.<span class="built_in">setElement</span>(<span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line">    vec.<span class="built_in">setElement</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">    vec.<span class="built_in">setElement</span>(<span class="number">2</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Vector:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    vec.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 矩阵和向量相乘</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result = <span class="built_in">multiply</span>(mat, vec);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Result:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : result) &#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解析</strong></p><ol><li><strong>类的封装性</strong>：<ul><li>矩阵类的 <code>mat</code> 和向量类的 <code>vec</code> 都是私有成员，外部函数无法直接访问。</li><li>保持了数据的封装性。</li></ul></li><li><strong>友元函数 <code>multiply</code></strong>：<ul><li><code>multiply</code> 是矩阵类和向量类的友元。</li><li>它可以直接访问 <code>Matrix::mat</code> 和 <code>Vector::vec</code>，高效完成矩阵和向量相乘。</li></ul></li><li><strong>友元的必要性</strong>：<ul><li>如果没有友元，必须为 <code>mat</code> 和 <code>vec</code> 提供 <code>getter</code> 方法，增加了代码复杂性和运行时开销。</li></ul></li></ol><img src="/2025/01/25/CPP-2-1/image-20241220081700368.png" class="" title="image-20241220081700368"><img src="/2025/01/25/CPP-2-1/image-20241220081754872.png" class="" title="image-20241220081754872"><img src="/2025/01/25/CPP-2-1/image-20241220081825639.png" class="" title="image-20241220081825639"><img src="/2025/01/25/CPP-2-1/image-20241220081838974.png" class=""><img src="/2025/01/25/CPP-2-1/image-20241220081908036.png" class="" title="image-20241220081908036"><img src="/2025/01/25/CPP-2-1/image-20241220081919781.png" class="" title="image-20241220081919781"><ul><li><strong>友元不是传递性的</strong>：<ul><li>必须明确声明谁是友元，友元关系不会自动传播到其他类或函数。</li></ul></li><li><strong>是的，可以编译</strong>，前提是 <code>multiply</code> 函数的定义与声明匹配，并且 <code>Matrix</code> 和 <code>Vector</code> 都正确声明了它为友元函数。</li></ul><img src="/2025/01/25/CPP-2-1/image-20241220082131830.png" class="" title="image-20241220082131830"><p><strong>1. Law of Demeter（迪米特法则）简介</strong></p><p><strong>核心理念</strong></p><ul><li>避免暴露内部数据成员（data member）：<ul><li>在类的公共接口中，尽量不要直接暴露内部数据成员（即不应将成员变量设为 <code>public</code>）。</li><li>强调通过函数（方法）间接访问数据，以提高封装性和安全性。</li></ul></li></ul><p><strong>为什么要遵循这个原则？</strong></p><ol><li>保护数据完整性：<ul><li>避免外部直接修改类的私有数据。</li><li>通过 getter 和 setter 方法，可以添加额外的逻辑进行检查或转换。</li></ul></li><li>增强代码的可维护性：<ul><li>如果数据成员需要重构或改变，只需修改类内部实现，调用方无需感知。</li></ul></li><li>减少依赖耦合：<ul><li>外部代码无需了解类的具体实现细节，从而降低耦合性。</li></ul></li></ol><p><strong>2. 避免将数据成员暴露在公共接口</strong></p><p>PPT 提到：</p><blockquote><p><strong>“避免将 data member 放在公共接口中”</strong></p></blockquote><ul><li>这是对类的 <strong>封装性（Encapsulation）</strong> 的要求。</li><li>数据成员应始终声明为 <code>private</code> 或 <code>protected</code>。</li><li>外部代码访问类的数据成员时，必须通过公共接口（<code>public</code> 方法）实现，而不是直接访问。</li></ul><p><strong>3. 类设计示例</strong></p><p>PPT 中的示例代码展示了一个名为 <code>AccessLevels</code> 的类，包含几个私有数据成员和相应的访问方法。</p><p><strong>代码解析</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccessLevels</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 只读属性的访问器</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getReadOnly</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> readOnly; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可读写属性的访问器和修改器</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setReadWrite</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123; readWrite = value; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getReadWrite</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> readWrite; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只写属性的修改器</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setWriteOnly</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123; writeOnly = value; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> noAccess;     <span class="comment">// 无访问权限（仅限类内部使用）</span></span><br><span class="line">    <span class="type">int</span> readOnly;     <span class="comment">// 只读属性</span></span><br><span class="line">    <span class="type">int</span> readWrite;    <span class="comment">// 可读写属性</span></span><br><span class="line">    <span class="type">int</span> writeOnly;    <span class="comment">// 只写属性</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>关键点解析</strong></p><ol><li><strong><code>noAccess</code></strong>:<ul><li>该变量完全对外部不可见。</li><li>没有提供任何 getter 或 setter 方法，只能由类内部的方法操作。</li><li>这是最严格的封装，适用于纯粹的内部实现细节。</li></ul></li><li><strong><code>readOnly</code></strong>:<ul><li>提供了 <code>getReadOnly()</code> 方法，但没有对应的 setter 方法。</li><li>这是一个只读属性，外部只能读取，不能修改。</li></ul></li><li><strong><code>readWrite</code></strong>:<ul><li>提供了 <code>getReadWrite()</code> 和 <code>setReadWrite()</code> 方法。</li><li>这是一个可读写属性，外部可以通过 getter 方法读取值，通过 setter 方法修改值。</li></ul></li><li><strong><code>writeOnly</code></strong>:<ul><li>提供了 <code>setWriteOnly()</code> 方法，但没有对应的 getter 方法。</li><li>这是一个只写属性，外部只能写入值，不能读取。</li></ul></li></ol><p><strong>优点</strong></p><ul><li><p>通过 getter 和 setter 控制数据访问，可以对数据的读取和修改添加额外的逻辑。</p><ul><li><p>例如，在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setReadWrite()</span><br></pre></td></tr></table></figure><p>方法中，可以添加范围检查：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setReadWrite</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value &gt;= <span class="number">0</span> &amp;&amp; value &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">        readWrite = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Value out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>避免直接暴露数据成员，提高了类的安全性和灵活性。</p></li><li><p>不同的访问级别（如只读、只写、可读写）可以根据需求灵活实现。</p></li></ul><p><strong>4. 访问控制的矩阵</strong></p><p>PPT 提供了一个访问控制矩阵，总结了不同访问权限的用法：</p><table><thead><tr><th>访问级别</th><th><code>Get</code></th><th><code>Set</code></th></tr></thead><tbody><tr><td><code>R</code>（只读）</td><td>✅</td><td>❌</td></tr><tr><td><code>W</code>（只写）</td><td>❌</td><td>✅</td></tr><tr><td><code>RW</code>（可读写）</td><td>✅</td><td>✅</td></tr><tr><td><code>NONE</code>（无访问权限）</td><td>❌</td><td>❌</td></tr></tbody></table><p><strong>具体对应</strong></p><ul><li><code>readOnly</code> 对应 <code>R</code>：提供 getter 方法，但没有 setter 方法。</li><li><code>writeOnly</code> 对应 <code>W</code>：提供 setter 方法，但没有 getter 方法。</li><li><code>readWrite</code> 对应 <code>RW</code>：同时提供 getter 和 setter 方法。</li><li><code>noAccess</code> 对应 <code>NONE</code>：既没有 getter 方法，也没有 setter 方法。</li></ul><p><strong>5. 努力让接口完整（complete）且最小化（minimal）</strong></p><p>PPT 提到：</p><blockquote><p><strong>“努力让接口完整且最小化”</strong></p></blockquote><ul><li>完整性（complete）：<ul><li>确保类的接口能够满足用户的需求。</li><li>例如，如果用户需要读取和修改某个属性，就应该同时提供 getter 和 setter 方法。</li></ul></li><li>最小化（minimal）：<ul><li>避免暴露不必要的接口，保持接口的简洁性。</li><li>例如，<strong>如果某个属性只需要提供读取功能，就不必为其提供 setter 方法。</strong></li></ul></li></ul><p><strong>原则</strong>：只暴露必要的接口，隐藏实现细节。</p><p><strong>6. 总结</strong></p><p><strong>PPT 的核心内容</strong></p><ol><li>数据成员应设置为 <code>private</code>，通过公共方法（getter 和 setter）访问。</li><li>根据需要，灵活设计访问方法（只读、只写、可读写）。</li><li>遵循封装性原则，避免直接暴露内部数据成员。</li></ol><p><strong>封装的优点</strong></p><ul><li>提高代码的安全性和可维护性。</li><li>避免数据污染，确保数据的一致性。</li><li>降低耦合性，使类的实现可以自由修改而不影响调用者。</li></ul><p><strong>Demeter 法则的应用</strong></p><ul><li><strong>避免过度暴露数据成员</strong>，通过方法访问。</li><li><strong>减少对象间的直接依赖</strong>，提高代码的模块化程度。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++高级程序设计笔记（C2-4）</title>
      <link href="/2025/01/25/CPP-2-4/"/>
      <url>/2025/01/25/CPP-2-4/</url>
      
        <content type="html"><![CDATA[<h1>CPP-2-4</h1><h2 id="异常处理">异常处理</h2><p><img src="C:%5CUsers%5C29607%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241229132315179.png" alt="image-20241229132315179"></p><img src="/2025/01/25/CPP-2-4/image-20241229132407339.png" class="" title="image-20241229132407339"><img src="/2025/01/25/CPP-2-4/image-20241229132418127.png" class="" title="image-20241229132418127"><img src="/2025/01/25/CPP-2-4/image-20241229132644192.png" class="" title="image-20241229132644192"><p><strong>(1) <code>try</code>：监控异常</strong></p><ul><li><strong>作用</strong>：<ul><li>用于包裹可能发生异常的代码段，监控其中的执行情况。</li></ul></li><li><strong>语法</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能引发异常的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>特性</strong>：<ul><li>如果<code>try</code>块中的代码没有抛出异常，<code>catch</code>块将被跳过。</li><li>如果<code>try</code>块中发生异常，程序将中断后续执行并跳转到对应的<code>catch</code>块。</li></ul></li></ul><p><strong>(2) <code>throw</code>：抛出异常对象</strong></p><ul><li><strong>作用</strong>：<ul><li>当程序检测到异常时，通过<code>throw</code>关键字将异常抛出。</li><li>可以抛出任何类型的对象，包括内置类型、类对象等。</li></ul></li><li><strong>语法</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> 表达式;</span><br></pre></td></tr></table></figure><ul><li>表达式可以是异常对象，例如字符串、整数或自定义的异常类对象。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;Division by zero&quot;</span>; <span class="comment">// 抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>(3) <code>catch</code>：捕获并处理异常</strong></p><ul><li><strong>作用</strong>：<ul><li>捕获由<code>throw</code>抛出的异常并对其进行处理。</li><li>捕获异常时，<code>catch</code>块会匹配异常的类型。</li></ul></li><li><strong>语法</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">catch</span> (异常类型 变量名) &#123;</span><br><span class="line">    <span class="comment">// 处理异常的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果异常类型匹配成功，程序会执行<code>catch</code>块中的代码。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* errMsg) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; errMsg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>3. 异常处理流程</strong></p><ul><li>当程序运行到<code>try</code>块中发生异常：<ol><li>立即停止<code>try</code>块后续代码的执行。</li><li>根据<code>throw</code>的异常类型，查找与之匹配的<code>catch</code>块。</li><li>如果找到匹配的<code>catch</code>块，进入其中执行异常处理逻辑。</li><li>如果没有找到匹配的<code>catch</code>块，程序将终止，调用<code>std::terminate()</code>。</li></ol></li></ul><p><strong>4. 异常处理的代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;Division by zero&quot;</span>; <span class="comment">// 抛出字符串异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; a / b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">divide</span>(<span class="number">10</span>, <span class="number">0</span>); <span class="comment">// 尝试执行可能抛出异常的代码</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* errMsg) &#123; <span class="comment">// 捕获异常</span></span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Caught exception: &quot;</span> &lt;&lt; errMsg &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caught exception: Division by zero</span><br></pre></td></tr></table></figure><img src="/2025/01/25/CPP-2-4/image-20241229132904617.png" class="" title="image-20241229132904617"><h3 id="多层传播">多层传播</h3><img src="/2025/01/25/CPP-2-4/image-20241229132938157.png" class="" title="image-20241229132938157"><p><strong>嵌套结构中的处理流程</strong>：</p><ol><li><strong><code>h()</code>函数抛出异常</strong>：<ul><li>如果<code>h()</code>中抛出的异常没有被自身捕获，会传播到调用它的<code>g()</code>。</li><li>如果<code>g()</code>中也没有捕获，则继续传播到<code>f()</code>。</li></ul></li><li><strong>逐层查找捕获点</strong>：<ul><li>异常从抛出点开始，沿调用链逆向寻找匹配的<code>catch</code>块。</li><li>如果调用链上都没有匹配的<code>catch</code>块，则程序终止（调用<code>std::terminate()</code>）。</li></ul></li></ol><p><strong>2. 多层传播</strong></p><p><strong>示例代码对应分析</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">1</span>;      <span class="comment">// 抛出int类型异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;abcd&quot;</span>; <span class="comment">// 抛出char*类型异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">h</span>();      <span class="comment">// 调用h()，可能抛出异常</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">int</span>) &#123;</span><br><span class="line">        <span class="comment">// 捕获int类型异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">g</span>();      <span class="comment">// 调用g()，可能抛出异常</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">int</span>) &#123;</span><br><span class="line">        <span class="comment">// 捕获int类型异常</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">char</span>*) &#123;</span><br><span class="line">        <span class="comment">// 捕获char*类型异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2025/01/25/CPP-2-4/image-20241229133427560.png" class="" title="image-20241229133427560"><img src="/2025/01/25/CPP-2-4/image-20241229133442749.png" class="" title="image-20241229133442749"><ol><li><p><strong>注意<code>catch</code>块排列顺序</strong></p><ul><li>C++异常处理中的<code>catch</code>块按照声明顺序依次匹配。</li><li>匹配规则：<strong>派生类异常必须在基类异常之前捕获</strong>，否则基类的<code>catch</code>块会抢先捕获所有异常（多态性）。</li><li>例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 抛出 WrongFormat 异常</span></span><br><span class="line">    WrongFormat wf;</span><br><span class="line">    <span class="keyword">throw</span> wf;</span><br><span class="line">&#125; <span class="built_in">catch</span> (FileErrors &amp;e) &#123;</span><br><span class="line">    <span class="comment">// 捕获基类异常</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="built_in">catch</span> (NonExist &amp;e) &#123;</span><br><span class="line">    <span class="comment">// 捕获文件不存在异常</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="built_in">catch</span> (DiskSeekError &amp;e) &#123;</span><br><span class="line">    <span class="comment">// 捕获磁盘错误异常</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>上述代码会出现问题，因为 <code>FileErrors &amp;</code> 的 <code>catch</code> 块优先被匹配，导致后续派生类异常 <code>catch</code> 块永远不会执行。</li></ul></li><li><p><strong>正确写法</strong></p><ul><li><code>catch</code>块应按<strong>从派生类到基类</strong>的顺序排列：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">WrongFormat</span>(); <span class="comment">// 抛出具体派生类异常</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (NonExist &amp;e) &#123;</span><br><span class="line">    <span class="comment">// 捕获文件不存在</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="built_in">catch</span> (DiskSeekError &amp;e) &#123;</span><br><span class="line">    <span class="comment">// 捕获磁盘错误</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="built_in">catch</span> (FileErrors &amp;e) &#123;</span><br><span class="line">    <span class="comment">// 捕获基类异常，处理其他未明确指定的异常</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="异常与throw的多态">==异常与throw的多态==</h3><img src="/2025/01/25/CPP-2-4/image-20241229133544204.png" class="" title="image-20241229133544204"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyExceptionBase</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyExceptionDerived</span> : <span class="keyword">public</span> MyExceptionBase &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(MyExceptionBase&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyExceptionDerived e;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">f</span>(e);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (MyExceptionDerived&amp; e) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyExceptionDerived&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (MyExceptionBase&amp; e) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyExceptionBase&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;MyExceptionBase&quot;</span><br></pre></td></tr></table></figure><p><strong>代码分析</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyExceptionBase</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyExceptionDerived</span> : <span class="keyword">public</span> MyExceptionBase &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>MyExceptionBase</strong> 是一个基类，表示基础异常类。</li><li><strong>MyExceptionDerived</strong> 是 <strong>MyExceptionBase</strong> 的派生类，表示一个更具体的异常类型。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(MyExceptionBase&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数 <code>f</code> 接受一个 <code>MyExceptionBase&amp;</code> 类型的引用参数 <code>e</code>，并抛出这个对象 <code>e</code>。</li><li>需要注意的是，<strong>这里抛出的 <code>e</code> 仅仅是对 <code>e</code> 的一个拷贝，而不是指针或引用的转发</strong>。因此，抛出的是一个 <code>MyExceptionBase</code> 类型的对象（即使传入的是派生类的对象，仍然会发生切割）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyExceptionDerived e;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">f</span>(e);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (MyExceptionDerived&amp; e) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyExceptionDerived&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (MyExceptionBase&amp; e) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyExceptionBase&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <code>main</code> 函数中，定义了一个 <code>MyExceptionDerived</code> 类型的对象 <code>e</code>，然后将它作为参数传递给 <code>f(e)</code>，即 <code>f</code> 函数被调用，抛出了 <code>e</code>。</li><li>由于 <code>f</code> 抛出的是 <code>MyExceptionBase</code> 类型的拷贝（即使传入的是 <code>MyExceptionDerived</code> 对象），因此异常类型在捕获时会失去 <code>MyExceptionDerived</code> 的信息，<strong>仅作为 <code>MyExceptionBase</code> 类型出现</strong>。</li></ul><p><strong>输出</strong></p><p>因此，程序的输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyExceptionBase</span><br></pre></td></tr></table></figure><p><strong>关键点</strong></p><ol><li><strong>异常抛出时的类型切割</strong>：在 <code>f</code> 函数中，<code>throw e</code> 使得 <code>e</code> 被复制为 <code>MyExceptionBase</code> 类型的对象。即使 <code>e</code> 原本是 <code>MyExceptionDerived</code> 类型，但抛出的对象是 <code>MyExceptionBase</code> 类型的拷贝，因此丧失了派生类信息。</li><li><strong>异常捕获机制</strong>：捕获异常时，<code>catch (MyExceptionDerived&amp; e)</code> 块不会被执行，因为抛出的异常对象是 <code>MyExceptionBase</code> 类型，不是 <code>MyExceptionDerived</code> 类型。</li></ol><img src="/2025/01/25/CPP-2-4/image-20241229134135575.png" class="" title="image-20241229134135575"><p><strong>特例 1：无参数 <code>throw</code></strong></p><p>解释：</p><ul><li>无参数的 <code>throw</code> 用于重新抛出当前捕获的异常。</li><li>例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">catch</span> (<span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在 <code>catch</code> 块中捕获一个 <code>int</code> 类型的异常后，通过无参数的 <code>throw</code> 关键字将同样的异常对象重新抛出。</li></ul><p><strong>作用：</strong></p><ul><li>重新抛出异常可以将异常传播到更高层的调用者，适用于某些情况下需要中途处理异常但无法完全解决的情景。</li></ul><p><strong>注意：</strong></p><ul><li>无参数的 <code>throw</code> 只能在 <code>catch</code> 块中使用，否则会导致未定义行为。</li></ul><p><strong>特例 2：<code>catch(...)</code></strong></p><p>解释：</p><ul><li><code>catch(...)</code> 是一个通配符异常捕获块，能够捕获所有类型的异常。</li><li>用法：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">catch</span> (...) &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>作用：</strong></p><ul><li>通常用于程序的最终安全保护机制，确保即使出现未明确处理的异常时，程序仍然能够优雅地结束。</li><li>在某些情况下，<code>catch(...)</code> 会用来记录错误日志或执行必要的清理工作。</li></ul><p><strong>特点说明</strong></p><p><strong>实现不影响对象布局：</strong></p><ul><li>异常处理机制的引入不会改变对象的内存布局，异常处理相关信息是通过额外的运行时支持（如栈展开）来管理的。</li></ul><p><strong>程序状态与析构函数、异常处理器的关系：</strong></p><ul><li>当异常被抛出时：<ul><li>会调用作用域内已经创建的对象的析构函数来释放资源。</li><li>异常处理器（<code>catch</code> 块）负责捕获并处理异常，确保程序能够以某种方式恢复或优雅退出。</li></ul></li></ul><p><strong>对程序验证特性的支持</strong></p><p>这一部分描述了如何通过异常处理实现对程序验证特性的支持。</p><p>代码片段：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Assert</span><span class="params">(T exp, E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG)</span><br><span class="line">        <span class="keyword">if</span> (!exp) <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li>这是一个模板函数，用于断言某个表达式（<code>exp</code>）是否为真。</li><li>如果在调试模式（<code>DEBUG</code>）下，断言失败（<code>exp</code> 为假），则会抛出异常 <code>e</code>。</li><li>典型用途包括：<ul><li>检查程序运行时的重要前置条件（如函数输入是否合法）。</li><li>提供调试信息，在调试模式下捕获潜在问题。</li></ul></li></ul><p><strong>优势：</strong></p><ul><li>在 <code>DEBUG</code> 模式下，断言能够有效检测程序逻辑问题。</li><li>在非调试模式（发布版）中，断言通常被禁用，以提高程序性能。</li></ul><p><strong>如何应对多出口引发的处理碎片？</strong></p><p>PPT中的这个问题是指异常处理的设计可以避免程序中由于多种错误出口导致的代码碎片化问题。</p><p><strong>背景：</strong></p><ul><li>在传统的错误处理机制中，通常通过返回错误代码或设置全局变量来传递错误信息，这种方法可能导致代码复杂且难以维护。</li><li>异常处理通过将错误的处理逻辑集中到 <code>catch</code> 块中，减少了多出口的代码碎片。</li></ul><p><strong>总结</strong></p><ol><li><p><strong>无参数 <code>throw</code>：</strong></p><ul><li>用于在 <code>catch</code> 块中重新抛出异常，通常用于将异常传递给更高层的异常处理器。</li></ul></li><li><p><strong><code>catch(...)</code>：</strong></p><ul><li>捕获所有类型的异常，通常作为程序最后的安全保障机制。</li></ul></li><li><p><strong>对程序验证特性的支持：</strong></p><ul><li>通过模板断言函数（<code>Assert</code>），结合异常处理机制实现程序的运行时验证，尤其适合调试模式。</li></ul></li><li><p><strong>实现特点：</strong></p><ul><li>异常处理机制不影响对象布局，并在异常抛出时自动调用对象的析构函数进行资源释放，确保程序状态的一致性。</li></ul></li><li><p><strong>多出口问题：</strong></p><ul><li>异常处理机制有效解决了传统错误处理方式中多出口导致的代码碎片问题，使代码更易于维护和扩展。</li></ul></li></ol><h3 id="Empty类">Empty类</h3><img src="/2025/01/25/CPP-2-4/image-20241229134508847.png" class="" title="image-20241229134508847"><p><strong>Know what functions C++ silently writes and calls</strong></p><p>翻译：了解C++编译器隐式生成和调用的函数。</p><p>C++ 编译器在某些情况下会为类自动生成一些默认的成员函数。这些默认成员函数为类提供了基本的功能，比如对象的构造、复制、赋值和销毁等。该PPT展示了这些默认生成的函数。</p><p><strong>内容解析</strong></p><ol><li><code>class Empty &#123; &#125;;</code></li></ol><p>这是一个空类声明。尽管类 <code>Empty</code> 看起来没有定义任何成员函数，但C++编译器会为它隐式生成以下默认成员函数。</p><ol start="2"><li><code>class Empty</code> 的默认生成函数列表：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;</span><br><span class="line">    <span class="built_in">Empty</span>();                                <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp;);                    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    ~<span class="built_in">Empty</span>();                               <span class="comment">// 析构函数</span></span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Empty&amp;);         <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">    Empty* <span class="keyword">operator</span>&amp;();                     <span class="comment">// 获取对象的非const地址</span></span><br><span class="line">    <span class="type">const</span> Empty* <span class="keyword">operator</span>&amp;() <span class="type">const</span>;         <span class="comment">// 获取对象的const地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><strong>C++编译器会自动生成的默认函数：</strong><ul><li>默认构造函数。</li><li>拷贝构造函数。</li><li>拷贝赋值运算符。</li><li>析构函数。</li><li>地址操作符（<code>operator&amp;</code> 和 <code>operator&amp; const</code>）。</li></ul></li><li><strong>这些默认函数的主要作用：</strong><ul><li>提供基本的对象构造、拷贝、赋值和销毁功能。</li><li>提供对对象地址的访问功能。</li></ul></li><li><strong>注意：</strong><ul><li>如果用户<strong>显式定义了任意一个构造函数，则默认构造函数不会自动生成</strong>。</li><li>如果用户显式定义了拷贝构造函数或拷贝赋值运算符，则编译器不会自动生成它们。</li></ul></li></ol><h3 id="try-catch中delete">try-catch中delete</h3><img src="/2025/01/25/CPP-2-4/image-20241229134754243.png" class="" title="image-20241229134754243"><img src="/2025/01/25/CPP-2-4/image-20241229134842322.png" class="" title="image-20241229134842322"><img src="/2025/01/25/CPP-2-4/image-20241229134912707.png" class="" title="image-20241229134912707"><h3 id="auto-ptr">auto_ptr</h3><img src="/2025/01/25/CPP-2-4/image-20241229135028953.png" class="" title="image-20241229135028953"><img src="/2025/01/25/CPP-2-4/image-20241229135129990.png" class="" title="image-20241229135129990"><img src="/2025/01/25/CPP-2-4/image-20241229135202290.png" class="" title="image-20241229135202290"><ul><li>将指针包装成类以后，类调用析构函数时释放指针，不用手动释放指针了</li></ul><h2 id="I-O处理">I/O处理</h2><img src="/2025/01/25/CPP-2-4/image-20241229135313659.png" class="" title="image-20241229135313659"><img src="/2025/01/25/CPP-2-4/image-20241229135343451.png" class="" title="image-20241229135343451"><h3 id="文件IO">文件IO</h3><img src="/2025/01/25/CPP-2-4/image-20241229135357241.png" class="" title="image-20241229135357241"><p><strong>核心概念：重定向</strong></p><p>在C++中，<code>cin</code> 和 <code>cout</code> 默认使用标准输入（键盘）和标准输出（控制台）作为数据流的来源和目标。通过流缓冲区（<code>streambuf</code>），可以将这些流重定向到文件或其他流对象，实现输入输出的灵活控制。</p><p><strong>代码解析</strong></p><p><strong>1. 重定向 <code>cin</code> 到文件 <code>in.txt</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;in.txt&quot;</span>)</span></span>;</span><br><span class="line">streambuf* cinbuf = cin.<span class="built_in">rdbuf</span>(); <span class="comment">// 保存标准输入的缓冲区</span></span><br><span class="line">cin.<span class="built_in">rdbuf</span>(in.<span class="built_in">rdbuf</span>());           <span class="comment">// 将 cin 的缓冲区重定向到 in.txt</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>ifstream in(&quot;in.txt&quot;)</code></strong>：<ul><li>创建一个输入文件流 <code>in</code>，从文件 <code>in.txt</code> 中读取内容。</li></ul></li><li><strong><code>cin.rdbuf()</code></strong>：<ul><li>获取当前 <code>cin</code>（标准输入流）的缓冲区指针，并保存到 <code>cinbuf</code> 中，便于后续恢复。</li></ul></li><li><strong><code>cin.rdbuf(in.rdbuf())</code></strong>：<ul><li>将 <code>cin</code> 的缓冲区设置为文件流 <code>in</code> 的缓冲区，这样后续通过 <code>cin</code> 的输入会从 <code>in.txt</code> 文件中读取，而不是从标准输入（键盘）读取。</li></ul></li></ul><p><strong>2. 重定向 <code>cout</code> 到文件 <code>out.txt</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;out.txt&quot;</span>)</span></span>;</span><br><span class="line">streambuf* coutbuf = cout.<span class="built_in">rdbuf</span>(); <span class="comment">// 保存标准输出的缓冲区</span></span><br><span class="line">cout.<span class="built_in">rdbuf</span>(out.<span class="built_in">rdbuf</span>());           <span class="comment">// 将 cout 的缓冲区重定向到 out.txt</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>ofstream out(&quot;out.txt&quot;)</code></strong>：<ul><li>创建一个输出文件流 <code>out</code>，用于向文件 <code>out.txt</code> 写入内容。</li></ul></li><li><strong><code>cout.rdbuf()</code></strong>：<ul><li>获取当前 <code>cout</code>（标准输出流）的缓冲区指针，并保存到 <code>coutbuf</code> 中，便于后续恢复。</li></ul></li><li><strong><code>cout.rdbuf(out.rdbuf())</code></strong>：<ul><li>将 <code>cout</code> 的缓冲区设置为文件流 <code>out</code> 的缓冲区，这样后续通过 <code>cout</code> 的输出会写入到 <code>out.txt</code> 文件，而不是标准输出（控制台）。</li></ul></li></ul><p><strong>3. 使用 <code>cin</code> 和 <code>cout</code> 进行文件输入和输出</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string word;</span><br><span class="line">cin &gt;&gt; word;        <span class="comment">// 从文件 in.txt 中读取一个单词</span></span><br><span class="line">cout &lt;&lt; word &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 将读取的单词写入文件 out.txt</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>cin &gt;&gt; word</code></strong>：<ul><li>因为 <code>cin</code> 已经被重定向到文件 <code>in.txt</code>，因此此处会从 <code>in.txt</code> 中读取一个单词并存储到变量 <code>word</code> 中。</li></ul></li><li><strong><code>cout &lt;&lt; word &lt;&lt; &quot; &quot;</code></strong>：<ul><li>因为 <code>cout</code> 已经被重定向到文件 <code>out.txt</code>，因此此处会将变量 <code>word</code> 的值写入文件 <code>out.txt</code>，并在后面加上一个空格。</li></ul></li></ul><p><strong>4. 恢复 <code>cin</code> 和 <code>cout</code> 的原始缓冲区</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">rdbuf</span>(cinbuf);   <span class="comment">// 重置 cin 到标准输入</span></span><br><span class="line">cout.<span class="built_in">rdbuf</span>(coutbuf); <span class="comment">// 重置 cout 到标准输出</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>cin.rdbuf(cinbuf)</code></strong>：<ul><li>将 <code>cin</code> 的缓冲区恢复为原始的标准输入缓冲区，之后 <code>cin</code> 的输入将来自键盘。</li></ul></li><li><strong><code>cout.rdbuf(coutbuf)</code></strong>：<ul><li>将 <code>cout</code> 的缓冲区恢复为原始的标准输出缓冲区，之后 <code>cout</code> 的输出将显示到控制台。</li></ul></li></ul><p><strong>5. 使用恢复后的 <code>cin</code> 和 <code>cout</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; word;        <span class="comment">// 从标准输入读取一个单词</span></span><br><span class="line">cout &lt;&lt; word;       <span class="comment">// 将读取的单词输出到标准输出</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>cin &gt;&gt; word</code></strong>：<ul><li>此时 <code>cin</code> 已经恢复为标准输入流，因此从键盘读取输入。</li></ul></li><li><strong><code>cout &lt;&lt; word</code></strong>：<ul><li>此时 <code>cout</code> 已经恢复为标准输出流，因此将数据输出到控制台。</li></ul></li></ul><p><strong>总结</strong></p><ol><li><p><strong>输入重定向：</strong></p><ul><li>通过 <code>cin.rdbuf()</code> 将标准输入流 <code>cin</code> 的缓冲区替换为文件流的缓冲区，可以从文件中读取数据。</li></ul></li><li><p><strong>输出重定向：</strong></p><ul><li>通过 <code>cout.rdbuf()</code> 将标准输出流 <code>cout</code> 的缓冲区替换为文件流的缓冲区，可以将数据写入到文件中。</li></ul></li><li><p><strong>恢复重定向：</strong></p><ul><li>重定向完成后，可以通过恢复原始缓冲区指针（<code>streambuf*</code>）的方式，将流重新设置为标准输入和标准输出。</li></ul></li><li><p><strong>用途：</strong></p><ul><li>输入输出重定向可以用于测试程序的输入输出、数据日志记录等场景，简化操作。</li></ul></li></ol><h3 id="重载">&lt;&lt;/&gt;&gt;重载</h3><img src="/2025/01/25/CPP-2-4/image-20241229140049531.png" class="" title="image-20241229140049531"><p><strong>核心概念</strong></p><ul><li><p><strong>操作符 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 重载：</strong></p></li><li><p><strong>重载位置：</strong></p><ul><li><strong>全局函数重载：</strong> 通常将 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 操作符定义为全局函数，并将类<strong>声明为这些函数的友元</strong>，以便访问类的私有或保护成员。</li><li><strong>目的：</strong> 支持对自定义类型对象的 I/O 操作。</li></ul></li></ul><p><strong>代码解析</strong></p><p><strong>1. 基本类 <code>CPoint2D</code> 的输出操作符重载</strong></p><p>类定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint2D</span> &#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, CPoint2D&amp; a);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>类 <code>CPoint2D</code></strong>：<ul><li>包含两个私有成员变量 <code>x</code> 和 <code>y</code>，表示二维点的坐标。</li><li>通过声明 <code>friend</code> 关键字，将 <code>operator&lt;&lt;</code> 定义为友元函数，使其能够访问类的私有成员。</li></ul></li></ul><p>重载函数定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, CPoint2D&amp; a) &#123;</span><br><span class="line">    out &lt;&lt; a.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; a.y &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>ostream&amp; operator&lt;&lt;</code>：</strong><ul><li>第一个参数 <code>ostream&amp; out</code> 是输出流对象（如 <code>std::cout</code>）。</li><li>第二个参数 <code>CPoint2D&amp; a</code> 是要输出的对象。</li><li>函数通过 <code>out</code> 流向输出目标插入 <code>a</code> 的 <code>x</code> 和 <code>y</code> 坐标，格式为 <code>x,y</code>。</li></ul></li></ul><p>使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPoint2D a;</span><br><span class="line">cout &lt;&lt; a;</span><br></pre></td></tr></table></figure><ul><li>当使用 <code>cout &lt;&lt; a</code> 时，调用 <code>operator&lt;&lt;</code> 输出对象 <code>a</code> 的 <code>x</code> 和 <code>y</code> 坐标。</li></ul><p><strong>2. 派生类 <code>CPoint3D</code> 的输出操作符重载</strong></p><p>类定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint3D</span> : <span class="keyword">public</span> CPoint2D &#123;</span><br><span class="line">    <span class="type">double</span> z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, CPoint3D&amp; b);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>类 <code>CPoint3D</code></strong>：<ul><li>继承自 <code>CPoint2D</code>，并添加了一个新的成员变量 <code>z</code>，表示三维点的 z 坐标。</li><li>定义了一个新的输出操作符 <code>operator&lt;&lt;</code>，用于处理 <code>CPoint3D</code> 对象。</li></ul></li></ul><p>重载函数定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, CPoint3D&amp; b) &#123;</span><br><span class="line">    out &lt;&lt; b.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; b.y &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; b.z &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>ostream&amp; operator&lt;&lt;</code>：</strong><ul><li>类似于 <code>CPoint2D</code> 的重载函数，但增加了对成员 <code>z</code> 的输出。</li><li>输出格式为 <code>x,y,z</code>。</li></ul></li></ul><p>使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPoint3D b;</span><br><span class="line">cout &lt;&lt; b;</span><br></pre></td></tr></table></figure><ul><li>如果没有为 <code>CPoint3D</code> 定义新的 <code>operator&lt;&lt;</code>，那么输出只会调用 <code>CPoint2D</code> 的重载版本，只显示 <code>x</code> 和 <code>y</code>，不会显示 <code>z</code>。</li></ul><p><strong>3. 重载函数的继承问题</strong></p><ul><li>在派生类中，<strong>父类的友元函数不会自动成为派生类的友元</strong>。</li><li>如果 <code>CPoint3D</code> 没有单独定义 <code>operator&lt;&lt;</code>，则会调用 <code>CPoint2D</code> 的重载版本。</li><li><strong>效果：</strong> 只会输出 <code>x</code> 和 <code>y</code>，而不会输出 <code>z</code>。</li><li>如果需要处理派生类的成员（如 <code>z</code>），必须为派生类单独定义新的重载版本。</li></ul><img src="/2025/01/25/CPP-2-4/image-20241229140432010.png" class="" title="image-20241229140432010"><ul><li>注意在派生类中，使用FatherClass::method();是调用父类的method方法</li></ul><h3 id="“虚拟”构造函数">==“虚拟”构造函数==</h3><img src="/2025/01/25/CPP-2-4/image-20241229140546611.png" class="" title="image-20241229140546611"><p><strong>Virtualizing constructors</strong></p><p>在C++中，构造函数不能声明为虚函数（<code>virtual</code>）。然而，在某些情况下，需要根据运行时的类型动态创建对象，而这正是“虚拟构造函数”的核心概念。</p><p><strong>内容分析</strong></p><p><strong>1. Virtual constructor</strong></p><p><strong>概念：</strong></p><ul><li><p><strong>Virtual function</strong>（虚函数）：</p><ul><li>虚函数是支持运行时多态的关键机制，用于动态调用派生类中重写的函数。</li><li>虚函数的核心作用是通过基类指针或引用调用派生类的实现。</li></ul></li><li><p><strong>Constructor</strong>（构造函数）：</p><ul><li>构造函数用于初始化对象，但<strong>构造函数不能声明为虚函数。这是因为在构造对象时，对象的类型已经确定，因此没有必要动态分派。</strong></li></ul></li></ul><p><strong>如何实现虚拟构造函数：</strong></p><p>由于C++不支持直接定义虚拟构造函数，需要使用替代方法实现类似的功能。这通常通过以下方式实现：</p><ol><li><p><strong>虚拟克隆函数（Virtual Clone Function）：</strong></p><ul><li>在基类中定义一个虚函数 <code>clone</code>，在派生类中实现它，用于动态创建当前派生类的对象。</li><li><strong>示例：</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Base* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Derived* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Derived</span>(*<span class="keyword">this</span>); <span class="comment">// 返回当前派生类对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>工厂模式（Factory Pattern）：</strong></p><ul><li>工厂模式通过统一接口，根据输入动态创建不同类型的对象。</li><li><strong>示例：</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> Base* <span class="title">create</span><span class="params">(<span class="type">int</span> type)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">public</span> Base &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">public</span> Base &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Base* <span class="title">Base::create</span><span class="params">(<span class="type">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Derived1</span>();</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Derived2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>2. PPT中的具体例子</strong></p><p><strong>系统设计：</strong></p><p>PPT中的示例展示了一个类似报纸（<code>NewsLetter</code>）的对象管理系统。系统包含以下内容：</p><ul><li><p><strong>NewsLetter</strong>：</p><ul><li>一个报纸类，包含多个对象列表（<code>List Objects</code>）。</li><li>每个对象可以是文本块（<code>TextBlock</code>）或图形（<code>Graphic</code>）。</li></ul></li><li><p><strong>NLComponent（基类）：</strong></p><ul><li>定义了所有组件（文本块和图形）的公共接口。</li><li><code>TextBlock</code> 和 <code>Graphic</code> 继承自 <code>NLComponent</code>。</li></ul></li></ul><p><strong>对象创建与管理：</strong></p><ul><li><strong>指针的多态性：</strong><ul><li><code>NewsLetter</code> 类中通过 <code>NLComponent</code> 类型的指针存储 <code>TextBlock</code> 和 <code>Graphic</code> 的对象，利用基类指针实现多态。</li><li><strong>好处：</strong> 能够在运行时处理不同类型的组件，而不需要预先知道具体的派生类类型。</li></ul></li></ul><p><strong>如何实现虚拟构造：</strong></p><ul><li><p>通过在 <code>NLComponent</code> 基类中定义虚拟克隆函数（<code>clone</code>），在派生类中实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NLComponent</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">NLComponent</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> NLComponent* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span> : <span class="keyword">public</span> NLComponent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TextBlock* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TextBlock</span>(*<span class="keyword">this</span>); <span class="comment">// 返回当前对象的副本</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graphic</span> : <span class="keyword">public</span> NLComponent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Graphic* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Graphic</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>当 <code>NewsLetter</code> 需要动态创建组件时，调用基类的 <code>clone</code> 方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NLComponent* component = <span class="keyword">new</span> <span class="built_in">TextBlock</span>();</span><br><span class="line">NLComponent* new_component = component-&gt;<span class="built_in">clone</span>();</span><br></pre></td></tr></table></figure></li></ul><img src="/2025/01/25/CPP-2-4/image-20241229141318307.png" class="" title="image-20241229141318307"><p><strong>1. 基本类结构</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NLComponent</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span> : <span class="keyword">public</span> NLComponent &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graphic</span> : <span class="keyword">public</span> NLComponent &#123; ... &#125;;</span><br></pre></td></tr></table></figure><ul><li><strong><code>NLComponent</code></strong> 是基类，定义了所有组件的通用接口。</li><li><strong><code>TextBlock</code> 和 <code>Graphic</code></strong> 是 <code>NLComponent</code> 的派生类，分别代表文本块和图形块。</li></ul><p><strong>2. 类 <code>NewsLetter</code> 的设计</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NewsLetter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NewsLetter</span>(istream&amp; str) &#123;</span><br><span class="line">        <span class="keyword">while</span> (str)</span><br><span class="line">            components.<span class="built_in">push_back</span>(<span class="built_in">readComponent</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> NLComponent* <span class="title">readComponent</span><span class="params">(istream&amp; str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    list&lt;NLComponent*&gt; components;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>构造函数 <code>NewsLetter(istream&amp; str)</code></strong></p><ul><li><strong>作用：</strong><ul><li>从输入流 <code>str</code> 中读取组件（如 <code>TextBlock</code> 或 <code>Graphic</code>），并将它们存储到 <code>components</code> 列表中。</li><li><code>components</code> 是一个指向 <code>NLComponent</code> 的指针列表，用于存储动态分配的对象。</li></ul></li><li><strong>实现：</strong><ul><li>调用静态成员函数 <code>readComponent(str)</code> 从流中读取并解析组件。</li></ul></li></ul><p><strong>静态函数 <code>readComponent(istream&amp; str)</code></strong></p><ul><li><strong>作用：</strong><ul><li>根据流中的数据，动态创建 <code>TextBlock</code> 或 <code>Graphic</code> 对象并返回。</li></ul></li><li><strong>实现思路：</strong><ul><li><code>readComponent</code> 解析流中组件的类型（如 “TextBlock” 或 “Graphic”），然后通过 <code>new</code> 操作符创建对应的派生类对象，并将其返回。</li></ul></li></ul><p><strong>3. 拷贝构造函数的实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NewsLetter</span>(<span class="type">const</span> NewsLetter&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">for</span> (list&lt;NLComponent*&gt;::iterator it = rhs.components.<span class="built_in">begin</span>();</span><br><span class="line">         it != rhs.components.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        components.<span class="built_in">push_back</span>(???);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题描述：</strong></p><ul><li>当使用拷贝构造函数时，如何从 <code>rhs</code> 的 <code>components</code> 列表中复制组件到当前对象？</li><li><code>components.push_back(???)</code> 中的 <code>???</code> 部分需要完成对组件的深拷贝。</li></ul><p><strong>解决思路：</strong></p><ul><li>因为 <code>components</code> 中存储的是 <code>NLComponent*</code> 类型的指针，而 <code>NLComponent</code> 是一个多态基类，必须通过虚拟克隆机制创建正确的派生类副本。</li></ul><p><strong>解决方案：使用虚拟克隆函数</strong></p><ul><li><p>在 <code>NLComponent</code> 中添加虚函数 <code>clone</code>，每个派生类实现自己的 <code>clone</code> 方法。</p></li><li><p><strong><code>NLComponent</code> 的修改：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NLComponent</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">NLComponent</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> NLComponent* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// 定义纯虚函数 clone</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>派生类的实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span> : <span class="keyword">public</span> NLComponent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TextBlock* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TextBlock</span>(*<span class="keyword">this</span>); <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graphic</span> : <span class="keyword">public</span> NLComponent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Graphic* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Graphic</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>完成拷贝构造函数：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NewsLetter</span>(<span class="type">const</span> NewsLetter&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">for</span> (list&lt;NLComponent*&gt;::iterator it = rhs.components.<span class="built_in">begin</span>();</span><br><span class="line">         it != rhs.components.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        components.<span class="built_in">push_back</span>((*it)-&gt;<span class="built_in">clone</span>()); <span class="comment">// 调用多态 clone 函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>运行时多态实现深拷贝：</strong></p><ul><li><code>(*it)-&gt;clone()</code> 调用的是指针 <code>*it</code> 指向的对象的 <code>clone</code> 方法。</li><li>根据 <code>*it</code> 的实际类型（<code>TextBlock</code> 或 <code>Graphic</code>），会动态调用派生类的 <code>clone</code> 方法，确保拷贝的是正确的派生类对象。</li></ul><p><strong>4. 总结实现细节</strong></p><ul><li><p><strong><code>readComponent</code> 的作用：</strong></p><ul><li>在构造函数中动态创建对象。</li><li>实现时可根据流数据的格式动态识别类型，例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NLComponent* <span class="title">NewsLetter::readComponent</span><span class="params">(istream&amp; str)</span> </span>&#123;</span><br><span class="line">    string type;</span><br><span class="line">    str &gt;&gt; type;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="string">&quot;TextBlock&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TextBlock</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">&quot;Graphic&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Graphic</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>拷贝构造函数中动态深拷贝：</strong></p><ul><li>通过基类中的虚拟 <code>clone</code> 方法，动态克隆正确的派生类对象。</li></ul></li></ul><p><strong>核心知识点总结</strong></p><ol><li><p><strong>虚拟克隆机制：</strong></p><ul><li>在基类中定义 <code>clone</code> 虚函数，并在派生类中实现，以支持动态多态的深拷贝。</li></ul></li><li><p><strong>多态与工厂模式：</strong></p><ul><li>使用工厂方法（如 <code>readComponent</code>）动态创建派生类对象。</li><li>根据运行时数据决定对象的实际类型。</li></ul></li><li><p><strong>动态对象管理：</strong></p><ul><li>通过 <code>std::list&lt;NLComponent*&gt;</code> 存储动态分配的对象，便于实现多态。</li></ul></li><li><p><strong>拷贝构造函数中的问题：</strong></p><ul><li>必须确保对动态分配的对象进行深拷贝。</li><li>借助虚拟 <code>clone</code> 方法实现正确的对象复制。</li></ul></li></ol><p><strong>完整示例代码</strong></p><p>以下是基于 PPT 内容的完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NLComponent</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">NLComponent</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> NLComponent* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// 虚拟克隆函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span> : <span class="keyword">public</span> NLComponent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TextBlock* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TextBlock</span>(*<span class="keyword">this</span>); <span class="comment">// 深拷贝当前对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graphic</span> : <span class="keyword">public</span> NLComponent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Graphic* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Graphic</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewsLetter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NewsLetter</span>(istream&amp; str) &#123;</span><br><span class="line">        <span class="keyword">while</span> (str) &#123;</span><br><span class="line">            components.<span class="built_in">push_back</span>(<span class="built_in">readComponent</span>(str)); <span class="comment">// 动态创建组件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NewsLetter</span>(<span class="type">const</span> NewsLetter&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = rhs.components.<span class="built_in">begin</span>(); it != rhs.components.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            components.<span class="built_in">push_back</span>((*it)-&gt;<span class="built_in">clone</span>()); <span class="comment">// 动态深拷贝</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">NewsLetter</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> component : components) &#123;</span><br><span class="line">            <span class="keyword">delete</span> component; <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    list&lt;NLComponent*&gt; components;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> NLComponent* <span class="title">readComponent</span><span class="params">(istream&amp; str)</span> </span>&#123;</span><br><span class="line">        string type;</span><br><span class="line">        str &gt;&gt; type;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="string">&quot;TextBlock&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TextBlock</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">&quot;Graphic&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Graphic</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2025/01/25/CPP-2-4/image-20241229141916203.png" class="" title="image-20241229141916203"><h3 id="不支持数组多态">不支持数组多态</h3><img src="/2025/01/25/CPP-2-4/image-20241229141945819.png" class="" title="image-20241229141945819"><p>这张PPT的主题是“<strong>Never treat arrays polymorphically</strong>”（永远不要将数组以多态的方式对待）。它强调了C++数组在多态上下文中的行为问题，特别是<strong>子类数组被当作基类数组使用时可能出现的问题</strong>。</p><p><strong>问题背景</strong></p><p>代码片段描述了一个基本的二叉搜索树类（<code>BST</code>）及其派生类（<code>BalancedBST</code>），并尝试通过一个函数处理二叉搜索树的数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BalancedBST</span> : <span class="keyword">public</span> BST &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p><strong>函数 <code>printBSTArray</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBSTArray</span><span class="params">(ostream&amp; s, <span class="type">const</span> BST array[], <span class="type">int</span> numElements)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numElements; i++)</span><br><span class="line">        s &lt;&lt; array[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个函数接收一个 <code>ostream</code> 对象、一个 <code>BST</code> 类型的数组和数组大小 <code>numElements</code>。</li><li><strong>目标：</strong> 遍历数组中的每个元素并将其输出到流 <code>s</code>。</li></ul><p><strong>创建子类数组并调用函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BalancedBST bBSTArray[<span class="number">10</span>]; <span class="comment">// 创建一个 BalancedBST 类型的数组</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">printBSTArray</span>(cout, bBSTArray, <span class="number">10</span>); <span class="comment">// 将子类数组传递给函数</span></span><br></pre></td></tr></table></figure><ul><li>创建了一个大小为 <code>10</code> 的 <code>BalancedBST</code> 数组（子类对象）。</li><li>然后尝试将这个子类数组传递给 <code>printBSTArray</code> 函数，其中参数的类型是 <code>const BST array[]</code>（基类数组）。</li></ul><p><strong>问题分析</strong></p><p>C++ 不支持对数组的多态处理。以下是问题的根源：</p><p><strong>1. 数组退化为指针</strong></p><ul><li>在函数调用中，数组作为参数会退化为指向数组第一个元素的指针。</li><li>在这段代码中：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printBSTArray</span>(cout, bBSTArray, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><code>bBSTArray</code> 会退化为 <code>BalancedBST*</code> 类型的指针，但函数期望的是 <code>const BST*</code> 类型的指针。</li></ul><p><strong>2. 对象切割问题</strong></p><ul><li>虽然 <code>BalancedBST</code> 继承自 <code>BST</code>，但数组中的每个元素在函数内部会被当作 <code>BST</code> 类型的对象处理。</li><li>数组元素被传递时，会发生<strong>对象切割</strong>（Slicing），即 <code>BalancedBST</code> 对象的派生类部分（子类新增的成员变量和函数）会丢失，剩下的只有基类 <code>BST</code> 的部分。</li></ul><p><strong>3. 虚函数对输出的影响</strong></p><ul><li>如果 <code>BST</code> 类中定义了虚函数（如虚拟的输出运算符 <code>operator&lt;&lt;</code>），可以避免对象切割导致的问题：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; s) <span class="type">const</span>;</span><br></pre></td></tr></table></figure></li><li>如果没有虚函数，<code>s &lt;&lt; array[i]</code> 会调用基类的 <code>operator&lt;&lt;</code> 实现，而不是子类的。</li></ul><p><strong>输出操作问题：</strong></p><ul><li>如果 <code>BST</code> 类没有定义虚拟的 <code>operator&lt;&lt;</code>，输出的内容只会涉及基类部分的数据，无法正确处理派生类的扩展部分。</li><li>即使定义了虚拟函数，整个数组的多态行为也依然可能存在问题。</li></ul><p><strong>避免问题的建议</strong></p><p><strong>1. 使用指针数组</strong></p><p>改为存储基类指针的数组，这样可以避免对象切割：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list&lt;BST*&gt; bBSTArray; <span class="comment">// 使用基类指针存储对象</span></span><br><span class="line">bBSTArray.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">BalancedBST</span>());</span><br></pre></td></tr></table></figure><ul><li>通过存储基类指针，可以正确地处理派生类对象。</li><li>使用虚函数确保动态分派（动态多态）。</li></ul><p><strong>2. 显式克隆对象</strong></p><p>为基类添加虚拟的克隆函数（<code>clone</code>），通过指针复制派生类对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">BST</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> BST* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BalancedBST</span> : <span class="keyword">public</span> BST &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">BalancedBST* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BalancedBST</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在函数中处理克隆后的对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BST* obj = bBSTArray[i]-&gt;<span class="built_in">clone</span>();</span><br><span class="line">s &lt;&lt; *obj;</span><br><span class="line"><span class="keyword">delete</span> obj;</span><br></pre></td></tr></table></figure><p><strong>3. 使用STL容器和智能指针</strong></p><p>用 STL 容器（如 <code>std::vector</code>）和智能指针（如 <code>std::shared_ptr</code>）存储对象，确保内存安全并支持多态：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;std::shared_ptr&lt;BST&gt;&gt; components;</span><br><span class="line">components.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;BalancedBST&gt;());</span><br></pre></td></tr></table></figure><p>函数可以直接操作容器中的对象，避免对象切割的问题。</p><p><strong>4. 动态分配数组</strong></p><p>如果必须使用数组，可以通过动态分配来确保多态行为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BST* bBSTArray[<span class="number">10</span>]; <span class="comment">// 指针数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    bBSTArray[i] = <span class="keyword">new</span> <span class="built_in">BalancedBST</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>printBSTArray</code> 函数中，直接操作基类指针数组即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBSTArray</span><span class="params">(ostream&amp; s, BST* array[], <span class="type">int</span> numElements)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numElements; ++i) &#123;</span><br><span class="line">        s &lt;&lt; *array[i]; <span class="comment">// 调用虚函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得在使用完后释放动态分配的内存：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">delete</span> bBSTArray[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ol><li><p><strong>数组的多态性问题：</strong></p><ul><li>在 C++ 中，数组无法实现真正的多态。</li><li>子类数组被当作基类数组时，会发生对象切割。</li></ul></li><li><p><strong>避免对象切割的方案：</strong></p><ul><li>使用基类指针数组。</li><li>在基类中定义虚拟的 <code>clone</code> 函数，动态创建派生类对象。</li><li>使用 STL 容器和智能指针（推荐）。</li></ul></li><li><p><strong>更安全的设计：</strong></p><ul><li>尽量避免直接使用数组，改用标准容器（如 <code>std::vector</code>）。</li><li>通过虚函数实现运行时的动态分派，确保派生类对象被正确处理。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++高级程序设计笔记（C2-5）</title>
      <link href="/2025/01/25/CPP-2-5/"/>
      <url>/2025/01/25/CPP-2-5/</url>
      
        <content type="html"><![CDATA[<h1>CPP-2-5</h1><img src="/2025/01/25/CPP-2-5/image-20241229143615079.png" class="" title="image-20241229143615079"><img src="/2025/01/25/CPP-2-5/image-20241229143622101.png" class="" title="image-20241229143622101"><h2 id="右值">右值</h2><img src="/2025/01/25/CPP-2-5/image-20241229143712855.png" class="" title="image-20241229143712855"><p>左值：</p><ul><li>左值是指具有存储地址的对象，在程序运行时可以通过其地址进行访问。</li><li>左值是可以被取地址的对象（<code>&amp;</code> 运算符可以作用于左值）。</li><li>左值通常代表在内存中存在的持久性存储（即变量、数组元素、对象等）。</li><li>左值可以出现在赋值语句的左侧。</li></ul><p>右值：</p><ul><li>右值是不能取地址的（<code>&amp;</code> 运算符不能作用于右值）。</li><li>右值通常是一些字面量（如 <code>1</code>, <code>2.5</code>, <code>'c'</code>）或者是表达式的结果（如 <code>1 + 2</code>，函数返回的临时对象）。</li><li>右值不能出现在赋值语句的左侧。</li></ul><p><strong>L-value 和 R-value 的关键区别</strong></p><table><thead><tr><th><strong>特性</strong></th><th><strong>L-value</strong></th><th><strong>R-value</strong></th></tr></thead><tbody><tr><td><strong>存储地址</strong></td><td>有存储地址，可以通过指针访问</td><td>无存储地址，通常是临时值</td></tr><tr><td><strong>可否取地址</strong></td><td>可以通过 <code>&amp;</code> 运算符取地址</td><td>无法取地址</td></tr><tr><td><strong>使用位置</strong></td><td>可用于赋值语句左侧</td><td>通常是表达式结果或临时对象</td></tr><tr><td><strong>生存期</strong></td><td>具有较长的生命周期，通常在作用域内有效</td><td>生命周期短暂，仅在表达式求值期间有效</td></tr></tbody></table><h3 id="const引用可绑右值">const引用可绑右值</h3><img src="/2025/01/25/CPP-2-5/image-20241229143731243.png" class="" title="image-20241229143731243"><ul><li><strong>非<code>const</code>引用</strong>（Non-const references）只能绑定到左值（L-value）。</li><li><strong><code>const</code>引用</strong>（Const references）既可以绑定到左值，也可以绑定到右值（R-value）。</li><li><strong>非<code>const</code>引用</strong>无法绑定到右值。</li></ul><img src="/2025/01/25/CPP-2-5/image-20241229144215194.png" class="" title="image-20241229144215194"><ul><li><strong>右值引用允许对右值进行修改和操作。</strong></li><li>在某些情况下，可以通过右值引用高效地操作临时对象，从而提升性能。</li></ul><h3 id="移动构造函数的潜在触发">移动构造函数的潜在触发</h3><img src="/2025/01/25/CPP-2-5/image-20241229144343159.png" class="" title="image-20241229144343159"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyArray <span class="title">myArr</span><span class="params">(<span class="number">5</span>)</span></span>;                  <span class="comment">// 调用带参数的构造函数</span></span><br><span class="line">    MyArray myArr2 = <span class="built_in">change_aw</span>(myArr); <span class="comment">// 调用拷贝构造函数和移动构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用过程分析：</strong></p><ol><li><strong><code>MyArray myArr(5)</code></strong><ul><li>调用带参数的构造函数，初始化 <code>myArr</code>。</li></ul></li><li><strong><code>change_aw(myArr)</code></strong><ul><li>调用 <code>change_aw</code> 时，<code>myArr</code> 以常量引用方式传递。</li><li>在 <code>change_aw</code> 内部：<ul><li>调用 <code>MyArray(int sz)</code> 构造函数创建局部对象 <code>aw</code>。</li><li><strong>返回 <code>aw</code> 时调用移动构造函数</strong>，<strong>将 <code>aw</code> 的资源转移给调用者的目标对象</strong>。</li></ul></li></ul></li><li><strong><code>MyArray myArr2 = change_aw(myArr)</code></strong><ul><li>将 <code>change_aw</code> 返回的<strong>临时对象</strong>移动到 <code>myArr2</code>。</li><li>调用<strong>移动构造函数</strong>，避免了临时对象的深拷贝。</li></ul></li></ol><img src="/2025/01/25/CPP-2-5/image-20241229144709715.png" class="" title="image-20241229144709715"><h2 id="Extern-Templates">Extern Templates</h2><img src="/2025/01/25/CPP-2-5/image-20241229144721415.png" class="" title="image-20241229144721415"><p><strong>1. 什么是Extern Templates？</strong></p><ul><li>在C++中，模板函数或模板类会在每个使用它们的翻译单元（translation unit）中被实例化。</li><li>如果同一个模板在多个翻译单元中被实例化，会导致冗余的代码生成，增加编译时间和最终二进制文件的大小。</li><li><strong>Extern Templates</strong> 是C++11引入的一种机制，允许开发者显式声明<strong>某些模板实例化发生在其他翻译单元中，避免重复实例化</strong>。</li></ul><p><strong>2. 为什么需要Extern Templates？</strong></p><p><strong>模板的实例化规则</strong></p><ul><li>当模板被使用时（如调用模板函数或实例化模板类对象），编译器会自动生成（实例化）模板代码。</li><li>如果一个模板在多个 <code>.cpp</code> 文件中被使用，那么每个文件都会生成该模板的实例代码，这会导致冗余的实例化。</li></ul><p><strong>冗余实例化的影响</strong></p><ol><li><strong>编译时间增加：</strong> 每个翻译单元都要重新实例化模板。</li><li><strong>可执行文件增大：</strong> 每个翻译单元生成的模板实例化代码可能会被重复链接。</li></ol><p><strong>解决方法：</strong></p><ul><li>使用 Extern Templates，可以显式告诉编译器，某些模板实例化已经在其他翻译单元中完成，不需要在当前翻译单元中再次实例化。</li></ul><p><strong>3. PPT代码解析</strong></p><p><strong>代码结构</strong></p><ul><li>代码分为三个文件：<code>myfunc.h</code>（头文件）、<code>test.cpp</code> 和 <code>main.cpp</code>。</li></ul><p><strong>1. <code>myfunc.h</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">(T t)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>定义了一个模板函数 <code>myfunc</code>，接受一个参数 <code>t</code>。</li><li>此模板函数可以针对任意类型 <code>T</code> 实例化。</li></ul><p><strong>2. <code>test.cpp</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myfunc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">myfunc</span>(<span class="number">1</span>);  <span class="comment">// 实例化 myfunc&lt;int&gt;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <code>test.cpp</code> 中调用了 <code>myfunc(1)</code>。</li><li>由于 <code>1</code> 是 <code>int</code> 类型，这里会实例化 <code>myfunc&lt;int&gt;</code>。</li></ul><p><strong>3. <code>main.cpp</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myfunc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 告诉编译器：该模板实例化已经在其他翻译单元中完成 */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="type">void</span> <span class="built_in">myfunc</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">myfunc</span>(<span class="number">1</span>);  <span class="comment">// 使用 extern 声明的实例化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>extern template</code> 声明：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="type">void</span> <span class="built_in">myfunc</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span>);</span><br></pre></td></tr></table></figure><ul><li>告诉编译器，<code>myfunc&lt;int&gt;</code> 的实例化已经在其他翻译单元（如 <code>test.cpp</code>）中完成。</li><li>编译器不会在 <code>main.cpp</code> 中再次实例化 <code>myfunc&lt;int&gt;</code>。</li></ul></li><li><p><strong>调用 <code>myfunc(1)</code>：</strong></p><ul><li>使用的是 <code>test.cpp</code> 中生成的 <code>myfunc&lt;int&gt;</code> 的实例化代码，而不会再次生成。</li></ul></li></ul><p><strong>4. Extern Templates的工作机制</strong></p><p><strong>1. 明确分工</strong></p><ul><li><strong>定义实例化：</strong><ul><li>在一个翻译单元中显式实例化模板，使用 <code>template</code> 关键字。</li><li>示例（添加在 <code>test.cpp</code>）：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="type">void</span> <span class="built_in">myfunc</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span>); <span class="comment">// 显式实例化 myfunc&lt;int&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><strong>声明实例化：</strong><ul><li>在其他翻译单元中使用 <code>extern template</code> 声明，告诉编译器实例化已经在别处完成。</li><li>示例（在 <code>main.cpp</code>）：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="type">void</span> <span class="built_in">myfunc</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>2. 编译器行为</strong></p><ul><li>在有 <code>extern template</code> 声明的翻译单元中，编译器不会实例化模板代码，而是使用其他翻译单元中定义的实例化代码。</li></ul><p><strong>3. 链接阶段</strong></p><ul><li>链接器将所有翻译单元中生成的代码合并，避免重复实例化的模板代码。</li></ul><h2 id="常量表达式">常量表达式</h2><img src="/2025/01/25/CPP-2-5/image-20241229145439519.png" class="" title="image-20241229145439519"><img src="/2025/01/25/CPP-2-5/image-20241229145518233.png" class="" title="image-20241229145518233"><img src="/2025/01/25/CPP-2-5/image-20241229145533072.png" class="" title="image-20241229145533072"><p><strong>Constant Expressions 概述</strong></p><p><strong>内容解析</strong></p><ol><li><p><strong>“Provides more general constant expressions”</strong></p><ul><li><code>constexpr</code> 提供了一种更加通用的方式来定义常量表达式，支持在编译期计算复杂的表达式，而不仅仅是简单的数值常量。</li></ul></li><li><p><strong>“Allows constant expressions involving user-defined types”</strong></p><ul><li>在C++11及之后，<code>constexpr</code>支持用户自定义类型的常量表达式（如类、结构体等）。</li><li>这使得用户可以编写更加灵活且高效的代码。</li></ul></li><li><p><strong>“Provides a way to guarantee that an initialization is done at compile time”</strong></p><ul><li>使用<code>constexpr</code>关键字可以保证某些<strong>初始化在编译时完成</strong>，从而提升运行时效率。</li><li>如果某个表达式无法在编译时计算，编译器会报错。</li></ul></li></ol><p>第二张PPT：<strong>Example 1 - Flags 示例</strong></p><p><strong>代码解析</strong></p><p><strong>1. 枚举类型 <code>Flags</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Flags</span> &#123; GOOD=<span class="number">0</span>, FAIL=<span class="number">1</span>, BAD=<span class="number">2</span>, EOF=<span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure><ul><li>定义了一个枚举类型<code>Flags</code>，表示不同的标志状态。</li></ul><p><strong>2. <code>constexpr</code>运算符重载</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="keyword">operator</span>|(Flags f1, Flags f2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Flags</span>(<span class="built_in">int</span>(f1) | <span class="built_in">int</span>(f2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重载了按位或运算符<code>|</code>，用于枚举类型<code>Flags</code>的按位操作。</li><li>使用<code>constexpr</code>保证这个操作可以在编译时执行。</li></ul><p><strong>3. 问题：return值不是常量</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> BAD|EOF: <span class="comment">// ERROR: return value is not const</span></span><br></pre></td></tr></table></figure><ul><li>如果没有constexpr，那么就会报错</li><li>编译器对<code>case</code>语句的值有严格要求，必须是编译期的<strong>常量值</strong>。</li></ul><p>第三张PPT：<strong>Example 2 - Point 类的常量表达式</strong></p><p><strong>代码解析</strong></p><p><strong>1. 结构体 <code>Point</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Point</span><span class="params">(<span class="type">int</span> xx, <span class="type">int</span> yy)</span> : x(xx), y(yy) &#123;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>定义了一个结构体 <code>Point</code>，表示平面上的一个点。</li><li>构造函数使用<code>constexpr</code>修饰，表示<strong>这个类的实例可以用于常量表达式</strong>。</li><li><strong>条件：</strong> <strong>所有成员变量的初始化必须在编译期完成</strong>。</li></ul><p><strong>2. 编译期实例化常量对象</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">origo</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> z = origo.x;</span><br></pre></td></tr></table></figure><ul><li><code>origo</code> 是一个常量对象，表示原点 <code>(0, 0)</code>。</li><li><code>z</code> 是一个常量，值为 <code>origo.x</code>。</li><li>这些操作都在编译时完成，不会影响运行时性能。</li></ul><p><strong>3. 常量数组</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> Point a[] = &#123; <span class="built_in">Point</span>(<span class="number">0</span>,<span class="number">0</span>), <span class="built_in">Point</span>(<span class="number">1</span>,<span class="number">1</span>), <span class="built_in">Point</span>(<span class="number">2</span>,<span class="number">2</span>) &#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> x = a[<span class="number">1</span>].x; <span class="comment">// x becomes 1</span></span><br></pre></td></tr></table></figure><ul><li>定义了一个<code>constexpr</code>数组，包含多个常量点。</li><li>数组中的每个点都是在编译时初始化的。</li><li><code>x</code> 获取数组中第二个点的<code>x</code>坐标，值为 <code>1</code>。</li></ul><p><strong>运行时效率的提升</strong></p><ul><li><strong>所有计算都在编译期完成：</strong><ul><li>构造点对象。</li><li>初始化数组。</li><li>访问数组元素。</li></ul></li><li><strong>运行时无额外开销：</strong><ul><li>程序运行时直接使用已经计算好的值。</li></ul></li></ul><p><strong>全局总结</strong></p><p><strong>1. 什么是<code>constexpr</code>？</strong></p><ul><li><code>constexpr</code>是C++11引入的关键字，用于定义<strong>可以在编译期计算的常量表达式</strong>。</li><li>适用于变量、函数、构造函数、类成员等场景。</li></ul><p><strong>2. <code>constexpr</code>的作用</strong></p><ol><li><strong>提升性能：</strong><ul><li>在编译期完成计算，减少运行时开销。</li></ul></li><li><strong>更灵活的常量表达式：</strong><ul><li>支持用户自定义类型（如类和结构体）的常量表达式。</li></ul></li><li><strong>编译期验证：</strong><ul><li>编译器会验证<code>constexpr</code>表达式是否符合编译期计算的要求。</li><li>如果不符合，编译会报错。</li></ul></li></ol><p><strong>3. 使用<code>constexpr</code>的注意事项</strong></p><ol><li>表达式中的所有操作必须是编译期可计算的。<ul><li>例如，不能使用非<code>constexpr</code>的函数或构造函数。</li></ul></li><li>使用<code>constexpr</code>函数或构造函数时，输入参数必须是常量。</li><li>在常量表达式中，确保所有变量和函数都支持编译期计算。</li></ol><p><strong>4. 实际应用场景</strong></p><ol><li><strong>常量初始化：</strong><ul><li>定义编译期常量，提升效率。</li></ul></li><li><strong>模板元编程：</strong><ul><li>使用<code>constexpr</code>函数简化模板元编程逻辑。</li></ul></li><li><strong>数组初始化：</strong><ul><li>使用<code>constexpr</code>数组减少运行时初始化的开销。</li></ul></li></ol><h2 id="Lambda表达式">Lambda表达式</h2><img src="/2025/01/25/CPP-2-5/image-20241229150145034.png" class="" title="image-20241229150145034"><img src="/2025/01/25/CPP-2-5/image-20241229150222120.png" class="" title="image-20241229150222120"><img src="/2025/01/25/CPP-2-5/image-20241229150239716.png" class="" title="image-20241229150239716"><h3 id="Lambda捕获">Lambda捕获</h3><img src="/2025/01/25/CPP-2-5/image-20241229150248289.png" class="" title="image-20241229150248289"><p><strong>捕获语法</strong></p><ol><li><p><strong><code>[]</code></strong></p><ul><li>不捕获任何变量。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda = []() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">lambda</span>(); <span class="comment">// 输出: Hello, World!</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>[&amp;]</code></strong></p><ul><li>按引用捕获所有在 Lambda 中使用的外部变量。</li><li>外部变量的任何修改都会反映到原始变量上。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> lambda = [&amp;]() &#123;</span><br><span class="line">    x += <span class="number">5</span>; <span class="comment">// 按引用捕获，可以修改 x</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">lambda</span>();</span><br><span class="line">std::cout &lt;&lt; x; <span class="comment">// 输出: 15</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>[=]</code></strong></p><ul><li><strong>按值捕获所有在 Lambda 中使用的外部变量</strong>。</li><li>Lambda 中的变量是捕获时的副本，修改不会影响原始变量。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> lambda = [=]() &#123;</span><br><span class="line">    <span class="comment">// x += 5; // 错误：按值捕获不能修改 x</span></span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl; <span class="comment">// 输出: 10</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">lambda</span>();</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>[=, &amp;foo]</code></strong></p><ul><li>按值捕获所有变量，但特定变量（如 <code>foo</code>）按引用捕获。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">auto</span> lambda = [=, &amp;x]() &#123;</span><br><span class="line">    x += <span class="number">5</span>; <span class="comment">// 按引用捕获，可以修改 x</span></span><br><span class="line">    <span class="comment">// y += 5; // 错误：按值捕获，不能修改 y</span></span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; std::endl; <span class="comment">// 输出: 15, 20</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">lambda</span>();</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>[bar]</code></strong></p><ul><li>捕获指定的变量（如 <code>bar</code>）按值，其余变量不捕获。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">auto</span> lambda = [x]() &#123;</span><br><span class="line">    <span class="comment">// y += 5; // 错误：未捕获变量 y</span></span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl; <span class="comment">// 输出: 10</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">lambda</span>();</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>3. 捕获方式的作用范围</strong></p><ol><li><p><strong>按值捕获（<code>[=]</code> 或 <code>[bar]</code>）</strong></p><ul><li>捕获的是变量的副本，Lambda 内的修改不会影响原始变量。</li><li>适用于只需要读取外部变量，不需要修改的场景。</li></ul></li><li><p><strong>按引用捕获（<code>[&amp;]</code> 或 <code>[&amp;, foo]</code>）</strong></p><ul><li>捕获的是变量的引用，Lambda 内的修改会反映到原始变量上。</li><li>适用于需要修改外部变量的场景。</li></ul></li></ol><p><strong>4. 特殊说明：默认捕获和显式捕获混用</strong></p><ul><li>可以混用默认捕获模式和显式捕获：<ul><li><code>[=, &amp;foo]</code>：按值捕获所有变量，但对 <code>foo</code> 按引用捕获。</li><li><code>[&amp;, foo]</code>：按引用捕获所有变量，但对 <code>foo</code> 按值捕获。</li></ul></li></ul><p><strong>5. Lambda 捕获的注意事项</strong></p><ol><li><p><strong>捕获的变量生命周期</strong></p><ul><li>按值捕获的变量是捕获时的副本，与原始变量无关。</li><li>按引用捕获的变量要求原始变量在 Lambda 的生命周期内有效。</li></ul></li><li><p><strong>可变性（<code>mutable</code> 修饰符）</strong></p><ul><li>默认情况下，按值捕获的变量在 Lambda 内是不可修改的。</li><li>使用 <code>mutable</code> 关键字可以允许修改按值捕获的变量。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> lambda = [x]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">    x += <span class="number">5</span>; <span class="comment">// 可以修改 x，因为加了 mutable</span></span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl; <span class="comment">// 输出: 15</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">lambda</span>();</span><br><span class="line">std::cout &lt;&lt; x; <span class="comment">// 输出: 10（原始变量未被修改）</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>C++14 中的扩展</strong></p><ul><li>C++14 允许在捕获列表中捕获表达式：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> lambda = [z = x + <span class="number">5</span>]() &#123;</span><br><span class="line">    std::cout &lt;&lt; z &lt;&lt; std::endl; <span class="comment">// 输出: 15</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">lambda</span>();</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>6. 总结</strong></p><ol><li><p><strong>捕获方式：</strong></p><ul><li><code>[ ]</code>：不捕获任何变量。</li><li><code>[&amp;]</code>：按引用捕获所有使用的外部变量。</li><li><code>[=]</code>：按值捕获所有使用的外部变量。</li><li><code>[=, &amp;foo]</code>：按值捕获所有变量，但对 <code>foo</code> 按引用捕获。</li><li><code>[bar]</code>：按值捕获指定变量，其余不捕获。</li></ul></li><li><p><strong>按值捕获与按引用捕获的选择：</strong></p><ul><li><strong>按值捕获：</strong> 安全性更高，适合只读操作。</li><li><strong>按引用捕获：</strong> 更高效，适合需要修改外部变量的场景。</li></ul></li><li><p><strong>扩展功能：</strong></p><ul><li>使用 <code>mutable</code> 允许按值捕获的变量在 Lambda 内部被修改。</li><li>C++14 引入的捕获表达式使捕获更加灵活。</li></ul></li></ol><h2 id="Delegating委托构造函数">Delegating委托构造函数</h2><img src="/2025/01/25/CPP-2-5/image-20241229150501932.png" class="" title="image-20241229150501932"><p><strong>1. 什么是委托构造函数？</strong></p><ul><li><strong>定义：</strong><ul><li><strong>委托构造函数</strong>是指一个构造函数通过调用同一类的另一个构造函数来完成部分或全部初始化工作。</li></ul></li><li><strong>特性：</strong><ul><li>C++11 引入。</li><li>减少代码重复，方便统一管理初始化逻辑。</li><li>提高代码的可维护性。</li></ul></li></ul><p><strong>2. 第一部分代码解析</strong></p><p><strong>类定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">validate</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &lt; x &amp;&amp; x &lt;= MAX) </span><br><span class="line">            a = x; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">bad_X</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> x) &#123; <span class="built_in">validate</span>(x); &#125;</span><br><span class="line">    <span class="built_in">X</span>() &#123; <span class="built_in">validate</span>(<span class="number">42</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><ol><li><p><strong>成员函数 <code>validate</code></strong></p><ul><li>验证参数 <code>x</code> 是否在合法范围 <code>[1, MAX]</code> 内。</li><li>如果合法，将 <code>x</code> 赋值给成员变量 <code>a</code>；否则抛出异常。</li></ul></li><li><p><strong>构造函数 <code>X(int x)</code></strong></p><ul><li>调用 <code>validate(x)</code>，验证参数 <code>x</code> 并完成初始化。</li></ul></li><li><p><strong>构造函数 <code>X()</code></strong></p><ul><li>默认构造函数中调用 <code>validate(42)</code>，使用默认值 <code>42</code> 初始化 <code>a</code>。</li></ul></li></ol><p><strong>问题：代码重复</strong></p><ul><li>两个构造函数都调用了 <code>validate</code>，存在重复逻辑。</li></ul><p><strong>3. 第二部分代码解析：使用委托构造函数优化</strong></p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &lt; x &amp;&amp; x &lt;= MAX) </span><br><span class="line">            a = x; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">bad_X</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">X</span>() : <span class="built_in">X</span>(<span class="number">42</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><ol><li><p><strong>构造函数 <code>X(int x)</code></strong></p><ul><li>完成所有验证和成员变量的初始化逻辑。</li></ul></li><li><p><strong>构造函数 <code>X()</code></strong></p><ul><li>委托给 <code>X(42)</code>。</li><li>调用 <code>X(int x)</code> 构造函数，直接传递默认值 <code>42</code>，避免了重复逻辑。</li></ul></li></ol><p><strong>4. 示例分析</strong></p><p><strong>问题：<code>X(int x = 42)</code> 是什么意思？</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">X</span>(<span class="type">int</span> x = <span class="number">42</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>这是一个带默认参数的构造函数。</li><li>如果调用时未提供参数，则使用默认值 <code>42</code>。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X obj1;        <span class="comment">// 等价于 X obj1(42);</span></span><br><span class="line"><span class="function">X <span class="title">obj2</span><span class="params">(<span class="number">100</span>)</span></span>;   <span class="comment">// 使用提供的值 100</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>5. 委托构造函数的优点</strong></p><ol><li><p><strong>减少代码重复</strong></p><ul><li>通过调用一个通用的构造函数，实现不同的初始化方式，避免重复编写初始化逻辑。</li></ul></li><li><p><strong>提高代码可读性</strong></p><ul><li>让构造函数的逻辑更清晰，便于维护。</li></ul></li><li><p><strong>统一初始化逻辑</strong></p><ul><li>所有的初始化逻辑集中在一个构造函数中，不容易出错。</li></ul></li></ol><h2 id="Uniform统一初始化">Uniform统一初始化</h2><img src="/2025/01/25/CPP-2-5/image-20241229150837424.png" class="" title="image-20241229150837424"><p><strong>1. 什么是 Uniform Initialization？</strong></p><ul><li><p><strong>定义：</strong></p><ul><li>统一初始化是C++11引入的一种新语法，用于用大括号 <code>&#123;&#125;</code> 初始化变量或对象。</li><li>它提供了一种<strong>统一的方式来初始化数组、基本类型、STL容器、自定义类等</strong>。</li></ul></li><li><p><strong>特点：</strong></p><ul><li>避免了传统初始化方法的二义性。</li><li>支持列表初始化（<code>initializer_list</code>），可以直接对容器或类进行初始化。</li></ul></li></ul><p><strong>2. 对比旧的初始化方式</strong></p><p><strong>旧风格初始化（Old style initialization）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;         <span class="comment">// 可以直接用花括号初始化数组</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;               <span class="comment">// 先定义再调用 push_back() 添加元素</span></span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><strong>存在的问题：</strong></p><ol><li><p><strong>数组初始化是特例：</strong></p><ul><li>只有数组可以用 <code>&#123;&#125;</code> 初始化，而其他容器（如<code>std::vector</code>）需要使用成员函数（如<code>push_back</code>）逐个添加元素。</li></ul></li><li><p><strong>初始化的二义性：</strong></p><ul><li>使用圆括号 <code>()</code> 可能会引发二义性问题：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;         <span class="comment">// 初始化 x 为 0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">()</span></span>;          <span class="comment">// 声明了一个返回 `int` 的函数</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>新风格初始化（New style initialization）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;   <span class="comment">// 统一使用大括号初始化</span></span><br></pre></td></tr></table></figure><p><strong>解决的问题：</strong></p><ol><li><p><strong>统一语法：</strong></p><ul><li>无论是数组、STL容器，还是自定义类，都可以使用大括号 <code>&#123;&#125;</code> 进行初始化。</li></ul></li><li><p><strong>支持列表初始化：</strong></p><ul><li>编译器将 <code>&#123;&#125;</code> 解析为 <code>initializer_list</code>，从而简化了初始化逻辑。</li></ul></li><li><p><strong>避免二义性：</strong></p><ul><li>使用 <code>&#123;&#125;</code> 初始化时，不会被误解为函数声明。</li></ul></li></ol><p><strong>3. 示例代码解析</strong></p><p><strong>列表初始化</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>作用：</strong><ul><li><code>&#123;1, 2, 3&#125;</code> 会被编译器解释为 <code>initializer_list&lt;int&gt;</code>。</li><li>STL 容器（如 <code>vector</code>）提供了一个接收 <code>initializer_list</code> 的构造函数，能够处理该初始化语法。</li></ul></li></ul><p><strong>自定义类的支持</strong></p><p><strong>模板类的实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span> &#123;</span><br><span class="line">    <span class="built_in">vector</span>(initializer_list&lt;T&gt; list) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = list.<span class="built_in">begin</span>(); it != list.<span class="built_in">end</span>(); ++it)</span><br><span class="line">            <span class="built_in">push_back</span>(*it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>initializer_list</code> 构造函数：</strong></p><ul><li><code>initializer_list&lt;T&gt;</code> 是一个标准类，用于处理 <code>&#123;&#125;</code> 初始化。</li><li>编译器会将 <code>&#123;1, 2, 3&#125;</code> 转换为 <code>initializer_list&lt;int&gt;</code>，传递给类的构造函数。</li></ul></li><li><p><strong>工作原理：</strong></p><ul><li>构造函数通过迭代 <code>initializer_list</code> 中的元素，依次调用 <code>push_back</code> 方法，将值添加到容器中。</li></ul></li></ul><p><strong>类 <code>A</code> 的初始化</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><strong>条件：</strong></p><ul><li>类 <code>A</code> 需要定义一个接受 <code>initializer_list</code> 的构造函数：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(initializer_list&lt;<span class="type">int</span>&gt; list) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : list) &#123;</span><br><span class="line">            <span class="comment">// 处理列表中的每个值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>结果：</strong></p><ul><li><code>&#123;1, 2, 3&#125;</code> 会被解析为 <code>initializer_list&lt;int&gt;</code>，并传递给构造函数。</li></ul></li></ul><p><strong>4. Uniform Initialization 的优点</strong></p><ol><li><p><strong>语法统一：</strong></p><ul><li>使用 <code>&#123;&#125;</code> 统一初始化语法，适用于数组、STL容器、自定义类等。</li></ul></li><li><p><strong>列表初始化：</strong></p><ul><li>支持通过 <code>initializer_list</code> 直接对对象进行批量初始化，简化代码。</li></ul></li><li><p><strong>避免二义性：</strong></p><ul><li>使用 <code>&#123;&#125;</code> 初始化不会被误解为函数声明。</li></ul></li><li><p><strong>兼容旧代码：</strong></p><ul><li>传统的初始化方式仍然有效，新语法是向后兼容的。</li></ul></li></ol><p><strong>5. 注意事项</strong></p><ol><li><p><strong>优先级：</strong></p><ul><li>大括号 <code>&#123;&#125;</code> 初始化的优先级高于其他初始化方式。</li></ul></li><li><p><strong>窄化转换：</strong></p><ul><li>列表初始化会避免隐式的窄化转换（narrowing conversion）：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">2.5</span>;    <span class="comment">// OK，隐式截断</span></span><br><span class="line"><span class="type">int</span> y&#123;<span class="number">2.5</span>&#125;;     <span class="comment">// 错误，窄化转换被禁止</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>initializer_list</code> 的局限性：</strong></p><ul><li><code>initializer_list</code> 只能用于构造函数，不能用于成员函数。</li><li>其内部数据是只读的，不能修改。</li></ul></li></ol><p><strong>6. 总结</strong></p><ol><li><p><strong>统一初始化语法：</strong></p><ul><li>使用 <code>&#123;&#125;</code> 可以初始化数组、容器、自定义类等，统一了语法规则。</li></ul></li><li><p><strong>列表初始化：</strong></p><ul><li>编译器将 <code>&#123;&#125;</code> 转换为 <code>initializer_list</code>，提供了简洁的批量初始化方式。</li></ul></li><li><p><strong>安全性和可读性：</strong></p><ul><li>避免了传统初始化方式的二义性，并禁止了不安全的隐式转换。</li></ul></li></ol><p><strong>示例代码：</strong></p><p>以下是一个完整示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(initializer_list&lt;<span class="type">int</span>&gt; list) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : list) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组初始化</span></span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// STL容器初始化</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义类初始化</span></span><br><span class="line">    A a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br></pre></td></tr></table></figure><img src="/2025/01/25/CPP-2-5/image-20241229151112965.png" class="" title="image-20241229151112965"><h2 id="nullptr">nullptr</h2><img src="/2025/01/25/CPP-2-5/image-20241229151134906.png" class="" title="image-20241229151134906"><p><strong>1. 什么是<code>nullptr</code>？</strong></p><ul><li><code>nullptr</code> 是 C++11 引入的关键字，用来表示空指针（null pointer）。</li><li>它是一种类型安全的指针字面值，取代了传统的 <code>NULL</code>。</li><li><strong>类型：</strong> <code>std::nullptr_t</code>，是一个独特的类型，与任何指针类型兼容，但与整数类型不同。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用不同的函数</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">0</span>);        <span class="comment">// 调用 f(int)</span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">nullptr</span>);  <span class="comment">// 调用 f(char*)</span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">NULL</span>);     <span class="comment">// 有歧义</span></span><br></pre></td></tr></table></figure><p><strong>第一行：<code>f(0);</code></strong></p><ul><li><code>0</code> 被解释为整数。</li><li>调用 <code>f(int)</code>。</li></ul><p><strong>第二行：<code>f(nullptr);</code></strong></p><ul><li><code>nullptr</code> 是一个空指针字面量，与 <code>char*</code> 类型匹配。</li><li>调用 <code>f(char*)</code>。</li></ul><p><strong>第三行：<code>f(NULL);</code></strong></p><ul><li><p><code>NULL</code> 被定义为整数 <code>0</code>。</p></li><li><p>有歧义</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++高级程序设计笔记（C2-2）</title>
      <link href="/2025/01/25/CPP-2-2/"/>
      <url>/2025/01/25/CPP-2-2/</url>
      
        <content type="html"><![CDATA[<h1>CPP-2-2</h1><h2 id="继承">继承</h2><img src="/2025/01/25/CPP-2-2/image-20241220082818418.png" class="" title="image-20241220082818418"><p><strong>1. 继承机制简介</strong></p><p>PPT 中提到：</p><blockquote><p><strong>继承机制是基于目标代码的复用</strong></p></blockquote><p><strong>什么是继承？</strong></p><p>继承（Inheritance）是面向对象编程（OOP）的三大特性之一，它允许一个类（子类或派生类）从另一个类（基类或父类）中继承属性和方法。</p><ul><li><strong>基类（Base Class）</strong>：提供基础功能和接口。</li><li><strong>派生类（Derived Class）</strong>：继承基类的<strong>属性和方法</strong>，并可以扩展或修改这些功能。</li></ul><p><strong>继承的目的</strong></p><ol><li>代码复用：<ul><li>基类中的代码可以被子类直接使用，避免重复编写。</li><li>提高了代码的可维护性和扩展性。</li></ul></li><li>层次化表示事物：<ul><li>通过继承，可以对事物进行分类。</li><li>从基类到派生类逐层增加具体化的细节。</li></ul></li><li>支持多态（Polymorphism）：<ul><li>派生类对象可以被视为基类对象，从而实现动态绑定（Dynamic Binding）。</li></ul></li></ol><p><strong>2. PPT 中的继承分类</strong></p><p><strong>派生类是基类的具体化</strong></p><ul><li><p>基类通常表示一个抽象的事物或概念，而派生类是基类的具体化。</p></li><li><p>示例：</p><ul><li><p>基类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shape</span><br></pre></td></tr></table></figure><p>（形状）</p><ul><li>属性：颜色、边数等。</li><li>方法：计算面积、计算周长。</li></ul></li><li><p>派生类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Circle</span><br></pre></td></tr></table></figure><p>（圆形）、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rectangle</span><br></pre></td></tr></table></figure><p>（矩形）</p><ul><li><code>Circle</code> 添加了属性：半径。</li><li><code>Rectangle</code> 添加了属性：长和宽。</li></ul></li></ul></li></ul><p><strong>把事物以层次结构表示出来</strong></p><ul><li>继承允许我们用层次结构表达事物，形成“类族”。</li><li>好处：<ul><li>更符合人类的逻辑思维方式。</li><li>可以更好地描述复杂问题，逐层分解问题。</li></ul></li></ul><p><strong>示例代码：事物分类</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类：Shape（形状）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string color; <span class="comment">// 颜色</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>(<span class="type">const</span> string&amp; c) : <span class="built_in">color</span>(c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">// 虚函数，支持多态</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Shape of color: &quot;</span> &lt;&lt; color &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类：Circle（圆形）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> radius; <span class="comment">// 半径</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">const</span> string&amp; c, <span class="type">double</span> r) : <span class="built_in">Shape</span>(c), <span class="built_in">radius</span>(r) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// 重写基类方法</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Circle of color: &quot;</span> &lt;&lt; color &lt;&lt; <span class="string">&quot;, radius: &quot;</span> &lt;&lt; radius &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类：Rectangle（矩形）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> length, width; <span class="comment">// 长和宽</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">const</span> string&amp; c, <span class="type">double</span> l, <span class="type">double</span> w) : <span class="built_in">Shape</span>(c), <span class="built_in">length</span>(l), <span class="built_in">width</span>(w) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Rectangle of color: &quot;</span> &lt;&lt; color &lt;&lt; <span class="string">&quot;, length: &quot;</span> &lt;&lt; length</span><br><span class="line">             &lt;&lt; <span class="string">&quot;, width: &quot;</span> &lt;&lt; width &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape* shape1 = <span class="keyword">new</span> <span class="built_in">Circle</span>(<span class="string">&quot;Red&quot;</span>, <span class="number">5.0</span>);</span><br><span class="line">    Shape* shape2 = <span class="keyword">new</span> <span class="built_in">Rectangle</span>(<span class="string">&quot;Blue&quot;</span>, <span class="number">10.0</span>, <span class="number">5.0</span>);</span><br><span class="line"></span><br><span class="line">    shape1-&gt;<span class="built_in">display</span>(); <span class="comment">// 输出：Circle of color: Red, radius: 5</span></span><br><span class="line">    shape2-&gt;<span class="built_in">display</span>(); <span class="comment">// 输出：Rectangle of color: Blue, length: 10, width: 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    <span class="keyword">delete</span> shape2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 增量开发</strong></p><p>PPT 提到：</p><blockquote><p><strong>增量开发</strong></p></blockquote><p><strong>增量开发的含义</strong></p><ul><li>增量开发指的是在已有基类的基础上，通过派生类逐步扩展功能。</li><li>派生类可以：<ol><li>增加新成员：<ul><li>添加新的属性和方法，使子类更加具体化。</li></ul></li><li>重写（Override）基类方法：<ul><li>子类可以提供自己的实现，覆盖基类的方法。</li></ul></li></ol></li></ul><img src="/2025/01/25/CPP-2-2/image-20241220083351797.png" class="" title="image-20241220083351797"><p><strong>1. 单继承的定义</strong></p><p>单继承是 C++ 中的一种继承机制，指的是<strong>一个派生类只能继承自一个基类</strong>。通过单继承，派生类可以继承基类的属性和方法，从而实现代码的复用和功能的扩展。</p><p><strong>2. PPT 中的继承语法</strong></p><p><strong>正确声明派生类</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Undergraduate_Student</span> : <span class="keyword">public</span> Student;</span><br></pre></td></tr></table></figure><p><strong>语法格式解析</strong></p><ul><li><code>class 派生类名 : 继承方式 基类名</code></li><li>继承方式：<ul><li><code>public</code>：基类的 <code>public</code> 成员和 <code>protected</code> 成员在派生类中分别保持为 <code>public</code> 和 <code>protected</code>。</li><li><code>protected</code>：基类的 <code>public</code> 成员和 <code>protected</code> 成员在派生类中变为 <code>protected</code>。</li><li><code>private</code>：基类的 <code>public</code> 成员和 <code>protected</code> 成员在派生类中变为 <code>private</code>。</li></ul></li></ul><p><strong>3. PPT 中的代码解析</strong></p><p><strong>基类 <code>Student</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> id; <span class="comment">// protected 成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> nickname[<span class="number">16</span>]; <span class="comment">// public 成员</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_ID</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; id = x; &#125; <span class="comment">// public 成员</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetNickName</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123; <span class="built_in">strcpy</span>(nickname, s); &#125; <span class="comment">// public 成员</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123; <span class="comment">// 虚函数，支持多态</span></span><br><span class="line">        cout &lt;&lt; nickname &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><code>protected</code> 访问修饰符：</p><ul><li><pre><code>id<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">成员变量是 </span><br><span class="line"></span><br></pre></td></tr></table></figure>protected<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     的，因此：</span><br><span class="line"></span><br><span class="line">    - 基类可以直接访问。</span><br><span class="line">    - 派生类也可以直接访问。</span><br><span class="line">    - 类外部不能直接访问。</span><br><span class="line"></span><br><span class="line">- `public` 访问修饰符：</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    nickname</span><br></pre></td></tr></table></figure>、<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_ID</span><br></pre></td></tr></table></figure> 和 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetNickName</span><br></pre></td></tr></table></figure> 是 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public</span><br></pre></td></tr></table></figure> 的，因此：- 基类、派生类和类外部都可以直接访问。</code></pre></li></ul></li><li><p>虚函数 <code>showInfo()</code>：</p><ul><li>使用 <code>virtual</code> 关键字修饰的函数。</li><li>支持在派生类中进行重写，实现<strong>运行时多态</strong>。</li></ul></li></ul><p><strong>派生类 <code>Undergraduate_Student</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Undergraduate_Student</span> : <span class="keyword">public</span> Student &#123;</span><br><span class="line">    <span class="type">int</span> dept_no; <span class="comment">// 专业编号</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDeptNo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; dept_no = x; &#125; <span class="comment">// 设置专业编号</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_ID</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; ... &#125; <span class="comment">// 重写 set_ID 方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123; <span class="comment">// 重写 showInfo 方法</span></span><br><span class="line">        cout &lt;&lt; dept_no &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; nickname &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Student::nickname; <span class="comment">// 将基类的 nickname 设置为 private</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetNickName</span><span class="params">()</span></span>; <span class="comment">// 禁用基类方法 SetNickName</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>重写方法 <code>set_ID</code> 和 <code>showInfo</code></strong>：<ul><li><code>set_ID</code> 和 <code>showInfo</code> 在派生类中重写了基类的方法。</li><li>注意：<strong>只有虚函数（<code>virtual</code> 修饰）才能在运行时实现多态</strong>，<strong>普通函数重写只会隐藏基类的实现</strong>。</li></ul></li><li><strong>访问修饰符 <code>private</code></strong>：<ul><li>将基类的 <code>nickname</code> 成员变量设置为 <code>private</code>，派生类和外部无法再访问。</li><li>将基类的 <code>SetNickName</code> 方法设置为 <code>private</code>，无法直接调用。</li></ul></li></ul><p><strong>4. 单继承的继承方式</strong></p><p><strong>继承方式对成员的访问控制影响</strong></p><table><thead><tr><th>基类成员类型</th><th><code>public</code>继承</th><th><code>protected</code>继承</th><th><code>private</code>继承</th></tr></thead><tbody><tr><td><code>public</code> 成员</td><td><code>public</code> 成员</td><td><code>protected</code> 成员</td><td><code>private</code> 成员</td></tr><tr><td><code>protected</code> 成员</td><td><code>protected</code> 成员</td><td><code>protected</code> 成员</td><td><code>private</code> 成员</td></tr><tr><td><code>private</code> 成员</td><td>不可访问（派生类不可继承）</td><td>不可访问（派生类不可继承）</td><td>不可访问（派生类不可继承）</td></tr></tbody></table><p><strong>PPT 中的继承方式 <code>public</code></strong></p><ul><li>基类的 <code>public</code> 成员（如 <code>nickname</code>）在派生类中仍为 <code>public</code>。</li><li>基类的 <code>protected</code> 成员（如 <code>id</code>）在派生类中仍为 <code>protected</code>。</li><li>基类的 <code>private</code> 成员不能被派生类直接访问。</li></ul><p><strong>5. PPT 中的访问控制说明</strong></p><p><strong>对基类成员的控制</strong></p><ul><li><p>在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Undergraduate_Student</span><br></pre></td></tr></table></figure><p>类中：</p><ul><li>基类的 <code>nickname</code> 被设置为 <code>private</code>，因此无法在类外访问。</li><li>基类的方法 <code>SetNickName</code> 被设置为 <code>private</code>，因此无法被调用。</li></ul></li></ul><p><strong>保护派生类的封装性</strong></p><ul><li>在继承中，派生类可以通过 <code>private</code> 访问控制对基类成员进行进一步的封装，避免外部直接访问。</li></ul><p><strong>6. 总结</strong></p><ol><li><strong>单继承的特性</strong>：<ul><li>派生类可以继承基类的 <code>public</code> 和 <code>protected</code> 成员。</li><li>继承方式（<code>public</code>、<code>protected</code>、<code>private</code>）会影响成员在派生类中的访问级别。</li><li><strong>基类的 <code>private</code> 成员不能被直接继承或访问。</strong></li></ul></li><li><strong>重写和访问控制</strong>：<ul><li>派生类可以重写基类的方法（尤其是虚函数），实现多态。</li><li>派生类可以通过 <code>private</code> 修饰符对基类的成员进行重新封装，限制外部访问。</li></ul></li><li><strong>虚函数的作用</strong>：<ul><li>基类使用虚函数（<code>virtual</code>）定义接口，派生类实现具体逻辑。</li><li>在运行时通过动态绑定调用派生类的方法。</li></ul></li></ol><h2 id="友元和protected">友元和protected</h2><img src="/2025/01/25/CPP-2-2/image-20241220083811463.png" class="" title="image-20241220083811463"><p><strong>1. <code>protected</code> 访问权限概述</strong></p><p>在 C++ 中，<code>protected</code> 是一种访问控制修饰符，其特性如下：</p><ul><li><strong>基类内部</strong>：<code>protected</code> 成员可以在基类内部访问。</li><li><strong>派生类</strong>：<code>protected</code> 成员可以在派生类中直接访问。</li><li><strong>类外部</strong>：<code>protected</code> 成员不能被类外部直接访问。</li></ul><p><strong>2. PPT 中的代码解析</strong></p><p><strong>基类 <code>Base</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> prot_mem; <span class="comment">// protected 成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>prot_mem</code> 是一个 <code>protected</code> 成员变量。</li><li>仅基类 <code>Base</code> 和派生类可以直接访问 <code>prot_mem</code>。</li></ul><p><strong>派生类 <code>Sneaky</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sneaky</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span></span>; <span class="comment">// 声明 clobber(Sneaky&amp;) 为友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span></span>;   <span class="comment">// 声明 clobber(Base&amp;) 为友元函数</span></span><br><span class="line">    <span class="type">int</span> j; <span class="comment">// 默认是 private 成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>友元函数 <code>clobber(Sneaky &amp;s)</code>：<ul><li>可以访问 <code>Sneaky</code> 对象的所有 <code>private</code> 和 <code>protected</code> 成员。</li><li>也可以访问从 <code>Base</code> 继承的 <code>protected</code> 成员。</li></ul></li><li>友元函数 <code>clobber(Base &amp;b)</code>：<ul><li>仅能访问 <code>Base</code> 中直接声明为 <code>protected</code> 的成员（如果有访问权限）。</li><li><strong>在此示例中，<code>Base::prot_mem</code> 不能通过 <code>clobber(Base &amp;b)</code> 访问。</strong></li></ul></li></ul><p><strong>友元函数实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span> </span>&#123;</span><br><span class="line">    s.j = <span class="number">0</span>;           <span class="comment">// 正确：能访问 Sneaky 的 private 成员</span></span><br><span class="line">    s.prot_mem = <span class="number">0</span>;    <span class="comment">// 正确：能访问 Sneaky 继承自 Base 的 protected 成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>原因：</p><ul><li><pre><code>clobber(Sneaky &amp;s)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">是 </span><br><span class="line"></span><br></pre></td></tr></table></figure>Sneaky<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     的友元函数，因此可以访问：</span><br><span class="line"></span><br><span class="line">    1. `Sneaky` 的私有成员 `j`。</span><br><span class="line">    2. `Sneaky` 从 `Base` 继承的 `protected` 成员 `prot_mem`。</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">void clobber(Base &amp;b) &#123;</span><br><span class="line">    b.prot_mem = 0; // 错误：clobber(Base&amp;) 不是 Base 的友元函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>原因：</p><ul><li><strong><code>clobber(Base &amp;b)</code> 是 <code>Sneaky</code> 的友元函数，但不是 <code>Base</code> 的友元函数。</strong></li><li>因此，<code>clobber(Base &amp;b)</code> 无法访问 <code>Base</code> 中的 <code>protected</code> 成员 <code>prot_mem</code>。</li></ul></li></ul><p><strong>3. 友元与访问权限</strong></p><p><strong>友元函数的特性</strong></p><ul><li>友元函数被某个类声明为友元后，可以访问该类的所有成员，包括 <code>private</code> 和 <code>protected</code>。</li><li>友元关系是单向的且非传递的：<ul><li>如果 <code>A</code> 是 <code>B</code> 的友元，<code>B</code> 并不会自动成为 <code>A</code> 的友元。</li></ul></li></ul><p><strong>友元对继承成员的访问规则</strong></p><ul><li>友元函数可以访问声明它的类的所有成员。</li><li>如果一个派生类声明了某个函数为友元函数，该友元函数可以：<ul><li>访问派生类的私有成员。</li><li>访问派生类从基类继承的 <code>protected</code> 成员。</li></ul></li><li>友元函数<strong>不能访问基类中直接声明的 <code>protected</code> 成员</strong>，除非该基类也将其声明为友元。</li></ul><p><strong>4. 总结</strong></p><ol><li><strong><code>protected</code> 的访问规则</strong>：<ul><li><code>protected</code> 成员可以被基类和派生类直接访问，但不能被类外部访问。</li><li>派生类中的 <code>protected</code> 成员仍然可以被派生类的友元函数访问。</li></ul></li><li><strong>友元函数的权限</strong>：<ul><li>可以访问友元类的所有成员（包括 <code>private</code> 和 <code>protected</code>）。</li><li>不能访问友元类以外的成员（即使是 <code>protected</code> 成员）。</li></ul></li><li><strong>错误示例分析</strong>：<ul><li><code>clobber(Base &amp;b)</code> 试图访问 <code>Base</code> 的 <code>protected</code> 成员，但<strong>它不是 <code>Base</code> 的友元函数</strong>，因此不允许。</li></ul></li></ol><img src="/2025/01/25/CPP-2-2/image-20241220084441680.png" class="" title="image-20241220084441680"><p><strong>1. 派生类对象的初始化</strong></p><p><strong>描述</strong></p><ul><li>当创建派生类对象时，<strong>对象的初始化过程</strong>由 <strong>基类</strong> 和 <strong>派生类</strong> 共同完成。</li><li><strong>基类的构造函数</strong>会首先执行，然后是<strong>派生类的构造函数</strong>。</li></ul><p><strong>原因</strong></p><ul><li>基类的成员是派生类对象的一部分，因此在派生类的构造函数运行之前，必须先初始化基类部分。</li></ul><p><strong>2. 构造函数的执行顺序</strong></p><p><strong>顺序</strong></p><ul><li><strong>基类的构造函数</strong>：先执行基类的构造函数，用于初始化基类的成员。</li><li><strong>派生类对象成员类的构造函数</strong>：如果派生类中包含对象成员（即类类型成员），会依次调用这些成员的构造函数。</li><li><strong>派生类的构造函数</strong>：最后执行派生类的构造函数，用于初始化派生类的特有成员。</li></ul><p><strong>例子</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base Destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Member</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Member</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Member Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Member</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Member Destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    Member m; <span class="comment">// 派生类的成员是一个对象</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived Destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Base Constructor</span><br><span class="line">Member Constructor</span><br><span class="line">Derived Constructor</span><br><span class="line">Derived Destructor</span><br><span class="line">Member Destructor</span><br><span class="line">Base Destructor</span><br></pre></td></tr></table></figure><p><strong>3. 析构函数的执行顺序</strong></p><p><strong>顺序</strong></p><p>析构函数的执行顺序与构造函数相反：</p><ol><li><strong>派生类的析构函数</strong>：先释放派生类的资源。</li><li><strong>派生类对象成员类的析构函数</strong>：接着释放派生类中对象成员的资源。</li><li><strong>基类的析构函数</strong>：最后调用基类的析构函数，释放基类的资源。</li></ol><p><strong>原因</strong></p><ul><li>释放资源的顺序必须与构造顺序相反，以<strong>确保派生类中使用的基类资源先被正确释放</strong>。</li></ul><p><strong>4. 总结</strong></p><p><strong>构造函数顺序</strong></p><ul><li><strong>基类 -&gt; 派生类对象成员 -&gt; 派生类</strong>。</li></ul><p><strong>析构函数顺序</strong></p><ul><li><strong>派生类 -&gt; 派生类对象成员 -&gt; 基类</strong>。</li></ul><img src="/2025/01/25/CPP-2-2/image-20241220084951693.png" class="" title="image-20241220084951693"><p><strong>1. 基类构造函数的调用</strong></p><p>PPT 中的重点是解释在派生类中如何调用基类的构造函数：</p><ul><li><strong>缺省情况下</strong>，派生类的构造函数会自动调用基类的<strong>默认构造函数</strong>（即无参构造函数）。</li><li>如果基类中没有默认构造函数（或者需要调用非默认构造函数），派生类构造函数需要在<strong>成员初始化列表</strong>中明确指定要调用的基类构造函数。</li></ul><p><strong>2. 示例代码解析</strong></p><p><strong>基类 <code>A</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; x = <span class="number">0</span>; &#125;          <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i) &#123; x = i; &#125;     <span class="comment">// 带参构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong><code>A()</code></strong> 是无参构造函数，默认将 <code>x</code> 初始化为 <code>0</code>。</li><li><strong><code>A(int i)</code></strong> 是带参构造函数，将 <code>x</code> 初始化为传入的参数 <code>i</code>。</li></ul><p><strong>派生类 <code>B</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123; y = <span class="number">0</span>; &#125;                     <span class="comment">// 调用基类的默认构造函数 A()</span></span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> i) &#123; y = i; &#125;                <span class="comment">// 调用基类的默认构造函数 A()</span></span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> i, <span class="type">int</span> j) : <span class="built_in">A</span>(i) &#123; y = j; &#125;  <span class="comment">// 调用基类的 A(int) 构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>B()</code>：派生类的默认构造函数。<ul><li>隐式调用基类 <code>A</code> 的默认构造函数 <code>A()</code>。</li><li>将 <code>y</code> 初始化为 <code>0</code>。</li></ul></li><li><code>B(int i)</code>：派生类的带参构造函数。<ul><li>同样隐式调用基类 <code>A</code> 的默认构造函数 <code>A()</code>。</li><li>将 <code>y</code> 初始化为 <code>i</code>。</li></ul></li><li><code>B(int i, int j)</code>：派生类的带参构造函数。<ul><li>在<strong>成员初始化列表</strong>中显式调用基类的构造函数 <code>A(i)</code>。</li><li>将 <code>y</code> 初始化为 <code>j</code>。</li></ul></li></ul><p><strong>3. PPT 中的调用顺序说明</strong></p><p><strong>对象 <code>B b1;</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B b1;  <span class="comment">// 执行 A::A() 和 B::B()</span></span><br></pre></td></tr></table></figure><ul><li><code>b1</code> 调用派生类的默认构造函数 <code>B()</code>。</li><li><code>B()</code> 会隐式调用基类的默认构造函数 <code>A()</code>。</li></ul><p><strong>对象 <code>B b2(1);</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">B <span class="title">b2</span><span class="params">(<span class="number">1</span>)</span></span>;  <span class="comment">// 执行 A::A() 和 B::B(int)</span></span><br></pre></td></tr></table></figure><ul><li><code>b2</code> 调用派生类的带参构造函数 <code>B(int)</code>。</li><li><code>B(int)</code> 同样隐式调用基类的默认构造函数 <code>A()</code>。</li></ul><p><strong>对象 <code>B b3(0, 1);</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">B <span class="title">b3</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>)</span></span>;  <span class="comment">// 执行 A::A(int) 和 B::B(int, int)</span></span><br></pre></td></tr></table></figure><ul><li><code>b3</code> 调用派生类的带参构造函数 <code>B(int, int)</code>。</li><li><code>B(int, int)</code> 在初始化列表中显式调用了基类的带参构造函数 <code>A(int)</code>。</li></ul><p><strong>4. 注意事项</strong></p><p><strong>基类的默认构造函数</strong></p><ul><li>如果基类中没有默认构造函数，派生类的构造函数必须在初始化列表中显式调用基类的其他构造函数，否则会编译报错。</li><li>示例：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i) &#123; x = i; &#125;  <span class="comment">// 没有提供默认构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> i) : <span class="built_in">A</span>(i) &#123;&#125;   <span class="comment">// 必须显式调用 A(int) 构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>初始化列表中的顺序</strong></p><ul><li>初始化列表的执行顺序是按照成员的声明顺序，而不是初始化列表中出现的顺序。</li><li>例如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">y</span>(<span class="number">2</span>), <span class="built_in">x</span>(<span class="number">1</span>) &#123;&#125;  <span class="comment">// x 仍然会在 y 之前初始化</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>1. <code>using A::A</code> 是什么？</strong></p><p><code>using A::A</code> 是 C++11 引入的一种新特性，用于<strong>继承基类的构造函数</strong>。这意味着，当派生类声明 <code>using A::A</code> 后，基类的构造函数会被引入到派生类中，可以直接用于派生类对象的构造。</p><p>换句话说：</p><ul><li>之前的写法（C++11 之前）：<ul><li>派生类必须手动定义构造函数，即使其逻辑和基类的构造函数完全相同。</li></ul></li><li>C++11 后的改进：<ul><li>通过 <code>using A::A</code>，可以直接“继承”基类的构造函数，不需要重复书写。</li></ul></li></ul><p><strong>2. 为什么需要继承基类的构造函数？</strong></p><p>如果派生类没有特殊的初始化逻辑，而仅仅是想沿用基类的构造函数逻辑，继承构造函数可以减少代码重复，简化开发。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x) &#123; <span class="comment">/*...*/</span> &#125;        <span class="comment">// 带参构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">double</span> y) &#123; <span class="comment">/*...*/</span> &#125;     <span class="comment">// 带参构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="comment">// 如果不使用 using A::A，必须重复定义构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> x) : <span class="built_in">A</span>(x) &#123;&#125;          <span class="comment">// 必须手动调用基类构造函数</span></span><br><span class="line">    <span class="built_in">B</span>(<span class="type">double</span> y) : <span class="built_in">A</span>(y) &#123;&#125;       <span class="comment">// 重复定义同样的逻辑</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 <code>using</code> 后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="keyword">using</span> A::A;   <span class="comment">// 直接继承 A 的所有构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><ul><li>基类的构造函数 <code>A(int)</code> 和 <code>A(double)</code> 现在都可以直接用来创建派生类的对象 <code>B</code>。</li><li>不需要在派生类中重复定义与基类一致的构造函数。</li></ul><p><strong>3. 继承构造函数的工作原理</strong></p><p>继承构造函数会将基类的构造函数<strong>自动添加到派生类的构造函数集</strong>中，但有以下限制和特点：</p><ol><li><strong>构造函数本质上是“复制”到派生类中：</strong><ul><li>派生类对象初始化时，基类的构造函数会像“被直接复制到派生类”一样被调用。</li></ul></li><li><strong>可以重写继承的构造函数：</strong><ul><li>如果派生类需要对基类的某些构造函数添加新的逻辑，可以在派生类中重新定义这些构造函数，覆盖继承的构造函数。</li></ul></li><li><strong>不会继承默认构造函数：</strong><ul><li>如果基类没有默认构造函数，派生类仍需要显式定义其自己的默认构造函数。</li></ul></li></ol><p>-<strong>4. 示例代码</strong></p><p><strong>示例 1：继承基类的构造函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A(int x) called with x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">double</span> y) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A(double y) called with y = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="keyword">using</span> A::A;  <span class="comment">// 继承基类的构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">B <span class="title">b1</span><span class="params">(<span class="number">10</span>)</span></span>;      <span class="comment">// 调用 A(int x)</span></span><br><span class="line">    <span class="function">B <span class="title">b2</span><span class="params">(<span class="number">3.14</span>)</span></span>;    <span class="comment">// 调用 A(double y)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A(int x) called with x = 10</span><br><span class="line">A(double y) called with y = 3.14</span><br></pre></td></tr></table></figure><ul><li><code>B b1(10)</code>：通过继承的构造函数 <code>A(int x)</code> 初始化对象。</li><li><code>B b2(3.14)</code>：通过继承的构造函数 <code>A(double y)</code> 初始化对象。</li></ul><p><strong>示例 2：基类没有默认构造函数</strong></p><p>如果基类没有默认构造函数，派生类必须显式调用基类的某个构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x) : <span class="built_in">value</span>(x) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A(int x) called with x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="keyword">using</span> A::A;  <span class="comment">// 继承构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">B <span class="title">b1</span><span class="params">(<span class="number">5</span>)</span></span>;  <span class="comment">// 正常，因为 A(int x) 被继承</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果尝试默认构造 <code>B</code>，会编译失败，因为 <code>A</code> 没有默认构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B b2;  <span class="comment">// 错误：A 没有默认构造函数</span></span><br></pre></td></tr></table></figure><p><strong>4. 注意事项和限制</strong></p><ol><li><strong><code>using A::A</code> 并不继承所有构造函数</strong><ul><li>析构函数、拷贝构造函数、移动构造函数不会被继承。</li></ul></li><li><strong>可以继承的构造函数有限制</strong><ul><li>基类中的构造函数如果被标记为 <code>=delete</code>，则派生类不能继承这些构造函数。</li><li>派生类不能继承 <code>explicit</code> 标记的基类构造函数。</li></ul></li><li><strong>避免菱形继承时的歧义</strong><ul><li>在多重继承中使用 <code>using</code> 时，可能会导致歧义，需要小心处理。</li></ul></li></ol><h2 id="虚函数">虚函数</h2><img src="/2025/01/25/CPP-2-2/image-20241220090110648.png" class="" title="image-20241220090110648"><p><strong>1. 类型相容性概念</strong></p><ul><li><strong>类、类型：</strong><ul><li>C++ 中的对象可以分为基类（Base Class）和派生类（Derived Class），派生类继承了基类的特性。</li><li>类型相容性主要指：<strong>一个派生类对象能否赋值或转换为基类类型，以及如何在运行时或编译时进行转换</strong>。</li></ul></li><li><strong>类型相容性分为两种：</strong><ul><li>赋值相容性：<ul><li>基类的指针（或引用）可以指向派生类的对象。</li><li>但派生类的指针（或引用）不能直接指向基类的对象，必须进行显式类型转换。</li></ul></li><li>赋值相容时的行为：<ul><li>当基类指针指向派生类对象时，通过基类指针只能访问基类的成员，而<strong>派生类的独有成员将“不可见”</strong>。</li><li>如果<strong>基类中的成员是虚函数，派生类的重写版本会在运行时被调用</strong>（多态的基础）。</li></ul></li></ul></li></ul><hr><p><strong>2. 问题分析：<code>a = b</code> 是否合法</strong></p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a; </span><br><span class="line">B b;  <span class="comment">// 假设 class B : public A;</span></span><br><span class="line">a = b;  <span class="comment">// 合法吗？</span></span><br></pre></td></tr></table></figure><ul><li><strong>语法解释：</strong><ul><li>这里的 <code>a</code> 是基类对象，<code>b</code> 是派生类对象，<code>class B : public A</code> 表示 <code>B</code> 继承自 <code>A</code>。</li><li>当 <code>b</code> 赋值给 <code>a</code> 时，会触发 <strong>“对象切割”（Object Slicing）</strong>。</li></ul></li><li><strong>对象切割：</strong><ul><li>由于 <code>a</code> 是基类对象，赋值操作会“切割”掉 <code>b</code> 中派生类部分的内容，仅保留基类 <code>A</code> 的成员。</li><li><strong>结论：合法，但会导致派生类部分的成员丢失。</strong></li></ul></li></ul><p>PPT 的描述：</p><ul><li>对象的身份发生变化：<ul><li>当 <code>a = b</code> 时，<code>b</code> 的派生类身份被“切割”，只保留基类 <code>A</code> 的部分。</li><li><strong>派生类的属性和方法</strong>（不包括虚函数）在赋值给基类对象时，已经不存在。</li></ul></li></ul><p><strong>3. 第二部分：指针和引用的赋值</strong></p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B* pb;</span><br><span class="line">A* pa = pb;  <span class="comment">// 合法，指针类型向上转型</span></span><br></pre></td></tr></table></figure><ul><li>指针赋值：<ul><li>当 <code>pb</code>（派生类指针）赋值给 <code>pa</code>（基类指针）时，这是合法的，称为<strong>向上转型（Upcasting）</strong>。</li><li>向上转型：<ul><li>基类指针可以指向派生类对象，但<strong>只能通过基类指针访问基类的成员</strong>。</li><li>如果基类有虚函数，则<strong>通过基类指针调用虚函数，会动态绑定到派生类的实现</strong>。</li></ul></li></ul></li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B b;</span><br><span class="line">A&amp; a = b;  <span class="comment">// 合法，引用类型向上转型</span></span><br></pre></td></tr></table></figure><ul><li>引用赋值：<ul><li>和指针类似，派生类对象 <code>b</code> 可以绑定到基类引用 <code>a</code>。</li><li>这意味着 <code>a</code> 通过引用绑定到派生类对象时，仍然<strong>只能访问基类成员（非虚函数时）</strong>。</li></ul></li></ul><p><strong>4. 虚函数的行为</strong></p><ul><li><p><strong>虚函数多态：</strong></p><ul><li>虚函数是 C++ 实现多态的关键。<strong>通过基类指针或引用调用虚函数时，最终调用的是派生类的实现</strong>。</li></ul></li><li><p><strong>例子解释：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::show()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::show()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A* pa = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">pa-&gt;<span class="built_in">show</span>();  <span class="comment">// 输出：B::show()</span></span><br></pre></td></tr></table></figure><ul><li><code>pa</code> 是基类指针，指向派生类对象 <code>B</code>。</li><li>因为 <code>show()</code> 是虚函数，调用时会动态绑定到 <code>B</code> 的实现。</li></ul></li><li><p><strong>非虚函数：</strong></p><ul><li>如果 <code>show()</code> 不是虚函数，则调用 <code>pa-&gt;show()</code> 会静态绑定到基类的实现，输出 <code>A::show()</code>。</li></ul></li></ul><p><strong>5. PPT 上描述的具体场景</strong></p><p><strong>第一行：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">B b;  <span class="comment">// class B : public A;</span></span><br><span class="line">a = b;</span><br></pre></td></tr></table></figure><ul><li><strong>结论：合法。</strong></li><li>这是赋值相容性。派生类对象 <code>b</code> 赋值给基类对象 <code>a</code> 时，派生类的部分被切割。</li></ul><p><strong>第二行：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B* pb;</span><br><span class="line">A* pa = pb;</span><br></pre></td></tr></table></figure><ul><li><strong>结论：合法。</strong></li><li>这是指针类型的向上转型。基类指针可以指向派生类对象。</li></ul><p><strong>第三行：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B b;</span><br><span class="line">A&amp; a = b;</span><br></pre></td></tr></table></figure><ul><li><strong>结论：合法。</strong></li><li>这是引用类型的向上转型。基类引用可以绑定到派生类对象。</li></ul><p><strong>6. 总结：派生类到基类的类型相容性</strong></p><ol><li><strong>对象赋值：</strong><ul><li>派生类对象赋值给基类对象时，合法，但会触发“对象切割”，丢失派生类的成员。</li></ul></li><li><strong>指针赋值（向上转型）：</strong><ul><li>基类指针可以指向派生类对象，合法，但通过基类指针只能访问基类的成员。</li></ul></li><li><strong>引用赋值（向上转型）：</strong><ul><li>基类引用可以绑定到派生类对象，合法，但只能通过基类引用访问基类的成员。</li></ul></li><li><strong>虚函数：</strong><ul><li>如果<strong>基类成员是虚函数，通过基类指针或引用调用时，运行时会动态绑定到派生类的实现</strong>（多态）。</li></ul></li></ol><img src="/2025/01/25/CPP-2-2/image-20241220092036720.png" class="" title="image-20241220092036720"><p><strong>1. 类定义与继承关系</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;  <span class="comment">// 基类成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;  <span class="comment">// 派生类成员函数，隐藏 A::f()</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;  <span class="comment">// 派生类独有成员函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>B</code> 继承自 <code>A</code>。</li><li><code>B::f()</code> 是一个与 <code>A::f()</code> 同名的函数，但<strong>由于不是虚函数，它不会覆盖 <code>A::f()</code>，而是隐藏它</strong>。</li></ul><p><strong>2. 对象赋值规则</strong></p><p><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line"></span><br><span class="line">a = b;  <span class="comment">// OK，派生类对象赋值给基类对象</span></span><br><span class="line">b = a;  <span class="comment">// Error，基类对象不能赋值给派生类对象</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>a = b</code></strong>：<ul><li>基类对象可以接收派生类对象赋值。</li><li><strong>对象切割（Object Slicing）</strong>：派生类对象中的扩展部分（如 <code>z</code> 和 <code>g()</code>）会被丢弃，仅保留基类 <code>A</code> 的部分。</li></ul></li><li><strong><code>b = a</code></strong>：<ul><li>派生类对象不能直接接收基类对象赋值。</li><li>原因是派生类需要扩展的部分无法从基类的部分推导出来。</li></ul></li></ul><p><strong>3. 引用与指针规则</strong></p><p><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A &amp;r_a = b;  <span class="comment">// OK，基类引用绑定派生类对象</span></span><br><span class="line">A *p_a = &amp;b; <span class="comment">// OK，基类指针指向派生类对象</span></span><br><span class="line"></span><br><span class="line">B &amp;r_b = a;  <span class="comment">// Error，派生类引用不能绑定基类对象</span></span><br><span class="line">B *p_b = &amp;a; <span class="comment">// Error，派生类指针不能指向基类对象</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>A &amp;r_a = b;</code> 和 <code>A *p_a = &amp;b;</code></strong><ul><li><strong>向上转型（Upcasting）：</strong> 基类的引用和指针可以绑定派生类对象。这是合法的，因为派生类对象总是包含基类部分。</li><li><strong>使用基类的引用或指针，只能访问基类部分的成员</strong>。</li></ul></li><li><strong><code>B &amp;r_b = a;</code> 和 <code>B *p_b = &amp;a;</code></strong><ul><li><strong>向下转型（Downcasting）：</strong> 派生类的引用和指针不能绑定基类对象。这是非法的，因为基类对象不包含派生类的扩展部分。</li></ul></li></ul><p><strong>4. 成员函数调用</strong></p><p><strong>直接调用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="built_in">f</span>();  <span class="comment">// 调用 A::f()</span></span><br><span class="line">b.<span class="built_in">f</span>();  <span class="comment">// 调用 B::f()</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>a.f()</code></strong> 调用的是 <code>A::f()</code>，因为 <code>a</code> 是基类对象。</li><li><strong><code>b.f()</code></strong> 调用的是 <code>B::f()</code>，因为 <code>b</code> 是派生类对象。</li></ul><p><strong>5. 函数参数传递</strong></p><p><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(A &amp;a)</span> </span>&#123;</span><br><span class="line">    a.<span class="built_in">f</span>();  <span class="comment">// 调用 a 的静态类型（基类）的 f()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(A *pa)</span> </span>&#123;</span><br><span class="line">    pa-&gt;<span class="built_in">f</span>();  <span class="comment">// 调用指针所指向对象的静态类型（基类）的 f()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func1</span>(b);   <span class="comment">// OK，派生类对象可以传递给基类引用</span></span><br><span class="line"><span class="built_in">func2</span>(&amp;b);  <span class="comment">// OK，派生类对象的地址可以传递给基类指针</span></span><br></pre></td></tr></table></figure><ul><li><code>func1(b)</code> 和 <code>func2(&amp;b)</code>：<ul><li><strong>基类的引用或指针可以接收派生类对象。</strong></li><li>如果 <code>A::f()</code> 是虚函数，则会动态绑定调用派生类 <code>B::f()</code>。</li><li>如果 <code>A::f()</code> 是<strong>普通函数，则静态绑定</strong>，调用 <code>A::f()</code>。</li></ul></li></ul><p><strong>6. 变量声明规则</strong></p><ul><li><p><strong>对象赋值：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line"></span><br><span class="line">a = b;  <span class="comment">// OK</span></span><br><span class="line">b = a;  <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><ul><li>基类对象可以接收派生类对象赋值，但会发生对象切割。</li><li>派生类对象不能直接接收基类对象赋值。</li></ul></li><li><p><strong>引用与指针：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A &amp;r_a = b;  <span class="comment">// OK</span></span><br><span class="line">A *p_a = &amp;b; <span class="comment">// OK</span></span><br><span class="line">B &amp;r_b = a;  <span class="comment">// Error</span></span><br><span class="line">B *p_b = &amp;a; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><ul><li>基类的引用或指针可以绑定派生类对象，但反之不成立。</li></ul></li></ul><p><strong>7. 总结</strong></p><ul><li><strong>向上转型</strong>（Upcasting）是允许的，即基类的引用或指针可以绑定派生类对象。</li><li><strong>向下转型</strong>（Downcasting）是非法的，即派生类的引用或指针不能绑定基类对象。</li><li><strong>非虚函数</strong>在调用时是静态绑定的，调用的是对象的静态类型对应的函数。</li><li>函数参数传递时，基类的引用或指针可以接收派生类对象，并根据虚函数机制决定调用哪一版本的成员函数。</li></ul><img src="/2025/01/25/CPP-2-2/image-20241220235838835.png" class="" title="image-20241220235838835"><p><strong>1. 前期绑定（Early Binding）</strong></p><p><strong>定义</strong>：在<strong>编译时刻</strong>确定函数调用的具体实现，绑定到对象的静态类型。</p><ul><li><p><strong>绑定时机</strong>：编译阶段。</p></li><li><p><strong>依据</strong>：静态类型（Static Type）。即对象在定义时的类型，而不是运行时对象的实际类型。</p></li><li><p>特点：</p><ul><li><strong>效率高</strong>：函数调用直接通过对象的静态类型进行，无需动态查表，速度较快。</li><li><strong>灵活性差</strong>：对象的实际类型可能与静态类型不一致，可能导致多态性丧失。</li></ul></li><li><p>典型场景：非虚函数。</p><ul><li><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::func()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::func()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line">A* p = &amp;b;</span><br><span class="line">p-&gt;<span class="built_in">func</span>();  <span class="comment">// 输出 &quot;A::func()&quot;，因为是前期绑定</span></span><br></pre></td></tr></table></figure><ul><li>尽管 <code>p</code> 指向一个 <code>B</code> 对象，但调用的是 <code>A::func()</code>，因为是基于静态类型 <code>A</code> 进行的绑定。</li></ul></li></ul></li></ul><p><strong>2. 后期绑定（Late Binding）</strong></p><p><strong>定义</strong>：在<strong>运行时刻</strong>根据对象的实际类型确定函数调用的具体实现。</p><ul><li><p><strong>绑定时机</strong>：运行阶段。</p></li><li><p><strong>依据</strong>：动态类型（Dynamic Type）。即对象在运行时的实际类型，而不是编译时的静态类型。</p></li><li><p>特点：</p><ul><li><strong>灵活性高</strong>：可以实现<strong>多态</strong>，动态调用不同类型的函数。</li><li><strong>效率低</strong>：需要<strong>通过虚函数表（vtable）查找函数地址</strong>，会有一定的<strong>运行时开销</strong>。</li></ul></li><li><p>典型场景：虚函数（virtual）。</p><ul><li><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::func()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::func()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line">A* p = &amp;b;</span><br><span class="line">p-&gt;<span class="built_in">func</span>();  <span class="comment">// 输出 &quot;B::func()&quot;，因为是后期绑定</span></span><br></pre></td></tr></table></figure><ul><li>虽然 <code>p</code> 是 <code>A*</code> 类型，但实际指向的是一个 <code>B</code> 对象，因此调用 <code>B::func()</code>。</li></ul></li></ul></li></ul><p><strong>3. 注意效率</strong></p><p>PPT指出：</p><ul><li><strong>默认前期绑定</strong>：C++ 默认对非虚函数进行前期绑定，原因是效率更高。</li><li>后期绑定需要显式声明 <code>virtual</code>：<ul><li>只有声明为虚函数的成员函数，才能实现后期绑定。</li><li>虚函数的调用需要依赖虚函数表（vtable）和虚函数指针（vptr），因此效率稍低。</li></ul></li></ul><p><strong>4. 总结</strong></p><table><thead><tr><th><strong>特性</strong></th><th><strong>前期绑定（Early Binding）</strong></th><th><strong>后期绑定（Late Binding）</strong></th></tr></thead><tbody><tr><td><strong>绑定时机</strong></td><td>编译时</td><td>运行时</td></tr><tr><td><strong>依据</strong></td><td>对象的静态类型</td><td>对象的实际类型</td></tr><tr><td><strong>效率</strong></td><td>高</td><td>低</td></tr><tr><td><strong>灵活性</strong></td><td>差</td><td>高</td></tr><tr><td><strong>关键字</strong></td><td>默认行为</td><td>需要显式声明 <code>virtual</code></td></tr><tr><td><strong>场景</strong></td><td>非虚函数调用</td><td>虚函数调用</td></tr></tbody></table><img src="/2025/01/25/CPP-2-2/image-20241221000205755.png" class="" title="image-20241221000205755"><p><strong>1. 定义：虚函数</strong></p><p>在C++中，<strong>虚函数</strong>是使用关键字<code>virtual</code>声明的类成员函数，其作用是实现<strong>动态绑定</strong>（Late Binding），从而支持<strong>多态性</strong>。</p><ul><li><p>虚函数的声明：在基类中使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual</span><br></pre></td></tr></table></figure><p>声明一个函数。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;  <span class="comment">// 声明虚函数f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><strong>2. 方法重定义</strong></p><p>虚函数支持在派生类中进行<strong>方法重定义（Override）</strong>，从而实现多态性。</p><ul><li><p><strong>方法重定义的要求</strong>：</p><ul><li>函数名相同。</li><li>参数列表相同（包括参数数量和类型）。</li><li>返回值类型一致（或者在C++11中支持协变返回类型）。</li><li>需要显式标记<code>virtual</code>关键字（在基类中声明即可，派生类不需要重复标记）。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::show()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::show()&quot;</span> &lt;&lt; endl; &#125;  <span class="comment">// 重写show</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A* a = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">a-&gt;<span class="built_in">show</span>();  <span class="comment">// 输出 &quot;B::show()&quot;</span></span><br></pre></td></tr></table></figure></li></ul><img src="/2025/01/25/CPP-2-2/image-20241221000221739.png" class="" title="image-20241221000221739"><p><strong>1. 虚函数的定义</strong></p><ul><li>如果在基类中某个成员函数被定义为虚函数（用<code>virtual</code>关键字修饰），则<strong>派生类中对该函数的重定义（override）也将是虚函数</strong>。<ul><li>虚函数支持<strong>动态绑定</strong>，即在运行时根据对象的实际类型调用对应的函数实现，而不是编译时的静态类型。</li></ul></li></ul><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::func()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived::func()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base* b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">b-&gt;<span class="built_in">func</span>();  <span class="comment">// 输出 &quot;Derived::func()&quot;</span></span><br></pre></td></tr></table></figure><ul><li>在这个例子中，<code>func</code>在基类中被声明为虚函数，因此在派生类中对它的重写仍然是虚函数，并会在运行时调用派生类的实现。</li></ul><p><strong>2. 虚函数的限制</strong></p><p><strong>（1）只有类的成员函数才能是虚函数</strong></p><ul><li>非成员函数（如全局函数或普通非成员函数）不能是虚函数。</li></ul><p><strong>（2）静态成员函数不能是虚函数</strong></p><ul><li>原因：静态成员函数与具体的对象无关，它们属于整个类，而虚函数依赖于对象的动态类型来实现动态绑定。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;  <span class="comment">// ❌ 不合法，编译报错</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>（3）内联成员函数不能是虚函数</strong></p><ul><li><strong>内联函数</strong>是建议编译器将其替换为函数体代码，从而优化性能。而<strong>虚函数</strong>需要通过虚函数表（vtable）动态查找，无法做到内联化。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;  <span class="comment">// ❌ 内联和虚函数机制冲突</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>（4）构造函数不能是虚函数</strong></p><ul><li>构造函数在创建对象时被调用，而虚函数依赖于对象的动态类型。由于构造函数在对象创建过程中调用，动态类型尚未确定，因此构造函数不能是虚函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">A</span><span class="params">()</span></span>;  <span class="comment">// ❌ 不合法，构造函数不能为虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>（5）析构函数可以是虚函数</strong></p><ul><li>析构函数被设计为虚函数的原因在于，当<strong>通过基类指针删除派生类对象时，确保调用派生类的析构函数以释放派生类资源</strong>。</li></ul><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; cout &lt;&lt; <span class="string">&quot;Base Destructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; cout &lt;&lt; <span class="string">&quot;Derived Destructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base* b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"><span class="keyword">delete</span> b;  <span class="comment">// 确保先调用 Derived 的析构函数，再调用 Base 的析构函数</span></span><br></pre></td></tr></table></figure><img src="/2025/01/25/CPP-2-2/image-20241221000805858.png" class="" title="image-20241221000805858"><p><strong>1. 背景知识：后期绑定（Late Binding）</strong></p><ul><li><strong>后期绑定</strong>的定义：在运行时决定调用哪一个函数，而不是在编译时。</li><li>在C++中，如果类中包含虚函数（<code>virtual</code>修饰），就会创建一个虚函数表（<strong>vtable</strong>）。</li><li>每个对象内部会有一个隐藏的指针（<strong>vptr</strong>），指向它对应的虚函数表。</li></ul><p><strong>2. 虚函数表的实现机制</strong></p><p>虚函数表的工作原理如下：</p><ol><li>虚函数表（vtable）：<ul><li>每个包含虚函数的类都有一张虚函数表。</li><li>表中存储了该类的所有虚函数的地址（函数指针）。</li><li>如果派生类重写了基类的虚函数，虚函数表中对应的地址会被派生类函数覆盖。</li></ul></li><li>虚指针（vptr）：<ul><li>每个对象都有一个隐藏的指针，称为虚指针（<code>vptr</code>）。</li><li><code>vptr</code>指向该对象所属类的虚函数表（<code>vtable</code>）。</li><li>调用虚函数时，通过<code>vptr</code>访问虚函数表，从而实现动态绑定。</li></ul></li></ol><p><strong>3. 代码解析</strong></p><p><strong>类定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;   <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;   <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>;           <span class="comment">// 非虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;           <span class="comment">// 重写 A 的虚函数 f</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>;           <span class="comment">// 隐藏 A 的非虚函数 h</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>对象和指针</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a;    <span class="comment">// 定义 A 类对象</span></span><br><span class="line">B b;    <span class="comment">// 定义 B 类对象</span></span><br><span class="line">A* p;   <span class="comment">// 定义基类指针</span></span><br></pre></td></tr></table></figure><p><strong>4. 虚函数表的工作流程</strong></p><p><strong>虚函数表的结构</strong></p><ol><li><p>对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a</span><br></pre></td></tr></table></figure><p>是类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A</span><br></pre></td></tr></table></figure><p>的实例：</p><ul><li>内部包含一个 <code>vptr</code>，指向类 <code>A</code> 的虚函数表（<code>A_vtable</code>）。</li><li><code>A_vtable</code> 包含两个虚函数的地址：<code>A::f</code> 和 <code>A::g</code>。</li></ul></li><li><p>对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b</span><br></pre></td></tr></table></figure><p>是类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B</span><br></pre></td></tr></table></figure><p>的实例：</p><ul><li>内部同样包含一个 <code>vptr</code>，但指向的是类 <code>B</code> 的虚函数表（<code>B_vtable</code>）。</li><li><code>B_vtable</code> 中，<code>f</code> 指向 <code>B::f</code>（覆盖了 <code>A::f</code>），<strong>而 <code>g</code> 仍然指向 <code>A::g</code></strong>。</li></ul></li></ol><p><strong>函数调用示例</strong></p><ol><li><strong>Case 1: <code>p = &amp;a;</code></strong><ul><li><code>p</code> 指向对象 <code>a</code>，即 <code>A</code> 类型的实例。</li><li><code>p-&gt;f()</code> 会通过 <code>vptr</code> 找到 <code>A_vtable</code> 中的 <code>A::f</code>，调用 <code>A::f()</code>。</li><li><strong>虚函数的绑定发生在运行时，由<code>vptr</code>指向的虚函数表决定。</strong></li></ul></li><li><strong>Case 2: <code>p = &amp;b;</code></strong><ul><li><code>p</code> 指向对象 <code>b</code>，即 <code>B</code> 类型的实例。</li><li>虽然 <code>p</code> 是 <code>A*</code> 类型，但由于对象实际类型是 <code>B</code>，<code>p-&gt;f()</code> 会通过 <code>vptr</code> 找到 <code>B_vtable</code> 中的 <code>B::f</code>，调用 <code>B::f()</code>。</li></ul></li></ol><p><strong>5. 重要细节</strong></p><ol><li><strong>非虚函数的调用</strong><ul><li><strong>非虚函数（如 <code>h()</code>）直接通过静态绑定</strong>（早期绑定）机制调用。</li><li>即便通过基类指针或引用调用，也<strong>不会进入虚函数表</strong>。</li></ul></li><li><strong>内存布局</strong><ul><li>每个<strong>对象的内存结构</strong>中会包含：<ul><li>成员变量（如 <code>x</code>, <code>y</code>, <code>z</code>）。</li><li><strong>一个隐式的虚指针（<code>vptr</code>），指向虚函数表</strong>。</li></ul></li></ul></li><li><strong>虚函数表的偏移量</strong><ul><li>通过 <code>vptr</code> 定位虚函数表后，根据函数在表中的位置（偏移量）找到函数地址，并调用该函数。</li></ul></li></ol><p><strong>示例：伪代码模拟调用过程</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示虚指针偏移量 -4</span></span><br><span class="line">(**((<span class="type">char</span>*)p - <span class="number">4</span>)) (p); <span class="comment">// 实际调用虚函数的过程</span></span><br></pre></td></tr></table></figure><img src="/2025/01/25/CPP-2-2/image-20241221001248854.png" class="" title="image-20241221001248854"><p><strong>1. 虚函数的动态绑定与多态性</strong></p><p><strong>代码分析</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; <span class="built_in">f</span>(); &#125;            <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;       <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;               <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">f</span>(); <span class="built_in">g</span>(); &#125;  <span class="comment">// 混合调用虚函数和普通成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;               <span class="comment">// 重写基类虚函数 f</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;               <span class="comment">// 普通成员函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>构造和函数调用顺序</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">B b;     <span class="comment">// A::A(), A::f, B::B()</span></span><br><span class="line">A* p = &amp;b;</span><br><span class="line"></span><br><span class="line">p-&gt;<span class="built_in">f</span>();  <span class="comment">// 调用B::f，因为f是虚函数</span></span><br><span class="line">p-&gt;<span class="built_in">g</span>();  <span class="comment">// 调用A::g，因为g是普通成员函数</span></span><br><span class="line">p-&gt;<span class="built_in">h</span>();  <span class="comment">// 混合调用虚函数和普通函数，具体调用细节解释如下</span></span><br></pre></td></tr></table></figure><ul><li>构造函数的执行顺序：<ul><li>基类的构造函数先执行，然后再执行派生类的构造函数。</li><li><strong>在基类构造函数中调用虚函数时，动态绑定机制被“部分禁用”，此时对象的类型仍然是基类。</strong></li><li>当基类的构造函数完成后，虚指针（vptr）才被初始化为派生类的虚函数表。</li></ul></li></ul><p><strong>2. 关键点解释</strong></p><p><strong>构造函数中调用虚函数</strong></p><ul><li>语句 <code>A() &#123; f(); &#125;</code>：<ul><li>在基类<strong>构造函数中，调用虚函数时，调用的是基类的实现</strong>，而不是派生类的重写版本。</li><li>原因是：<strong>构造函数执行时，对象尚未完全初始化，其动态类型仍被认为是基类类型</strong>。</li></ul></li></ul><p><strong>多态行为和动态绑定</strong></p><ul><li><code>p-&gt;f()</code>：<ul><li>虚函数 <code>f</code> 的调用通过动态绑定，根据对象的实际类型决定调用哪个实现。</li><li>这里 <code>p</code> 指向一个 <code>B</code> 类型的对象，因此调用的是 <code>B::f</code>。</li></ul></li><li><code>p-&gt;g()</code>：<ul><li><code>g</code> 是普通成员函数（非虚函数），采用早期绑定（静态绑定）。</li><li>因此，无论 <code>p</code> 的动态类型如何，调用的都是 <code>A::g</code>。</li></ul></li><li><code>p-&gt;h()</code>：<ul><li><code>h</code> 是基类中的普通成员函数。</li><li>在 <code>h</code> 中调用 <code>f</code> 和 <code>g</code> 时：<ul><li><code>f()</code> 是虚函数，调用的是 <code>B::f</code>。</li><li><code>g()</code> 是普通函数，调用的是 <code>A::g</code>。</li></ul></li></ul></li></ul><p>==<strong>3. 特殊行为：<code>this</code> 指针</strong>===</p><p>在<strong>派生类重写的虚函数中，<code>this</code> 指针的类型为 <code>B* const</code></strong>，它指向派生类对象本身。</p><p><strong>代码解释</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">g</span>();  <span class="comment">// 调用 B::g()</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行具体逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>在 <code>B::f</code> 中，<code>this</code> 指针的类型为 <code>B* const</code>，指向派生类对象。</li><li><code>this-&gt;g()</code> 的解析基于静态绑定，因此会调用 <code>B::g</code>。</li></ul><p><strong>4. PPT中的调用行为分析</strong></p><p><strong>关键代码与行为</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">B b;</span><br><span class="line">A* p = &amp;b;</span><br><span class="line">p-&gt;<span class="built_in">f</span>();  <span class="comment">// 调用B::f</span></span><br><span class="line">p-&gt;<span class="built_in">g</span>();  <span class="comment">// 调用A::g</span></span><br><span class="line">p-&gt;<span class="built_in">h</span>();  <span class="comment">// 调用A::h，但A::h中调用了B::f和A::g</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>p-&gt;f()</code></strong>：<ul><li>虚函数，通过动态绑定调用 <code>B::f</code>。</li><li>在 <code>B::f</code> 中，进一步调用 <code>B::g</code>。</li></ul></li><li><strong><code>p-&gt;g()</code></strong>：<ul><li>普通成员函数，静态绑定，调用 <code>A::g</code>。</li></ul></li><li><strong><code>p-&gt;h()</code></strong>：<ul><li>普通成员函数，调用 <code>A::h</code>。</li><li>在 <code>A::h</code> 内部：<ul><li><code>f()</code> 是虚函数，通过动态绑定调用 <code>B::f</code>。</li><li><code>g()</code> 是普通函数，静态绑定，调用 <code>A::g</code>。</li></ul></li></ul></li></ul><h3 id="final-override">final, override</h3><img src="/2025/01/25/CPP-2-2/image-20241221002332226.png" class="" title="image-20241221002332226"><p><strong>1. 代码解析与概念</strong></p><p><strong>基类 B 的定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span></span>;   <span class="comment">// 虚函数，带参数 int 和 const 限定符</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;           <span class="comment">// 普通虚函数，无参数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span>;                   <span class="comment">// 普通成员函数（非虚函数）</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f5</span><span class="params">(<span class="type">int</span>)</span> <span class="keyword">final</span></span>;  <span class="comment">// 虚函数，带 final 限定符，不能再被派生类重写</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong><code>virtual</code></strong>：虚函数，支持动态绑定，派生类可以重写。</li><li><strong><code>final</code></strong>：标记<strong>函数不能被进一步重写</strong>。</li><li><strong>非虚函数</strong>：如 <code>f3</code>，只能静态绑定，不能通过<code>override</code>重写。</li></ul><p><strong>派生类 D 的定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> : B &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span> <span class="keyword">override</span></span>; <span class="comment">// 正确，完全匹配基类 f1 的签名</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">int</span>)</span> <span class="keyword">override</span></span>;       <span class="comment">// 错误，基类没有 f2(int) 这样的函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span> <span class="keyword">override</span></span>;          <span class="comment">// 错误，f3 不是虚函数，不能重写</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">()</span> <span class="keyword">override</span></span>;          <span class="comment">// 错误，基类没有 f4 这样的函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f5</span><span class="params">(<span class="type">int</span>)</span></span>;                <span class="comment">// 错误，基类的 f5 被声明为 final，禁止重写</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>2. <code>override</code> 和 <code>final</code> 的作用</strong></p><p><strong><code>override</code></strong></p><ul><li>定义：<ul><li>明确指定派生类的函数是用来重写基类的虚函数。</li><li>编译器会检查函数签名是否和基类虚函数完全一致。</li></ul></li><li>作用：<ul><li>提高代码可读性和安全性，避免因函数签名不匹配导致的错误。</li><li>避免无意中创建了一个新的函数（不是重写基类的函数）。</li></ul></li></ul><p><strong><code>final</code></strong></p><ul><li>定义：<ul><li><strong>禁止派生类进一步重写某个虚函数。</strong></li><li>如果派生类尝试重写标记为<code>final</code>的虚函数，编译器报错。</li></ul></li><li>作用：<ul><li>提供明确的限制，防止虚函数被意外重写。</li><li>常用于设计中，需要确保某些函数的行为在派生类中保持不变。</li></ul></li></ul><p><strong>4. 总结</strong></p><table><thead><tr><th><strong>关键词</strong></th><th><strong>作用</strong></th><th><strong>使用场景</strong></th></tr></thead><tbody><tr><td><code>virtual</code></td><td>定义虚函数，支持动态绑定</td><td>允许派生类重写基类的函数</td></tr><tr><td><code>override</code></td><td>明确表示函数是重写基类的虚函数</td><td>防止派生类函数签名与基类不匹配而引发隐式错误</td></tr><tr><td><code>final</code></td><td>禁止派生类进一步重写某个虚函数</td><td>确保某些函数的行为在继承体系中保持不变，防止误重写</td></tr></tbody></table><h3 id="纯虚函数和抽象类">纯虚函数和抽象类</h3><img src="/2025/01/25/CPP-2-2/image-20241221002725340.png" class="" title="image-20241221002725340"><p><strong>1. 纯虚函数</strong></p><p>定义：</p><ul><li><p><strong>纯虚函数</strong>是指在类中声明为<code>= 0</code>的虚函数。</p></li><li><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> 返回类型 函数名(参数列表) = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li></ul><p>特点：</p><ol><li><strong>必须在派生类中重写：</strong><ul><li>如果派生类没有重写纯虚函数，派生类本身也会变成抽象类（即无法实例化）。</li></ul></li></ol><p><strong>2. 抽象类</strong></p><p>定义：</p><ul><li><p><strong>抽象类</strong>是指<strong>至少包含一个纯虚函数</strong>的类。</p></li><li><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>特点：</p><ol><li><p><strong>不能实例化：</strong></p><ul><li><p>抽象类无法直接创建对象。</p></li><li><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbstractClass obj;  <span class="comment">// 错误，抽象类不能实例化</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>可以定义构造函数和成员变量：</strong></p><ul><li>抽象类<strong>可以有构造函数</strong>，但只能被派生类调用，用于初始化基类部分。</li><li>抽象类也可以包含非纯虚函数和普通成员变量。</li></ul></li><li><p><strong>为派生类提供框架：</strong></p><ul><li><p>抽象类的作用是定义接口和行为框架，让派生类根据需要实现具体功能。</p></li><li><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() &#123;&#125;      <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现圆的绘制</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>派生类必须实现所有纯虚函数：</strong></p><ul><li>否则，派生类也会成为抽象类。</li></ul></li></ol><p><strong>3. 纯虚函数和抽象类的关系</strong></p><ul><li><p>如果一个类中有一个或多个纯虚函数，则该类一定是抽象类。</p></li><li><p>抽象类可以包含非纯虚函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nonVirtualFunc</span><span class="params">()</span> </span>&#123; <span class="comment">/* 普通函数实现 */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><strong>4. 内部机制：_pure_virtual_called</strong></p><ul><li>“Means ‘not there’”：<ul><li>表示纯虚函数在基类中没有实现，派生类必须提供具体实现。</li></ul></li><li><code>_pure_virtual_called</code>：<ul><li>如果在程序运行时调用了一个未被实现的纯虚函数（例如，派生类没有重写纯虚函数），程序会抛出<code>_pure_virtual_called</code>错误。</li></ul></li></ul><img src="/2025/01/25/CPP-2-2/image-20241221003131430.png" class="" title="image-20241221003131430"><img src="/2025/01/25/CPP-2-2/image-20241221003159161.png" class="" title="image-20241221003159161"><img src="/2025/01/25/CPP-2-2/image-20241221003244928.png" class="" title="image-20241221003244928"><ul><li><strong>协变返回类型的规则</strong></li><li>如果子类重写父类的虚函数，<strong>返回值可以是父类虚函数返回类型的派生类</strong>。</li><li>协变返回类型仅适用于<strong>指针</strong>或<strong>引用</strong>类型，而不适用于普通值类型。</li></ul><img src="/2025/01/25/CPP-2-2/image-20241221003525976.png" class="" title="image-20241221003525976"><h3 id="虚析构函数">虚析构函数</h3><img src="/2025/01/25/CPP-2-2/image-20241221003538967.png" class="" title="image-20241221003538967"><p><strong>1. 问题背景</strong></p><p><strong>代码情景</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">B* p = <span class="keyword">new</span> D;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure><ul><li><code>p</code> 是基类 <code>B</code> 的指针，指向了派生类 <code>D</code> 的对象。</li><li>使用 <code>delete p;</code> 来删除对象时，行为可能出问题。</li></ul><p><strong>2. 虚析构函数的作用</strong></p><p>虚析构函数的作用是确保当使用基类指针删除派生类对象时，能够正确调用派生类和基类的析构函数。</p><p><strong>未使用虚析构函数时的问题</strong></p><ul><li>如果基类的析构函数不是虚函数，那么使用 <code>delete p;</code> 时，只会调用<strong>基类的析构函数</strong>，不会调用派生类的析构函数。</li><li>这会导致：<ul><li>派生类中的资源未被正确释放（例如堆内存）。</li><li>可能造成内存泄漏或未定义行为。</li></ul></li></ul><p><strong>虚析构函数的定义</strong></p><p>在基类中将析构函数声明为虚函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">B</span>() &#123; ... &#125;  <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>当 <code>delete p;</code> 被执行时，虚函数机制会确保派生类的析构函数被调用，然后再调用基类的析构函数。</li></ul><p><strong>正确调用链</strong></p><ul><li><p>使用虚析构函数后，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete p;</span><br></pre></td></tr></table></figure><p>将按照如下顺序调用：</p><ul><li>调用派生类 <code>D</code> 的析构函数。</li><li>调用基类 <code>B</code> 的析构函数。</li></ul></li></ul><p><strong>3. PPT第一部分分析</strong></p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">B* p = <span class="keyword">new</span> D;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><ol><li><p>如果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B</span><br></pre></td></tr></table></figure><p>的析构函数不是虚函数，则：</p><ul><li>只会调用 <code>B</code> 的析构函数。</li><li><code>D</code> 的析构函数不会被调用。</li><li>派生类 <code>D</code> 中可能动态分配的资源无法被释放。</li></ul></li><li><p>如果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B</span><br></pre></td></tr></table></figure><p>的析构函数是虚函数，则：</p><ul><li><code>delete p;</code> 会正确调用 <code>D</code> 的析构函数，然后调用 <code>B</code> 的析构函数。</li></ul></li></ol><p><strong>结论</strong></p><p>需要将基类的析构函数声明为虚函数，以避免资源泄漏。</p><p><strong>4. PPT第二部分分析</strong></p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">mystring</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B &#123;</span><br><span class="line">    mystring name;  <span class="comment">// 派生类中含有复杂类型成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B* p = <span class="keyword">new</span> D;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><ul><li><p>这里派生类 <code>D</code> 中包含一个复杂类型成员 <code>mystring</code>，该类型可能有自己的构造函数和析构函数。</p></li><li><p>如果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B</span><br></pre></td></tr></table></figure><p>的析构函数不是虚函数：</p><ul><li>只会调用基类 <code>B</code> 的析构函数。</li><li><code>D</code> 的析构函数不会被调用。</li><li><code>mystring</code> 的析构函数也不会被调用。</li><li>结果可能导致派生类中成员 <code>name</code> 所占用的资源未释放。</li></ul></li></ul><p><strong>结论</strong></p><p>当派生类包含需要特殊析构的复杂成员（如动态分配内存或类对象）时，未使用虚析构函数的基类可能导致更严重的资源泄漏。</p><hr><p><strong>5. 总结</strong></p><p><strong>虚析构函数的必要性</strong></p><ul><li><strong>使用虚析构函数是面向多态编程的重要实践</strong>。</li><li>如果一个基类有可能被继承，并且通过基类指针来操作对象，基类的析构函数应该被声明为虚函数。</li><li>这样可以确保<strong>正确地调用派生类的析构函数</strong>，避免资源泄漏和未定义行为。</li></ul><p><strong>使用虚析构函数的模板</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B Destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">D</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;D Destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>当通过基类指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete</span><br></pre></td></tr></table></figure><p>一个派生类对象时：</p><ul><li>首先调用 <code>D</code> 的析构函数。</li><li>然后调用 <code>B</code> 的析构函数。</li></ul></li></ul><p><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B* p = <span class="keyword">new</span> <span class="built_in">D</span>();</span><br><span class="line">    <span class="keyword">delete</span> p;  <span class="comment">// 确保正确调用析构函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D Destructor</span><br><span class="line">B Destructor</span><br></pre></td></tr></table></figure><img src="/2025/01/25/CPP-2-2/image-20241221003920688.png" class="" title="image-20241221003920688"><p><strong>1. 虚函数与继承的设计原则</strong></p><p><strong>明确 public inheritance 的含义</strong></p><ul><li>“is-a” 关系：<ul><li>派生类与基类应该遵循 “is-a” 的关系，表示派生类对象是基类对象的一种特殊化。</li><li>例如，<code>FlyingBird</code> 是一种鸟，符合 “is-a” 关系；<code>NonFlyingBird</code> 也是一种鸟，符合 “is-a” 关系。</li><li>但是，<code>NonFlyingBird</code> 实现 <code>fly</code> 函数时，应当明确处理特性差异，例如给出错误提示 “Penguins can’t fly”。</li></ul></li></ul><p><strong>避免覆盖非虚成员函数</strong></p><ul><li>不要在派生类中定义与继承而来的非虚成员函数同名的函数。<ul><li>如果基类成员函数不是虚函数，而派生类定义了同名函数，这将导致隐藏（隐藏基类的非虚函数），可能产生不符合预期的行为。</li><li>推荐使用 <code>virtual</code> 明确成员函数的重载意图。</li></ul></li></ul><p><strong>2. Rectangle 和 Square 的设计问题</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setWidth</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">width</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Rectangle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setLength</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setWidth</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>问题背景</strong></p><ul><li>从数学意义上，正方形是一种特殊的矩形（Square is a Rectangle）。</li><li>然而，正方形的宽和高总是相等的，如果直接继承 Rectangle 并提供 <code>setHeight</code> 和 <code>setWidth</code> 的独立实现，会导致语义冲突。</li></ul><p><strong>代码分析</strong></p><ul><li><code>Square</code> 重载了 <code>setHeight</code> 和 <code>setWidth</code> 并将其设为 <code>private</code>，从而限制了直接调用。</li><li>但<strong>这种做法会导致多态行为的问题，因为基类的虚函数机制允许通过基类指针调用派生类的 <code>setHeight</code> 和 <code>setWidth</code></strong>，从而破坏正方形的约束（宽等于高）。</li></ul><p><strong><code>Square::setHeight</code> 是 private 的，能否调用？</strong></p><ul><li><p>虽然 <code>Square::setHeight</code> 是 <code>private</code> 的，但这并不会阻止通过 <strong>基类指针</strong> 调用虚函数的过程。</p></li><li><p>访问控制规则（<code>public</code>、<code>protected</code>、<code>private</code>）是在</p><p><strong>编译期检查</strong>的，而虚函数的解析是在<strong>运行时完成</strong>的。这是关键点：</p><ul><li>编译时：编译器只会检查 <code>Rectangle</code> 类的 <code>setHeight</code> 是否对调用方可见。<ul><li>因为 <code>Rectangle::setHeight</code> 是 <code>public</code> 的，所以编译器允许调用 <code>p-&gt;setHeight(10)</code>。</li></ul></li><li><strong>运行时</strong>：由于 <code>p</code> 实际指向一个 <code>Square</code> 对象，虚函数机制会在运行时调用 <code>Square</code> 的 <code>setHeight</code> 方法，<strong>无视访问控制</strong>。</li></ul></li></ul><p>因此，<strong>即使 <code>Square::setHeight</code> 是 <code>private</code> 的，虚函数机制仍然会在运行时调用它</strong>。</p><p><strong>为什么会导致 <code>assert</code> 失败？</strong></p><ul><li>由于 <code>Square::setHeight</code> 是 <code>private</code> 的，开发者的本意可能是希望外部代码无法直接修改正方形的高度和宽度，以保持正方形的数学约束（宽等于高）。</li><li>但通过基类指针调用虚函数时，<code>Square::setHeight</code> 被调用，而这个方法可能<strong>只修改高度</strong>，却没有同步修改宽度。</li><li>结果就是：正方形的宽度和高度不再相等，破坏了正方形的语义。</li></ul><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Square <span class="title">s</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">Rectangle* p = &amp;s;</span><br><span class="line">p-&gt;<span class="built_in">setHeight</span>(<span class="number">10</span>); <span class="comment">// 调用了 Square::setHeight，只修改了高度</span></span><br><span class="line"><span class="built_in">assert</span>(s.<span class="built_in">width</span>() == s.<span class="built_in">height</span>()); <span class="comment">// 断言失败，因为宽度没有同步更新</span></span><br></pre></td></tr></table></figure><h3 id="private继承">private继承</h3><img src="/2025/01/25/CPP-2-2/image-20241221093747287.png" class="" title="image-20241221093747287"><ol><li><strong>private继承的概念</strong></li></ol><ul><li><strong>private继承</strong>是C++中的一种继承方式。</li><li>与<code>public继承</code>不同，<code>private继承</code>的目的并不是为了建立&quot;is-a&quot;（是一个）的关系，而是为了实现<code>&quot;implemented-in-term-of&quot;</code>（通过某个类的实现来实现另一个类的功能）。</li><li>访问控制的特性：<ul><li>基类的<code>public</code>和<code>protected</code>成员，在派生类中都会变成<code>private</code>。</li><li>派生类的外部无法直接访问基类的成员。</li></ul></li><li>设计目的：<ul><li>主要用于<strong>实现层面</strong>，而非设计层面，强调实现的内部逻辑，而不是在类型系统中建立父子关系。</li></ul></li></ul><ol start="2"><li><strong>PPT中的代码及解释</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CHumanBeing</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStudent</span> : <span class="keyword">private</span> CHumanBeing &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">const</span> CHumanBeing&amp; h)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">CHumanBeing a;</span><br><span class="line">CStudent b;</span><br><span class="line"><span class="built_in">eat</span>(a);  <span class="comment">// 正常，CHumanBeing的对象可以直接传入</span></span><br><span class="line"><span class="built_in">eat</span>(b);  <span class="comment">// 错误，因为CStudent不能被隐式转换为CHumanBeing</span></span><br></pre></td></tr></table></figure><p><strong>(1) 为什么 <code>eat(b)</code> 报错？</strong></p><ul><li><p><code>CStudent</code>通过<code>private继承</code>自<code>CHumanBeing</code>。</p></li><li><p>在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private继承</span><br></pre></td></tr></table></figure><p>中，派生类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CStudent</span><br></pre></td></tr></table></figure><p>不能隐式地被看作基类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHumanBeing</span><br></pre></td></tr></table></figure><p>。</p><ul><li>也就是说，<code>CStudent</code> <strong>不是</strong> <code>CHumanBeing</code> 的一种（<code>is-a</code>关系不成立）。</li></ul></li><li><p>因此，调用<code>eat(b)</code>时会报错，因为<code>eat</code>函数需要一个<code>CHumanBeing&amp;</code>类型的参数，但无法将<code>CStudent</code>隐式转换为<code>CHumanBeing</code>。</p></li></ul><p><strong>(2) <code>private继承</code>的特性</strong></p><ul><li><code>private继承</code>中，基类的成员在派生类中变为<code>private</code>，仅供派生类自身访问。</li><li>外部代码无法直接访问基类的成员，也无法将派生类对象视为基类对象。</li></ul><ol start="3"><li><strong>private继承的用途</strong></li></ol><p><strong>(1) 实现&quot;implemented-in-term-of&quot;</strong></p><ul><li>通过<code>private继承</code>，派生类可以使用基类的<code>protected</code>成员或者覆盖其<code>virtual</code>函数，从而复用基类的实现。</li><li><strong>这种复用是“通过实现”而非“通过接口”</strong>。</li></ul><p><strong>(2) 隐藏基类的接口</strong></p><ul><li><code>private继承</code>会隐藏基类的所有<code>public</code>和<code>protected</code>接口，从而防止派生类的用户直接访问这些接口。</li><li>在设计上，强调“我实现了某些功能，但不希望外界知道我是通过继承某个类来实现的”。</li></ul><p><strong>(3) 强调实现层面的关系，而非类型层面的关系</strong></p><ul><li>与<code>public继承</code>不同，<code>private继承</code>不会建立父子类的类型层次关系。</li><li>在类型系统中，<code>CStudent</code>与<code>CHumanBeing</code>是完全不同的类型，不会因为继承而建立任何类型上的联系。</li></ul><hr><ol start="4"><li><strong>常见应用场景</strong></li></ol><p><strong>(1) 需要访问基类的<code>protected</code>成员</strong></p><ul><li>如果需要访问基类的<code>protected</code>成员，但又不希望外界把派生类当成基类使用，可以采用<code>private继承</code>。</li></ul><p><strong>(2) 不希望基类的接口暴露给用户</strong></p><ul><li><p>例如，如果一个类内部需要用到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector</span><br></pre></td></tr></table></figure><p>来管理数据，但又不希望外界把这个类当成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector</span><br></pre></td></tr></table></figure><p>来使用，就可以用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private继承</span><br></pre></td></tr></table></figure><p>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyContainer</span> : <span class="keyword">private</span> std::vector&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">push_back</span>(value); <span class="comment">// 使用std::vector的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">size_t</span> index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">at</span>(index); <span class="comment">// 使用std::vector的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><strong>(3) 用作纯粹的实现工具</strong></p><ul><li>基类只是作为一个工具类，提供实现的某些基础功能，而不会用于表示一种类型的关系。</li></ul><ol start="5"><li><strong>与组合的对比</strong></li></ol><p>在许多情况下，组合（<code>has-a</code>）比继承（特别是<code>private继承</code>）更合适：</p><ul><li>如果派生类只需要利用基类的实现，并不需要访问其<code>protected</code>成员，通常可以选择组合。</li><li>组合的优势是更加灵活，能够明确表示语义上的关系：<ul><li><strong>组合</strong>：表示“有一个”关系（<code>has-a</code>）。</li><li><strong>继承</strong>：表示“是一个”关系（<code>is-a</code> 或 <code>implemented-in-term-of</code>）。</li></ul></li></ul><img src="/2025/01/25/CPP-2-2/image-20241221094159034.png" class="" title="image-20241221094159034"><img src="/2025/01/25/CPP-2-2/image-20241221094306142.png" class="" title="image-20241221094306142"><ol><li><strong>调用虚函数的机制</strong></li></ol><ul><li><p><strong>通过基类指针或引用调用虚函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A *p_a;</span><br><span class="line">B b;</span><br><span class="line">p_a = &amp;b;</span><br><span class="line">p_a-&gt;<span class="built_in">f</span>();  <span class="comment">// 调用B::f()</span></span><br></pre></td></tr></table></figure><ul><li>当通过<code>p_a</code>调用<code>f</code>时，<code>p_a</code>指向<code>B</code>类对象的虚表。</li><li>虚表指针<code>vptr</code>会定位到<code>B</code>的虚表，找到<code>B::f</code>的地址，并完成调用。</li></ul></li><li><p><strong>缺省参数值的注意点</strong></p><ul><li>虽然虚函数的动态绑定是运行时完成的，但缺省参数值是在<strong>编译时</strong>确定的。</li><li>如果通过基类指针<code>p_a</code>调用<code>f</code>，缺省参数值使用的是<strong>基类中定义的值</strong>，而不是派生类中的值。</li></ul></li></ul><ol start="2"><li><strong>为什么“绝对不要重新定义继承而来的缺省参数值”</strong></li></ol><ul><li>PPT中指出：<strong>缺省参数值是编译时绑定的，而虚函数调用是运行时绑定的</strong>。</li><li>这会导致<strong>调用虚函数时的行为与缺省参数值不一致</strong>。</li></ul><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A *p_a1;</span><br><span class="line">C c;</span><br><span class="line">p_a1 = &amp;c;</span><br><span class="line">p_a1-&gt;<span class="built_in">f</span>();  <span class="comment">// 调用的是C::f，但参数值是A中定义的0</span></span><br></pre></td></tr></table></figure><ul><li><pre><code>p_a1-&gt;f()<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ：</span><br><span class="line"></span><br><span class="line">  - **动态绑定**：调用的是`C::f`。</span><br><span class="line">  - **缺省参数值**：使用的是`A`中定义的`x = 0`，而不是`C`中的参数值。</span><br><span class="line"></span><br><span class="line">- 结果：</span><br><span class="line"></span><br><span class="line">  - 函数调用的行为是`C::f(0)`，但用户可能期望`C`中的缺省参数值被使用，从而导致程序行为不符合预期。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 多继承</span><br><span class="line"></span><br><span class="line">![image-20241221095153747](CPP-2-2/image-20241221095153747.png)</span><br><span class="line"></span><br><span class="line">![image-20241221095256848](CPP-2-2/image-20241221095256848.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20241221095343505](CPP-2-2/image-20241221095343505.png)</span><br><span class="line"></span><br><span class="line">![image-20241221095610292](CPP-2-2/image-20241221095610292.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**第一张PPT：未经优化的多继承设计**</span><br><span class="line"></span><br><span class="line">1. 背景：直接多继承</span><br><span class="line">   - `SleepSofa` 类直接继承了 `Bed` 和 `Sofa`。</span><br><span class="line">   - `Bed` 和 `Sofa` 各自定义了 `weight` 和 `SetWeight()`，表示床和沙发的重量属性和设置重量的方法。</span><br><span class="line">   - 问题：二义性与冗余</span><br><span class="line">     - `SleepSofa` 通过继承得到了两个独立的 `weight` 和 `SetWeight()`，一个来自 `Bed`，一个来自 `Sofa`。</span><br><span class="line">     - 编译器会不知道当访问 `weight` 或调用 `SetWeight()` 时是调用 `Bed` 的还是 `Sofa` 的，导致**二义性**。</span><br><span class="line">     - 数据冗余：两个 `weight` 和 `SetWeight()` 是重复的。</span><br><span class="line"></span><br><span class="line">**第二张PPT：基类分解（Base-Class Decomposition）**</span><br><span class="line"></span><br><span class="line">1. 优化：将公共部分抽取到公共基类</span><br><span class="line">   - 引入 `Furniture` 基类：</span><br><span class="line">     - 定义了 `weight` 和 `SetWeight()`，将这两个功能抽取出来，表示所有家具的公共属性。</span><br><span class="line">     - `Bed` 和 `Sofa` 继承 `Furniture`，扩展自己独有的功能（如 `Sleep()` 和 `WatchTV()`）。</span><br><span class="line">   - 解决问题：</span><br><span class="line">     - 数据冗余消除：`SleepSofa` 只需要从 `Furniture` 中继承一次 `weight` 和 `SetWeight()`。</span><br><span class="line">     - 消除了二义性：`SleepSofa` 调用 `SetWeight()` 时是从 `Furniture` 中继承而来。</span><br><span class="line">   - 缺陷：依然存在多继承的潜在问题：</span><br><span class="line">     - 如果 `Bed` 和 `Sofa` 继承 `Furniture` 是普通继承，`SleepSofa` 依然会继承两份 `Furniture` 的副本（因为每个基类都有一份）。</span><br><span class="line"></span><br><span class="line">**第三张PPT：引入虚继承（Virtual Inheritance）**</span><br><span class="line"></span><br><span class="line">1. 进一步优化：使用虚继承</span><br><span class="line">   - 引入虚继承的概念：</span><br><span class="line">     - `Bed` 和 `Sofa` **使用 `virtual` 关键字继承 `Furniture`**。</span><br><span class="line">     - `SleepSofa` 通过虚继承机制只继承了一份 `Furniture` 的副本。</span><br><span class="line">   - 特点：</span><br><span class="line">     - 虚继承消除了因普通继承产生的**冗余副本**问题。</span><br><span class="line">     - `Furniture` 中的 `weight` 和 `SetWeight()` 在整个继承链中只存在一个副本，`SleepSofa` 只需要管理一份 `Furniture` 的数据和行为。</span><br><span class="line">   - 优点：</span><br><span class="line">     - 解决了多继承中的二义性和冗余问题。</span><br><span class="line">     - 通过虚继承，保证 `SleepSofa` 不会出现多个 `Furniture` 副本的问题。</span><br><span class="line"></span><br><span class="line">**三张PPT的总结**</span><br><span class="line"></span><br><span class="line">1. 第一张：直接多继承</span><br><span class="line">   - 展示了多继承的基本问题：二义性和数据冗余。</span><br><span class="line">2. 第二张：基类分解</span><br><span class="line">   - 将公共功能抽取到公共基类中（`Furniture`），减少了重复代码，解决了一部分问题，但没有完全消除多继承的二义性。</span><br><span class="line">3. 第三张：虚继承</span><br><span class="line">   - 通过虚继承（`virtual` 关键字），在整个继承链中只存在一个 `Furniture` 的副本，彻底解决了二义性和冗余问题。</span><br><span class="line"></span><br><span class="line">**补充：虚继承的代价**</span><br><span class="line"></span><br><span class="line">虽然虚继承解决了多继承中的二义性问题，但引入了额外的开销：</span><br><span class="line"></span><br><span class="line">- 每个虚继承的基类在派生类中有一个指针，用于指向共享的基类数据。</span><br><span class="line">- 动态绑定的开销稍微增加。</span><br><span class="line"></span><br><span class="line">总的来说，虚继承是一种面向对象编程中解决多继承冲突的重要手段，特别适用于需要公共基类的复杂继承结构中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20241221095827663](CPP-2-2/image-20241221095827663.png)</span><br><span class="line"></span><br><span class="line">1. **基类的声明顺序对多继承的影响**</span><br><span class="line"></span><br><span class="line">**基类构造函数和析构函数的调用顺序**</span><br><span class="line"></span><br><span class="line">- 规则：在多继承中，基类的构造函数调用顺序由基类在派生类声明中的顺序决定。</span><br><span class="line"></span><br><span class="line">  - 比如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>  class D : B, C &#123;&#125;  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - 构造时：先调用 `B` 的构造函数，再调用 `C` 的构造函数，最后是派生类 `D` 的构造函数。</span><br><span class="line">    - 析构时：顺序相反，先析构 `D`，然后是 `C`，最后是 `B`。</span><br><span class="line"></span><br><span class="line">**基类数据成员的存储排列**</span><br><span class="line"></span><br><span class="line">- 规则：基类数据成员在内存中的存储顺序与基类声明的顺序一致。</span><br><span class="line">  - 这保证了在对象布局时，基类的成员能够按照其声明顺序被正确访问。</span><br><span class="line"></span><br><span class="line">2. **命名冲突问题**</span><br><span class="line"></span><br><span class="line">**问题描述**</span><br><span class="line"></span><br><span class="line">- 在多继承中，不同基类可能有同名的成员或方法，这会导致冲突。</span><br><span class="line"></span><br><span class="line">  - 如例子所示：</span><br><span class="line"></span><br><span class="line">    ```cpp</span><br><span class="line">    class A &#123;</span><br><span class="line">        int x;</span><br><span class="line">    &#125;;</span><br><span class="line">    class B : A &#123;&#125;;</span><br><span class="line">    class C : A &#123;&#125;;</span><br><span class="line">    class D : B, C &#123;&#125;;</span><br></pre></td></tr></table></figure>  在   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D</span><br></pre></td></tr></table></figure>   中，会因为   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B</span><br></pre></td></tr></table></figure>   和   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C</span><br></pre></td></tr></table></figure>   都继承了   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A</span><br></pre></td></tr></table></figure>  ，从而导致   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A</span><br></pre></td></tr></table></figure>   的成员（如   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x</span><br></pre></td></tr></table></figure>  ）出现两份。</code></pre></li></ul><p><strong>解决方案</strong></p><ul><li><p>使用作用域解析符明确指定访问哪个基类的成员：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;基类名&gt;::&lt;基类成员名&gt;;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d.B::x; <span class="comment">// 访问从 B 中继承的 A 的 x</span></span><br><span class="line">d.C::x; <span class="comment">// 访问从 C 中继承的 A 的 x</span></span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><strong>虚基类：解决冗余副本问题</strong></li></ol><p><strong>问题描述</strong></p><ul><li>如果多个基类继承了同一个公共基类，派生类会包含该公共基类的多份副本，造成数据冗余。<ul><li>在PPT中的例子中：<ul><li><code>class B : public A</code> 和 <code>class C : public A</code> 都从 <code>A</code> 继承。</li><li><code>class D : public B, public C</code> 会拥有 <code>A</code> 的两份独立副本。</li><li><code>D</code> 在访问 <code>A</code> 的成员时，会引发<strong>二义性</strong>问题。</li></ul></li></ul></li></ul><p><strong>虚基类的引入</strong></p><ul><li><p>定义：通过在继承时使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual</span><br></pre></td></tr></table></figure><p>关键字声明基类为虚基类，可以解决上述问题。</p><ul><li><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>效果：</p><ul><li><code>D</code> 类中只会保留 <strong>一份公共基类 <code>A</code> 的副本</strong>。</li><li>虚基类的初始化由最派生类（即 <code>D</code>）负责，基类 <code>B</code> 和 <code>C</code> 不再重复初始化 <code>A</code>。</li></ul></li></ul><p><strong>总结</strong></p><p>这张PPT的重点在于：</p><ol><li><strong>基类构造和析构顺序</strong>是由声明顺序决定的，数据成员的存储顺序也遵循这一规则。</li><li><strong>命名冲突</strong>通过作用域解析符 <code>&lt;基类名&gt;::&lt;基类成员名&gt;</code> 解决。</li><li>**虚基类（Virtual Base Class）**是解决多继承中公共基类冗余副本问题的核心机制，能够有效避免二义性和冗余。</li></ol><img src="/2025/01/25/CPP-2-2/image-20241221100122760.png" class="" title="image-20241221100122760"><ol><li><strong>类D拥有两个成员 <code>B::x</code> 和 <code>C::x</code></strong></li></ol><p><strong>问题描述</strong></p><ul><li><p>在多继承中，如果两个基类中有同名成员变量或者成员函数，派生类会继承这些同名成员。</p></li><li><p>在此例中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><code>D</code> 类中会包含两份 <code>A</code> 的成员 <code>x</code>，分别是 <code>B::x</code> 和 <code>C::x</code>。</p></li><li><p>访问时会产生二义性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D d;</span><br><span class="line">d.x; <span class="comment">// 错误，编译器不知道是 B::x 还是 C::x</span></span><br></pre></td></tr></table></figure></li><li><p>解决办法是使用作用域限定符显式指定：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d.B::x; <span class="comment">// 访问 B 中的 x</span></span><br><span class="line">d.C::x; <span class="comment">// 访问 C 中的 x</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ol start="2"><li><strong>虚基类的作用</strong></li></ol><p><strong>问题描述</strong></p><ul><li>如果 <code>B</code> 和 <code>C</code> 都继承自 <code>A</code>，<code>D</code> 再同时继承 <code>B</code> 和 <code>C</code>，<code>D</code> 中会包含两份 <code>A</code> 的副本，导致冗余和不必要的开销。</li><li>解决方案是使用<strong>虚基类</strong>，通过 <code>virtual</code> 关键字声明基类。</li></ul><p><strong>虚基类的效果</strong></p><ul><li><p>如果将 <code>A</code> 声明为 <code>virtual public</code> 或 <code>public virtual</code>，则无论 <code>B</code> 和 <code>C</code> 中如何继承 <code>A</code>，<code>D</code> 中只会有一份 <code>A</code> 的副本。</p></li><li><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;&#125;;</span><br></pre></td></tr></table></figure><ul><li>这样 <code>D</code> 中就只有一份 <code>A</code> 的数据成员。</li></ul></li></ul><p><strong>注意事项</strong></p><ol><li><p><strong>虚基类的构造函数调用由派生类负责</strong>：</p><ul><li>虚基类的初始化在最派生类中完成。</li><li>比如，在 <code>D</code> 的构造函数中，负责调用 <code>A</code> 的构造函数，而不是 <code>B</code> 和 <code>C</code>。</li></ul></li><li><p><strong>构造函数的执行顺序</strong>：</p><ul><li><strong>虚基类的构造函数优先于非虚基类的构造函数执行</strong>。</li><li>构造顺序为：<strong>虚基类 -&gt; 非虚基类 -&gt; 派生类本身</strong>。</li></ul></li><li><p><strong>代码示例</strong></p></li></ol><p>以下是PPT中对应的代码说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;&#125;;</span><br></pre></td></tr></table></figure><p><strong>行为分析</strong></p><ol><li><p><code>B</code> 和 <code>C</code> 都声明了 <code>A</code> 为虚基类，因此在 <code>D</code> 中只有一份 <code>A</code> 的成员。</p></li><li><p>如果 <code>B</code> 和 <code>C</code> 的继承不是虚基类，则 <code>D</code> 中会有两份 <code>A</code> 的成员。</p></li><li><p><strong>总结</strong></p></li></ol><ul><li>虚基类的特点：<ul><li>解决了多继承中由于公共基类导致的冗余数据问题。</li><li>保证派生类中只有一份虚基类的成员。</li><li>虚基类的构造由最派生类负责。</li></ul></li><li>使用注意：<ul><li>在<strong>派生类构造函数中，如果虚基类没有默认构造函数，必须显式初始化虚基类成员</strong>，避免未初始化问题。</li><li>虚基类的构造优先于非虚基类。</li></ul></li></ul><img src="/2025/01/25/CPP-2-2/image-20241221100630464.png" class="" title="image-20241221100630464">]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++高级程序设计笔记（C2-3）</title>
      <link href="/2025/01/25/CPP-2-3/"/>
      <url>/2025/01/25/CPP-2-3/</url>
      
        <content type="html"><![CDATA[<h1>CPP-2-3</h1><h2 id="多态">多态</h2><img src="/2025/01/25/CPP-2-3/image-20241221102705367.png" class="" title="image-20241221102705367"><ol><li><strong>多态的定义</strong></li></ol><p><strong>多态（Polymorphism）是一种面向对象程序设计的基本特性，指的是同一逻辑域中一个元素可以具有多种解释或形式</strong>。在C++中，多态有以下特点：</p><ul><li><strong>提升语言的灵活性</strong>：通过多态，程序可以在不修改已有代码的情况下扩展新功能。</li><li>多态在面向对象编程中实现了<strong>代码复用和扩展性</strong>，是实现动态绑定的基础。</li></ul><ol start="2"><li><strong>多态在程序设计语言中的体现</strong></li></ol><p>PPT中提到了三种多态的形式，分别是：</p><p>（1）<strong>一名多用</strong>（函数重载）</p><p>这是静态多态（Compile-time Polymorphism）的一种形式：</p><ul><li><p>函数重载（Function Overloading）：同名函数可以根据参数的类型或数量不同而表现出不同的行为。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>根据传入的参数类型，编译器在编译时决定调用哪个函数版本。</li></ul></li></ul><p>（2）<strong>类属</strong>（模板）</p><p>这是另一种静态多态的实现方式：</p><ul><li><p>模板（Template）：C++通过模板实现通用编程，使同一段代码能够处理多种数据类型。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用模板，<code>add&lt;int&gt;</code>可以处理整数，<code>add&lt;double&gt;</code>可以处理浮点数。</li></ul></li></ul><p>（3）<strong>OO程序设计（虚函数）</strong></p><p>这是动态多态（Run-time Polymorphism）的形式：</p><ul><li><p>虚函数（Virtual Function）：C++通过虚函数和动态绑定实现运行时的多态。</p><ul><li><p>父类定义一个虚函数，子类可以重写（override）该函数。在运行时，通过基类指针调用函数时，会根据对象的实际类型动态决定调用哪一个函数实现。</p></li><li><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing Shape&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing Circle&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Shape* s = <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br><span class="line">s-&gt;<span class="built_in">draw</span>(); <span class="comment">// 输出 &quot;Drawing Circle&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>总结</strong></p><p>这张PPT强调了多态作为C++语言核心特性之一的灵活性，以及它在编程中的三种主要体现：</p><ol><li><strong>静态多态</strong>（函数重载、模板）</li><li><strong>动态多态</strong>（虚函数） 通过这些机制，C++能够高效地支持面向对象编程和泛型编程，提升代码的复用性和可扩展性。</li></ol><h2 id="操作符重载">操作符重载</h2><img src="/2025/01/25/CPP-2-3/image-20241221103247206.png" class="" title="image-20241221103247206"><ol><li><strong>函数重载</strong></li></ol><p>定义</p><ul><li><strong>函数重载（Function Overloading）**是C++的一种静态多态（Compile-time Polymorphism），允许在同一作用域中定义多个**同名但参数列表不同</strong>的函数。</li><li>特点：<ul><li><strong>名称相同，参数不同</strong>：函数名相同，但参数的个数、类型或顺序不同。</li><li><strong>静态绑定</strong>：在编译时由编译器根据调用的参数类型和数量决定调用哪个版本的函数。</li></ul></li></ul><p>实现机制</p><ul><li><p>编译器通过“函数签名（Function Signature）”来区分函数。</p><ul><li>函数签名包括函数名和参数列表（不包括返回值）。</li></ul></li><li><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span></span>;      <span class="comment">// 打印整数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> x)</span></span>;   <span class="comment">// 打印浮点数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(string x)</span></span>;   <span class="comment">// 打印字符串</span></span><br></pre></td></tr></table></figure></li></ul><p>优点</p><ul><li>提高<strong>代码可读性</strong>：同一功能的操作使用相同的名称，更加直观。</li><li>提高<strong>代码扩展性</strong>：通过重载扩展功能，而不需要为每种类型单独定义不同的函数名。</li></ul><ol start="2"><li><strong>操作符重载</strong></li></ol><p>定义</p><ul><li>**操作符重载（Operator Overloading）**是C++的一种特性，允许程序员为自定义类型定义操作符（如<code>+</code>、<code>-</code>、<code>==</code>等）的行为。</li><li>特点：<ul><li>C++中大多数内置操作符（如<code>+</code>、<code>*</code>、<code>==</code>等）可以重载，只有少数操作符（如<code>::</code>、<code>.*</code>、<code>sizeof</code>等）不能重载。</li><li>可以对内置类型或用户自定义类型（如类）进行操作符重载。</li></ul></li></ul><p>实现方式</p><ul><li><p>通过定义一个特殊的成员函数或友元函数来实现。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &quot;+&quot; 运算符</span></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; c) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;real + c.real, imag + c.imag&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>使用场景</p><ul><li><strong>扩展性</strong>：当需要对自定义类型（如类）进行操作符操作时。</li><li><strong>提高代码可读性</strong>：通过重载操作符，使得自定义类型的操作更贴近直观的数学逻辑。</li></ul><ol start="3"><li><strong>编译器/链接器的处理过程</strong></li></ol><p>编译器（Compiler）</p><ul><li>编译器负责检查函数调用时的重载匹配，根据<strong>调用的参数类型和数量</strong>来决定使用哪个版本。</li><li>编译器会尝试寻找“最匹配”的函数（即符合参数列表的函数）。</li><li>如果有多个候选函数，编译器会根据如下规则选择最佳匹配：<ul><li>参数顺序：参数列表的类型和顺序是否完全匹配。</li><li><strong>更好匹配</strong>：如果存在隐式类型转换（如<code>int</code>到<code>double</code>），编译器会选择最少类型转换的函数。</li><li><strong>窄转换问题（窄转换）</strong>：如果需要类型转换（如浮点数转整数），可能会导致精度损失，因此尽量避免。</li></ul></li></ul><p>链接器（Linker）</p><ul><li>如果函数的重载匹配不唯一（存在歧义），会导致链接错误。</li></ul><img src="/2025/01/25/CPP-2-3/image-20241221103522031.png" class="" title="image-20241221103522031"><img src="/2025/01/25/CPP-2-3/image-20241221103618783.png" class="" title="image-20241221103618783"><ol><li><strong>背景：友元函数重载<code>+</code>操作符</strong></li></ol><p>在前一张PPT中，展示了通过<strong>成员函数</strong>重载操作符<code>+</code>的实现方式。但成员函数方式存在以下局限：</p><ul><li><strong>限制左操作数的类型</strong>：成员函数的重载要求左操作数必须是类的对象（或者能够隐式转换为类的对象）。</li><li><strong>灵活性不足</strong>：如果需要支持左操作数为其他类型（如内置类型），只能通过友元函数来实现。</li></ul><p>因此，这张PPT使用了<strong>友元函数</strong>重载<code>+</code>操作符。</p><ol start="2"><li><strong>代码讲解</strong></li></ol><p><strong>类定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line">    <span class="type">double</span> real, imag;  <span class="comment">// 实部和虚部</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>() &#123; real = <span class="number">0</span>; imag = <span class="number">0</span>; &#125;                       <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i) &#123; real = r; imag = i; &#125;    <span class="comment">// 带参数构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(Complex&amp; c1, Complex&amp; c2);    <span class="comment">// 声明友元函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><code>friend</code>关键字声明了一个友元函数<code>operator+</code>，该函数<strong>不属于类成员</strong>，但可以访问类的私有成员。</p></li><li><pre><code>operator+(Complex&amp; c1, Complex&amp; c2)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ：</span><br><span class="line"></span><br><span class="line">  - 接受两个`Complex`对象作为参数。</span><br><span class="line">  - 不依赖于类对象的上下文（不是成员函数）。</span><br><span class="line">  - 可以直接访问`c1`和`c2`的私有数据成员`real`和`imag`。</span><br><span class="line"></span><br><span class="line">**友元函数定义**</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">Complex operator+(Complex&amp; c1, Complex&amp; c2) &#123;</span><br><span class="line">    Complex temp;</span><br><span class="line">    temp.real = c1.real + c2.real;  // 实部相加</span><br><span class="line">    temp.imag = c1.imag + c2.imag;  // 虚部相加</span><br><span class="line">    return temp;  // 返回结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>在函数中，将两个<code>Complex</code>对象的实部和虚部分别相加，构造一个新的<code>Complex</code>对象并返回。</p></li><li><p>这是一个<strong>非成员函数</strong>，可以直接访问类的私有成员。</p></li></ul><p><strong>使用示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span>, c</span>;</span><br><span class="line">c = a + b;  <span class="comment">// 等价于 operator+(a, b)</span></span><br></pre></td></tr></table></figure><ul><li>当调用<code>a + b</code>时，编译器会自动调用友元函数<code>operator+</code>。</li><li>重载操作符的作用是让表达式更符合直观的数学表达方式。</li></ul><ol start="3"><li><strong>友元函数的优点</strong></li></ol><ul><li>灵活性更高：<ul><li>友元函数不需要左操作数是类的对象，这在某些场景下更加灵活。</li><li>例如，如果需要支持<code>Complex + double</code>这样的表达式，友元函数可以轻松扩展。</li></ul></li><li>访问权限：<ul><li>友元函数可以直接访问类的私有成员，避免了额外的访问函数开销。</li></ul></li><li>非对称操作符：<ul><li>对于需要非对称操作符（如<code>&lt;&lt;</code>和<code>&gt;&gt;</code>），友元函数是必不可少的实现方式。</li></ul></li></ul><ol start="4"><li><strong>与成员函数的对比</strong></li></ol><table><thead><tr><th><strong>特点</strong></th><th><strong>成员函数重载</strong></th><th><strong>友元函数重载</strong></th></tr></thead><tbody><tr><td><strong>左操作数类型</strong></td><td>必须是类的对象或其派生类</td><td>可以是任意类型</td></tr><tr><td><strong>是否依赖类对象</strong></td><td>是</td><td>否</td></tr><tr><td><strong>访问权限</strong></td><td>只能通过<code>this</code>访问本类成员</td><td>可以直接访问所有私有/保护成员</td></tr><tr><td><strong>适用场景</strong></td><td>左操作数是类对象的情况</td><td>左操作数不确定的情况</td></tr></tbody></table><img src="/2025/01/25/CPP-2-3/image-20241221104059763.png" class="" title="image-20241221104059763"><img src="/2025/01/25/CPP-2-3/image-20241221104156533.png" class="" title="image-20241221104156533"><p><strong>1. 基本原则</strong></p><p><strong>(1) 重载方式</strong></p><ul><li><strong>类成员函数</strong>：<ul><li>如果某个操作符是类的成员函数，则该操作符的左操作数必须是该类的对象。</li><li>例如，<code>operator+</code> 可以定义为类的成员函数。</li></ul></li><li><strong>带有类参数的全局函数</strong>：<ul><li>也可以将操作符重载定义为全局函数，但需要将操作数之一声明为该类的对象。</li><li>通常在需要对两类不同对象进行操作时使用全局函数。</li><li>例如，重载 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 操作符通常需要定义为全局函数。</li></ul></li></ul><p><strong>(2) 避免歧义性</strong></p><ul><li><strong>单目/双目运算符</strong>：<ul><li>一些操作符既可以用作单目操作符（如 <code>-a</code>），也可以用作双目操作符（如 <code>a - b</code>）。在重载时需要明确处理单目和双目运算。</li></ul></li><li><strong>优先级</strong>：<ul><li>操作符的优先级是由编译器定义的，无法通过重载改变。</li><li>例如，<code>*</code>（乘法）操作符的优先级高于<code>+</code>（加法）。</li></ul></li><li><strong>结合性</strong>：<ul><li>操作符的结合性（从左向右或从右向左）同样是固定的，无法通过重载改变。</li><li>例如，赋值操作符<code>=</code>的结合性是从右向左。</li></ul></li></ul><p><strong>2. 示例代码解释</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i) : <span class="built_in">x</span>(i) &#123;&#125;   <span class="comment">// 构造函数，初始化成员x</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; ... &#125;     <span class="comment">// 普通成员函数f</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; ... &#125;     <span class="comment">// 普通成员函数g</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>指向成员函数的指针</strong></p><ul><li>声明：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (A::*p_f)();</span><br></pre></td></tr></table></figure><ul><li>含义：<ul><li><code>p_f</code> 是一个指向 <code>A</code> 类的成员函数的指针，指向的是返回值为 <code>void</code> 且无参数的成员函数。</li></ul></li><li>使用：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p_f = &amp;A::f;    <span class="comment">// 将指针p_f指向A类的成员函数f</span></span><br><span class="line">(a.*p_f)();     <span class="comment">// 使用成员函数指针调用对象a的成员函数f</span></span><br></pre></td></tr></table></figure><ul><li>说明：<ul><li><code>.*</code> 是成员指针访问操作符，用于通过对象访问成员函数。</li><li>该操作符无法被重载，因此始终具有固定语法和行为。</li></ul></li></ul><h3 id="双目操作符重载">双目操作符重载</h3><img src="/2025/01/25/CPP-2-3/image-20241221105128911.png" class="" title="image-20241221105128911"><p><strong>1. 双目操作符重载</strong></p><ul><li>双目操作符：<ul><li>是需要两个操作数的操作符，例如 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>==</code> 等。</li><li>双目操作符通常是类的成员函数，用于实现类对象之间的操作逻辑。</li></ul></li></ul><p><strong>2. 格式</strong></p><p>重载双目操作符的成员函数格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">return</span> type&gt; <span class="keyword">operator</span>#(&lt;arg&gt;)</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>operator#</code></strong>：</p><ul><li><p>这里的 <code>#</code> 是占位符，表示具体的操作符，例如 <code>+</code>, <code>-</code>。</p></li><li><p>例如，重载加法操作符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+</span><br></pre></td></tr></table></figure><p>时，函数声明为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; other);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>&lt;arg&gt;</code></strong>：</p><ul><li>表示操作符<strong>右侧的操作数</strong>，作为函数的参数传入。</li><li><strong>左操作数是隐式的，表示当前对象</strong>（通过 <code>this</code> 指针访问）。</li></ul></li><li><p><strong><code>&lt;return type&gt;</code></strong>：</p><ul><li>操作符的返回值类型。</li><li>一般情况下，<strong>返回值是一个新的对象</strong>，表示<strong>操作符的运算结果</strong>。</li></ul></li></ul><p><strong>3. 隐式的 <code>this</code> 指针</strong></p><ul><li><p>在操作符重载的成员函数中，<strong>左操作数</strong>是隐式传递的，表示当前调用对象。</p></li><li><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Complex a, b;</span><br><span class="line">a + b;</span><br></pre></td></tr></table></figure><ul><li><p>等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="keyword">operator</span>+(b);</span><br></pre></td></tr></table></figure></li><li><p>在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.operator+(b)</span><br></pre></td></tr></table></figure><p>中：</p><ul><li><code>a</code> 是隐式的，通过 <code>this</code> 指针表示；</li><li><code>b</code> 是显式传递的参数。</li></ul></li></ul></li></ul><p><strong>4. 使用</strong></p><p>举例说明使用方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="title class_">name</span>&gt; a, b;</span><br><span class="line">a <span class="meta"># b;</span></span><br><span class="line">a.<span class="keyword">operator</span>#(b);</span><br></pre></td></tr></table></figure><p>示例：</p><p>以下是一个完整的操作符重载代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r = <span class="number">0</span>, <span class="type">double</span> i = <span class="number">0</span>) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载加法操作符（双目操作符）</span></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(real + other.real, imag + other.imag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; real &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; imag &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    Complex c = a + b;  <span class="comment">// 等价于 a.operator+(b);</span></span><br><span class="line">    c.<span class="built_in">display</span>();        <span class="comment">// 输出 (4, 6)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(4, 6)</span><br></pre></td></tr></table></figure><p><strong>5. 总结</strong></p><ul><li><p>双目操作符重载</p><p>可以通过类的成员函数实现，格式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ret type&gt; <span class="keyword">operator</span>#(&lt;arg&gt;);</span><br></pre></td></tr></table></figure></li><li><p><strong>左操作数通过 <code>this</code> 隐式传</strong>递，右操作数作为函数参数传递。</p></li><li><p>使用时，<code>a # b</code> 等价于 <code>a.operator#(b)</code>。</p></li><li><p>重载操作符可以使代码更简洁和易读，但需要遵循操作符的语义规范，避免滥用。</p></li></ul><img src="/2025/01/25/CPP-2-3/image-20241221105410774.png" class="" title="image-20241221105410774"><p><strong>1. 全局函数的操作符重载</strong></p><ul><li><p><strong>全局函数</strong>形式的操作符重载适用于以下场景：</p><ul><li>操作符的左侧不是类的对象。</li><li>操作符需要访问两个或更多参数，但不需要直接访问类的私有/保护成员。</li></ul></li><li><p><strong>友元函数（<code>friend</code>）</strong></p><ul><li><p>如果需要让全局函数访问类的私有或保护成员，则可以将该全局函数声明为类的友元。</p></li><li><p>格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> &lt;ret type&gt; <span class="keyword">operator</span># (&lt;arg1&gt;, &lt;arg2&gt;);</span><br></pre></td></tr></table></figure><ul><li><p>**<code>friend</code>**关键字使得全局函数可以访问类的内部成员。</p></li><li><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r = <span class="number">0</span>, <span class="type">double</span> i = <span class="number">0</span>) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; c1, <span class="type">const</span> Complex&amp; c2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; c1, <span class="type">const</span> Complex&amp; c2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(c<span class="number">1.</span>real + c<span class="number">2.</span>real, c<span class="number">1.</span>imag + c<span class="number">2.</span>imag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p><strong>2. 格式</strong></p><ul><li><p>全局函数形式的操作符重载函数格式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ret type&gt; <span class="keyword">operator</span># (&lt;arg1&gt;, &lt;arg2&gt;);</span><br></pre></td></tr></table></figure><ul><li><strong>返回值类型</strong>：表示操作符的结果。</li><li>参数列表：<ul><li>通常需要两个参数，分别表示操作符的两个操作数。</li></ul></li></ul></li></ul><p><strong>3. 为什么 <code>=</code>, <code>()</code>, <code>[]</code> 不能作为全局函数重载？</strong></p><p>这三种操作符具有特殊含义和行为，因此只能通过<strong>类的成员函数</strong>进行重载。</p><p><strong>赋值操作符 <code>=</code></strong></p><ul><li><p>原因：</p><ul><li>赋值操作符需要访问当前对象的所有成员以完成深拷贝、浅拷贝或其他自定义行为。</li><li>如果允许全局函数重载 <code>=</code>，就无法隐式访问左操作数（当前对象）的私有成员。</li></ul></li><li><p>解决方式：</p><ul><li><p>只能作为类的成员函数重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; other) &#123;</span><br><span class="line">        <span class="comment">// 实现赋值逻辑</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>函数调用操作符 <code>()</code></strong></p><ul><li><p>原因：</p><ul><li><code>()</code> 是用于模拟函数调用的操作符，必须与一个特定的类对象关联。</li><li>它通常用于创建可调用对象（如仿函数），需要访问类的成员。</li></ul></li><li><p>解决方式：</p><ul><li><p>只能作为类的成员函数重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Called with &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Callable obj;</span><br><span class="line"><span class="built_in">obj</span>(<span class="number">10</span>);  <span class="comment">// 调用 operator()</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>下标操作符 <code>[]</code></strong></p><ul><li><p>原因：</p><ul><li><code>[]</code> 用于访问容器或类似容器的类对象的元素。</li><li>需要访问类的内部数据（例如数组、指针等）。</li></ul></li><li><p>解决方式：</p><ul><li><p>只能作为类的成员函数重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line">    <span class="type">int</span> data[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Array arr;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">10</span>;  <span class="comment">// 调用 operator[]</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>4. 总结</strong></p><ul><li><p>某些操作符（如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=</span><br></pre></td></tr></table></figure><p>、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()</span><br></pre></td></tr></table></figure><p>、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]</span><br></pre></td></tr></table></figure><p>）只能作为</p><p>类的成员函数</p><p>重载，原因是：</p><ul><li>它们<strong>必须与一个特定的类对象绑定</strong>。</li><li>它们需要<strong>直接访问类的私有或保护成员</strong>。</li></ul></li><li><p><strong>全局函数形式的操作符重载</strong>适用于需要<strong>访问两个或多个对象</strong>的操作符（例如 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 等），且不需要直接访问类的内部成员时。</p></li></ul><p><strong>PPT中 “Why?” 的解答</strong></p><ul><li>赋值操作符 <code>=</code>、函数调用操作符 <code>()</code> 和下标操作符 <code>[]</code> 之所以不能作为全局函数重载，是因为它们需要<strong>直接与类对象绑定并访问其内部成员</strong>，因此设计上只允许作为类的成员函数重载。</li></ul><img src="/2025/01/25/CPP-2-3/image-20241221105729906.png" class="" title="image-20241221105729906"><p><strong>1. 重点问题</strong></p><p>在C++中，操作符重载通常作为类的<strong>成员函数</strong>实现，但某些情况下需要通过<strong>全局函数</strong>进行补充，尤其是在操作符的左侧操作数不是类对象的情况。例如：</p><ul><li><strong><code>obj + 10</code></strong>：可以通过类的成员函数 <code>operator+</code> 实现，因为左侧是类对象。</li><li><strong><code>10 + obj</code></strong>：需要通过全局函数 <code>operator+</code> 实现，因为左侧不是类对象，成员函数无法处理这种场景。</li></ul><p><strong>2. 代码讲解</strong></p><p><strong>类定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CL</span> &#123;</span><br><span class="line">    <span class="type">int</span> count;  <span class="comment">// 类的私有成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明友元函数</span></span><br><span class="line">    <span class="keyword">friend</span> CL <span class="keyword">operator</span>+(<span class="type">int</span> i, CL&amp; a);   <span class="comment">// 用于处理 &quot;10 + obj&quot; 的情况</span></span><br><span class="line">    <span class="keyword">friend</span> CL <span class="keyword">operator</span>+(CL&amp; a, <span class="type">int</span> i);  <span class="comment">// 用于处理 &quot;obj + 10&quot; 的情况</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><strong>成员变量 <code>count</code></strong>：<code>CL</code> 类包含一个私有成员变量 <code>count</code>，用于存储某些信息。</p></li><li><p>友元函数</p><p>：</p><ul><li><pre><code>friend CL operator+(int i, CL&amp; a)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ：</span><br><span class="line"></span><br><span class="line">  - 处理左操作数为整型 `int`，右操作数为 `CL` 类对象的情况（例如 `10 + obj`）。</span><br><span class="line">  - 必须声明为友元函数以访问类的私有成员。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  friend CL operator+(CL&amp; a, int i)</span><br></pre></td></tr></table></figure>：- 处理左操作数为 `CL` 类对象，右操作数为整型 `int` 的情况（例如 `obj + 10`）。- 同样需要访问私有成员，因此声明为友元函数。</code></pre></li></ul></li></ul><p><strong>友元函数实现</strong></p><p>假设类 <code>CL</code> 的成员变量 <code>count</code> 表示某种计数器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CL <span class="keyword">operator</span>+(<span class="type">int</span> i, CL&amp; a) &#123;</span><br><span class="line">    CL temp;               <span class="comment">// 创建一个新的 CL 对象</span></span><br><span class="line">    temp.count = i + a.count;  <span class="comment">// 将 int 和 CL 对象的 count 相加</span></span><br><span class="line">    <span class="keyword">return</span> temp;           <span class="comment">// 返回新对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CL <span class="keyword">operator</span>+(CL&amp; a, <span class="type">int</span> i) &#123;</span><br><span class="line">    CL temp;               <span class="comment">// 创建一个新的 CL 对象</span></span><br><span class="line">    temp.count = a.count + i;  <span class="comment">// 将 CL 对象的 count 和 int 相加</span></span><br><span class="line">    <span class="keyword">return</span> temp;           <span class="comment">// 返回新对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 实现原理</strong></p><ul><li>当<strong>操作符左侧是类对象时，C++ 会优先调用类的成员函数来进行操作符重</strong>载。</li><li>当<strong>左侧不是类对象（如 <code>10 + obj</code>），类的成员函数无法处理，因此需要全局函数作为补充</strong>。</li><li>为了让全局函数能够访问类的私有成员，通常将其声明为<strong>友元函数</strong>。</li></ul><p><strong>4. 示例解释</strong></p><p>以下是如何调用操作符重载的代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CL obj1, obj2;</span><br><span class="line">obj<span class="number">1.</span>count = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用成员函数实现的操作符重载</span></span><br><span class="line">obj2 = obj1 + <span class="number">10</span>;  <span class="comment">// 调用 friend CL operator+(CL&amp;, int)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用全局函数实现的操作符重载</span></span><br><span class="line">obj2 = <span class="number">10</span> + obj1;  <span class="comment">// 调用 friend CL operator+(int, CL&amp;)</span></span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><strong><code>obj1 + 10</code></strong>：<code>obj1</code> 是类对象，C++ 会优先调用 <code>CL</code> 类的成员函数 <code>operator+</code> 或对应的友元函数 <code>operator+(CL&amp;, int)</code>。</li><li><strong><code>10 + obj1</code></strong>：左操作数 <code>10</code> 不是类对象，C++ 无法调用成员函数，因此使用全局友元函数 <code>operator+(int, CL&amp;)</code>。</li></ul><p><strong>5. 结论</strong></p><ul><li><strong>成员函数重载</strong>适用于左操作数是类对象的情况。</li><li><strong>全局函数重载</strong>可以<strong>补充处理左操作数不是类对象的情况</strong>（如 <code>10 + obj</code>）。</li><li><strong>友元声明</strong>允许全局函数访问类的私有成员，从而实现完整的操作符重载。</li></ul><img src="/2025/01/25/CPP-2-3/image-20241221105953158.png" class="" title="image-20241221105953158"><p><strong>1. 核心问题</strong></p><p>逻辑操作符 <code>&amp;&amp;</code> 和 <code>||</code> 是<strong>短路操作符</strong>，在C++中具有特殊的行为：</p><ul><li><p>短路求值：</p><ul><li><p>对于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp;</span><br></pre></td></tr></table></figure><p>：</p><ul><li>如果第一个表达式为 <code>false</code>，则整个表达式结果必然为 <code>false</code>，不再计算第二个表达式。</li></ul></li><li><p>对于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">||</span><br></pre></td></tr></table></figure><p>：</p><ul><li>如果第一个表达式为 <code>true</code>，则整个表达式结果必然为 <code>true</code>，不再计算第二个表达式。</li></ul></li></ul></li></ul><p>重载 <code>&amp;&amp;</code> 和 <code>||</code> 会改变这种短路行为，从而导致与直觉不符的结果。</p><p><strong>2. PPT中的示例解释</strong></p><p>示例代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p;</span><br><span class="line"><span class="keyword">if</span> ((p != <span class="number">0</span>) &amp;&amp; (<span class="built_in">strlen</span>(p) &gt; <span class="number">10</span>)) ...</span><br></pre></td></tr></table></figure><ul><li><p>这里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp;</span><br></pre></td></tr></table></figure><p>是短路操作符：</p><ul><li>如果 <code>p != 0</code> 为 <code>false</code>，表达式立即为 <code>false</code>，不会调用 <code>strlen(p)</code>。</li><li>避免了潜在的运行时错误（如 <code>p</code> 为 <code>nullptr</code> 时调用 <code>strlen(p)</code> 会导致崩溃）。</li></ul></li></ul><p>重载后的行为</p><p>如果 <code>&amp;&amp;</code> 被重载，会变成以下形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression1 &amp;&amp; expression2) ...</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression<span class="number">1.</span><span class="keyword">operator</span>&amp;&amp;(expression2)) ...</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">operator</span>&amp;&amp;(expression1, expression2)) ...</span><br></pre></td></tr></table></figure><p><strong>问题：</strong></p><ul><li>重载后的逻辑操作符不会短路：<ul><li>即使 <code>expression1</code> 为 <code>false</code>，<code>expression2</code> 仍然会被计算。</li><li>这可能导致与短路语义不一致的行为，进而引发潜在的逻辑错误或性能问题。</li></ul></li></ul><p><strong>3. 为什么不能重载</strong></p><ol><li><strong>语义破坏</strong></li></ol><p><code>&amp;&amp;</code> 和 <code>||</code> 是语言级别的操作符，其<strong>短路特性是内置的</strong>。如果重载这些操作符：</p><ul><li>表达式的语义不再直观，可能导致程序员误解或未预料的行为。</li></ul><ol start="2"><li><strong>潜在错误</strong></li></ol><ul><li>如果操作数包含昂贵的计算或可能引发副作用（如函数调用），未短路的行为可能导致意外问题。</li></ul><ol start="3"><li><strong>语言限制</strong></li></ol><p>C++ 明确规定：</p><ul><li><strong>逻辑操作符 <code>&amp;&amp;</code> 和 <code>||</code> 无法完全通过重载模仿其内置行为，因此禁止重载这些操作符。</strong></li></ul><p><strong>4. 小结</strong></p><ul><li><code>&amp;&amp;</code> 和 <code>||</code> 不允许重载的原因：<ul><li>保持短路行为；</li><li>避免语义破坏；</li><li>防止性能和逻辑错误。</li></ul></li><li>C++ 的操作符重载机制允许我们重载大多数操作符，但对某些关键操作符（如 <code>&amp;&amp;</code>、<code>||</code>、<code>.</code>、<code>.*</code>、<code>::</code>、<code>sizeof</code>）进行了限制，以确保代码的可读性和一致性。</li></ul><img src="/2025/01/25/CPP-2-3/image-20241221110156566.png" class="" title="image-20241221110156566"><p><strong>1. 类定义的核心</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">int</span>, <span class="type">int</span>);  <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; r) <span class="type">const</span>;  <span class="comment">// 重载乘法操作符</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, d;  <span class="comment">// 分子和分母</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>数据成员：<ul><li><code>n</code>：分子。</li><li><code>d</code>：分母。</li></ul></li><li>重载的乘法操作符：<ul><li>函数声明中，返回值是<code>const Rational&amp;</code>，表示返回的结果是一个<code>Rational</code>类的引用，且这个引用是只读的（不可修改）。</li><li>参数是一个常量引用<code>const Rational&amp; r</code>，提高了传参效率，避免了值传递导致的拷贝。</li><li><code>const</code> 修饰函数，表明操作符不会修改当前对象的状态。</li></ul></li></ul><p><strong>2. 操作符<code>*</code>的多种实现方式</strong></p><p>PPT中列出了几种实现乘法操作符的方法，每种方式都对应不同的性能和安全性特点：</p><p><strong>实现方式 1：直接返回临时对象</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">Rational</span>(n * r.n, d * r.d);</span><br></pre></td></tr></table></figure><ul><li>优点：<ul><li>简单易懂，效率较高。</li><li>不涉及动态分配内存，临时对象会在栈上创建，作用域结束后自动销毁。</li></ul></li><li>缺点：<ul><li>返回的是一个临时对象的引用，而临时对象在函数调用结束后就会被销毁，导致悬空引用（Dangling Reference）。</li><li>如<code>const Rational&amp; operator*()</code>返回引用，调用者可能操作失效的内存。</li></ul></li></ul><p><strong>实现方式 2：动态分配内存</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rational *result = <span class="keyword">new</span> <span class="built_in">Rational</span>(n * r.n, d * r.d);</span><br><span class="line"><span class="keyword">return</span> *result;</span><br></pre></td></tr></table></figure><ul><li>优点：<ul><li>返回的是一个有效的对象，避免了悬空引用问题。</li></ul></li><li>缺点：<ul><li>内存泄漏风险：调用者需要显式删除返回的对象，如果忘记<code>delete</code>，会导致内存泄漏。</li><li>动态分配的性能开销较大，效率低于栈上分配。</li></ul></li></ul><p><strong>实现方式 3：返回静态对象</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Rational result;</span><br><span class="line">result.n = n * r.n;</span><br><span class="line">result.d = d * r.d;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><ul><li>优点：<ul><li>避免了动态内存分配，性能较高。</li></ul></li><li>缺点：<ul><li>使用静态对象可能导致线程不安全问题。</li><li>每次调用操作符时会覆盖静态对象的值，这意味着返回的结果在下一次调用时可能被修改，无法应用于复杂计算。</li></ul></li></ul><p><strong>3. PPT中的重要提示</strong></p><p><strong>绿色框的建议</strong></p><ul><li><p>提出一个重要的编程原则：</p><blockquote><p>尽可能让事情有效率，但不要过度有效率。</p></blockquote><ul><li>过度优化可能会带来复杂性和安全问题（如悬空引用、内存泄漏等）。</li><li>编写代码时，应优先保证代码的安全性和易维护性，在此基础上再考虑优化。</li></ul></li></ul><p><strong>复杂表达式的潜在问题</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w = x * y * z;</span><br></pre></td></tr></table></figure><ul><li>如果操作符<code>*</code>返回的是引用，会导致重复使用同一个对象（如静态对象）或操作失效的内存，结果不可靠。</li></ul><p><strong>4. 总结与建议</strong></p><p><strong>选择返回值的方式</strong></p><ol><li><p><strong>返回值推荐</strong>：</p><ul><li><p>操作符重载通常返回一个值（按值传递，而不是引用），例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; r) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>(n * r.n, d * r.d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>确保返回的对象在调用结束后仍然有效。</li><li>编译器会优化返回值拷贝（通过返回值优化 RVO 技术）。</li></ul></li><li><p>返回引用（如<code>const Rational&amp;</code>）仅适用于<strong>已有的成员对象</strong>，不适用于返回临时对象。</p></li></ul></li><li><p><strong>使用动态内存需谨慎</strong>：</p><ul><li>如果需要返回动态分配的对象，应明确调用者的职责（如<code>delete</code>操作）。</li><li>一般情况下，避免使用动态分配对象，除非有非常明确的需求。</li></ul></li></ol><p><strong>5. 操作符<code>*</code>的正确实现示例</strong></p><p>以下是推荐的实现方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">int</span> n, <span class="type">int</span> d) : <span class="built_in">n</span>(n), <span class="built_in">d</span>(d) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按值返回</span></span><br><span class="line">    Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; r) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Rational</span>(n * r.n, d * r.d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此实现避免了悬空引用、内存泄漏和线程安全问题，同时效率较高且易于理解。</p><h3 id="单目操作符重载">单目操作符重载</h3><img src="/2025/01/25/CPP-2-3/image-20241221111041350.png" class="" title="image-20241221111041350"><p><strong>1. 单目操作符的重载</strong></p><p>单目操作符</p><ul><li>单目操作符是只作用于一个操作数的操作符，例如：<code>+</code>（正号）、<code>-</code>（负号）、<code>*</code>（解引用）、<code>&amp;</code>（取地址）、<code>!</code>（逻辑非）、<code>~</code>（按位取反）、<code>++</code>（前置自增）、<code>--</code>（前置自减）等。</li></ul><p>重载的方式</p><p>单目操作符可以通过以下两种方式重载：</p><ol><li><strong>类成员函数</strong>形式</li><li><strong>全局函数</strong>形式</li></ol><p><strong>2. 类成员函数重载单目操作符</strong></p><p>特点</p><ul><li>成员函数形式的单目操作符重载<strong>隐含一个<code>this</code>指针</strong>，因为成员函数本质上总是作用于调用该操作符的对象。</li><li>重载的函数只需要一个参数，即操作符本身的对象实例。</li></ul><p>格式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ret_type&gt; <span class="keyword">operator</span>#();</span><br></pre></td></tr></table></figure><ul><li><strong><code>ret_type</code></strong>：操作符重载函数的返回值类型。可以是一个值、引用或指针，取决于操作符的实际需求。</li><li><strong><code>operator#</code></strong>：<code>#</code>是占位符，实际使用时需要替换成具体的操作符（如<code>+</code>、<code>-</code>等）。</li><li><strong>参数</strong>：对于单目操作符重载，成员函数<strong>不需要额外的参数</strong>，因为操作的对象是隐式的，即调用该函数的对象。</li></ul><p>示例代码</p><p>以下是单目操作符<code>-</code>（取负号）的重载示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Number</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载单目操作符-</span></span><br><span class="line">    Number <span class="keyword">operator</span>-() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(-value); <span class="comment">// 返回一个取反后的新对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>用法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Number <span class="title">n</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">Number m = -n;  <span class="comment">// 调用重载的operator-()</span></span><br><span class="line">std::cout &lt;&lt; m.<span class="built_in">getValue</span>(); <span class="comment">// 输出 -5</span></span><br></pre></td></tr></table></figure><p>总结</p><ul><li>类成员函数形式更适用于操作符直接作用于类的私有数据（如上述<code>value</code>）。</li><li>隐式使用<code>this</code>指针，语法简洁。</li></ul><p><strong>3. 全局函数重载单目操作符</strong></p><p>特点</p><ul><li>全局函数形式的重载操作符需要显式指定操作数。</li><li><strong>操作符作用的对象需要通过参数传递，而不是隐式的<code>this</code></strong>。</li></ul><p>格式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ret_type&gt; <span class="keyword">operator</span>#(&lt;arg&gt;);</span><br></pre></td></tr></table></figure><ul><li><strong><code>ret_type</code></strong>：操作符重载函数的返回值类型。</li><li><strong><code>#</code></strong>：占位符，表示实际的操作符。</li><li><strong><code>&lt;arg&gt;</code></strong>：单目操作符重载时需要一个参数，即操作的对象。</li></ul><p>示例代码</p><p>以下是重载取负号操作符的全局函数版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Number</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元函数</span></span><br><span class="line">    <span class="keyword">friend</span> Number <span class="keyword">operator</span>-(<span class="type">const</span> Number&amp; n);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义全局重载函数</span></span><br><span class="line">Number <span class="keyword">operator</span>-(<span class="type">const</span> Number&amp; n) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>(-n.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Number <span class="title">n</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">Number m = -n;  <span class="comment">// 调用全局重载的operator-()</span></span><br><span class="line">std::cout &lt;&lt; m.<span class="built_in">getValue</span>(); <span class="comment">// 输出 -5</span></span><br></pre></td></tr></table></figure><p><strong>4. 类成员函数与全局函数的选择</strong></p><p>类成员函数适合的情况</p><ul><li>操作符直接作用于类的成员数据（如<code>value</code>）。</li><li>不需要跨多个类使用操作符时。</li></ul><p>全局函数适合的情况</p><ul><li>操作符涉及多个类或非类类型（如<code>int</code>、<code>double</code>等）之间的运算。</li><li>需要访问类的私有或保护成员时，可以通过将全局函数声明为类的友元函数实现。</li></ul><p>比较</p><table><thead><tr><th>特点</th><th>类成员函数</th><th>全局函数</th></tr></thead><tbody><tr><td>调用对象</td><td>隐式调用，使用<code>this</code></td><td>显式调用，通过参数传递</td></tr><tr><td>参数数量</td><td>无额外参数</td><td>至少需要一个参数</td></tr><tr><td>使用复杂性</td><td>操作符仅与类数据关联时较简单</td><td>需要访问多个类或外部数据时较简单</td></tr></tbody></table><img src="/2025/01/25/CPP-2-3/image-20241221111332091.png" class="" title="image-20241221111332091"><p><strong>1. 前置自增（<code>++a</code>）</strong></p><p>特点：</p><ul><li><strong>操作符位置</strong>：写在变量前面，例如：<code>++a</code>。</li><li><strong>返回值</strong>：前置自增操作符返回变量自身的引用（左值引用），以便支持链式操作（如<code>+++a</code>）。</li><li><strong>行为</strong>：在执行操作时，变量的值会先增加，然后再返回增加后的变量。</li></ul><p>实现方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Counter&amp; <span class="keyword">operator</span>++() <span class="comment">// 前置自增</span></span><br><span class="line">&#123;</span><br><span class="line">    value++;          <span class="comment">// 增加成员变量的值</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;     <span class="comment">// 返回当前对象自身的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Counter a;</span><br><span class="line">++a; <span class="comment">// 调用前置自增</span></span><br></pre></td></tr></table></figure><p>适用场景：</p><ul><li>当需要链式调用时，例如<code>+++a</code>。</li><li>需要高效操作，因为不需要生成额外的临时对象。</li></ul><p><strong>2. 后置自增（<code>a++</code>）</strong></p><p>特点：</p><ul><li><strong>操作符位置</strong>：写在变量后面，例如：<code>a++</code>。</li><li><strong>返回值</strong>：后置自增操作符返回变量的值（未增加前）的副本。</li><li><strong>行为</strong>：在执行操作时，变量的值会先被保存到一个临时对象中，然后变量本身的值增加，最后返回临时对象。</li></ul><p>实现方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Counter <span class="keyword">operator</span>++(<span class="type">int</span>) <span class="comment">// 后置自增</span></span><br><span class="line">&#123;</span><br><span class="line">    Counter temp = *<span class="keyword">this</span>; <span class="comment">// 保存当前对象</span></span><br><span class="line">    value++;              <span class="comment">// 增加成员变量的值</span></span><br><span class="line">    <span class="keyword">return</span> temp;          <span class="comment">// 返回原始值的副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：这里的<code>int</code>参数是一个哑参数（dummy argument），并没有实际意义，它只是用来区分前置和后置版本。</p></blockquote><p>使用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Counter a;</span><br><span class="line">a++; <span class="comment">// 调用后置自增</span></span><br></pre></td></tr></table></figure><p>适用场景：</p><ul><li>当需要保存变量增加前的状态，例如在循环中记录或处理操作前的值。</li></ul><p><strong>3. 前置自增与后置自增的区别</strong></p><table><thead><tr><th>特性</th><th>前置自增（<code>++a</code>）</th><th>后置自增（<code>a++</code>）</th></tr></thead><tbody><tr><td><strong>返回值</strong></td><td>返回增加后的变量（引用）。</td><td>返回增加前的变量（副本）。</td></tr><tr><td><strong>效率</strong></td><td>更高效，不需要创建临时对象。</td><td>较低效，需要创建并返回一个临时对象。</td></tr><tr><td><strong>用途</strong></td><td>用于高效操作，适合链式调用（如<code>+++a</code>）。</td><td>用于需要操作前值的场景。</td></tr><tr><td><strong>实现</strong></td><td>没有额外参数，只是操作当前对象。</td><td>带有一个哑参数<code>int</code>用于区分后置操作。</td></tr></tbody></table><p><strong>4. 代码解析</strong></p><p>定义的类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Counter</span>() &#123; value = <span class="number">0</span>; &#125; <span class="comment">// 默认构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置自增操作符</span></span><br><span class="line">    Counter&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        value++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回自身引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置自增操作符</span></span><br><span class="line">    Counter <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">        Counter temp = *<span class="keyword">this</span>; <span class="comment">// 保存当前对象到临时变量</span></span><br><span class="line">        value++;              <span class="comment">// 增加当前对象的值</span></span><br><span class="line">        <span class="keyword">return</span> temp;          <span class="comment">// 返回保存的临时变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>5. 总结</strong></p><ul><li>**前置自增（<code>++a</code>）**效率高，适合需要链式操作的场景，因为它直接返回对象自身，不生成临时副本。</li><li>**后置自增（<code>a++</code>）**适合需要操作之前值的场景，但因为需要生成一个副本对象，效率较低。</li><li>哑参数<code>int</code>是<strong>后置版本的标志</strong>，前置版本则没有参数。</li></ul><h3 id="特殊操作符重载">特殊操作符重载</h3><img src="/2025/01/25/CPP-2-3/image-20241221111609105.png" class="" title="image-20241221111609105"><p><strong>1. 默认赋值操作符重载函数</strong></p><p>C++中的赋值操作符<code>=</code>在没有明确重载时，编译器会自动为类生成一个<strong>默认赋值操作符</strong>。该默认操作符具有以下特点：</p><p><strong>1.1 默认行为</strong></p><ul><li>成员赋值（member-wise assignment）：<ul><li>对于类的每个非静态成员，默认赋值操作符会调用它们的赋值操作符。</li><li>如果成员是基础类型（如<code>int</code>、<code>float</code>等），直接按值赋值。</li><li>如果成员是对象，则递归调用该对象的赋值操作符。</li></ul></li></ul><p><strong>1.2 递归调用</strong></p><ul><li>如果类中包含成员对象，则默认赋值操作符会递归调用成员对象的赋值操作符，直至完成所有成员的赋值。这种递归行为保证了成员对象之间的赋值是正确且完整的。</li></ul><p><strong>2. 为什么赋值操作符重载不能继承？</strong></p><p>PPT中的问题是：<strong>为什么赋值操作符重载不能继承？</strong></p><p><strong>原因分析</strong></p><ol><li><strong>赋值操作符是类特定的：</strong><ul><li>赋值操作符的实现高度依赖于类的成员变量的类型和数量。</li><li>派生类的成员变量和基类可能完全不同，因此基类的赋值操作符对于派生类来说通常不适用。</li></ul></li><li><strong>派生类需要自定义赋值逻辑：</strong><ul><li>派生类可能有额外的成员变量，或者需要特定的赋值逻辑。</li><li>如果派生类直接使用基类的赋值操作符，会导致派生类特定的成员变量无法正确赋值。</li></ul></li><li><strong>覆盖的语义问题：</strong><ul><li>如果基类提供了一个赋值操作符，而派生类没有定义自己的赋值操作符，那么<strong>派生类会自动生成一个默认的赋值操作符，而不是继承基类的赋值操作符</strong>。</li><li>这避免了错误的赋值行为（如只处理基类部分的成员）。</li></ul></li><li><strong>遵循C++的默认规则：</strong><ul><li>C++中，<strong>特殊成员函数</strong>（包括<strong>拷贝构造函数、移动构造函数、析构函数和赋值操作符等）默认是为每个类单独生成的，不会被继承</strong>。</li><li>这是为了让每个类都有一组与自身成员匹配的特殊成员函数，而不是直接复用基类的实现。</li></ul></li></ol><p><strong>总结</strong></p><p>赋值操作符重载不能继承的核心原因在于：</p><ul><li><strong>派生类通常有不同的成员变量和赋值逻辑</strong>。</li><li><strong>为保证正确性和语义一致性，C++默认为每个类单独生成赋值操作符，而不是继承基类的实现</strong>。</li></ul><p><strong>3. 自定义赋值操作符重载</strong></p><p>当默认赋值操作符无法满足需求时，可以手动重载赋值操作符：</p><p><strong>实现方式</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 防止自赋值</span></span><br><span class="line">        x = other.x; <span class="comment">// 按成员赋值</span></span><br><span class="line">        y = other.y;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回当前对象的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ol><li><strong>防止自赋值（Self-assignment）</strong>：<ul><li>当<code>this == &amp;other</code>时，直接返回<code>*this</code>，防止不必要的操作。</li></ul></li><li><strong>返回当前对象的引用</strong>：<ul><li>返回<code>*this</code>可以支持链式操作，例如：<code>a = b = c;</code></li></ul></li></ol><p><strong>4. 总结</strong></p><ul><li>默认赋值操作符：<ul><li>是编译器生成的特殊成员函数，支持递归调用成员变量的赋值操作符。</li></ul></li><li>不能继承赋值操作符：<ul><li>基于类成员的不同需求，<strong>派生类需要单独定义自己的赋值操作符</strong>。</li></ul></li><li>重载赋值操作符：<ul><li>必要时，可以手动实现赋值操作符重载，以满足特殊需求，并保证安全性（防止自赋值）。</li></ul></li></ul><img src="/2025/01/25/CPP-2-3/image-20241221112239567.png" class="" title="image-20241221112239567"><p>这张PPT讲解了赋值操作符（<code>=</code>）重载中的一个经典问题：<strong>浅拷贝与深拷贝的内存管理问题</strong>。</p><p><strong>代码含义解析</strong></p><p>类定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">char</span> *p; <span class="comment">// 动态分配的字符串指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span> *s):<span class="built_in">x</span>(i), <span class="built_in">y</span>(j) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s) + <span class="number">1</span>]; <span class="comment">// 动态分配内存存储字符串</span></span><br><span class="line">        <span class="built_in">strcpy</span>(p, s);               <span class="comment">// 拷贝字符串内容到动态内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] p;                 <span class="comment">// 析构时释放动态内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    A&amp; <span class="keyword">operator</span> = (A&amp; a) &#123;</span><br><span class="line">        x = a.x;                    <span class="comment">// 直接拷贝基本类型</span></span><br><span class="line">        y = a.y;</span><br><span class="line">        <span class="keyword">delete</span>[] p;                 <span class="comment">// 释放当前对象已有的动态内存，防止内存泄漏</span></span><br><span class="line">        p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(a.p) + <span class="number">1</span>]; <span class="comment">// 为新值重新分配动态内存</span></span><br><span class="line">        <span class="built_in">strcpy</span>(p, a.p);             <span class="comment">// 拷贝新字符串</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;               <span class="comment">// 返回当前对象，支持链式赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>赋值操作逻辑</strong></p><ol><li><strong>基本类型的拷贝：</strong><ul><li>成员变量<code>x</code>和<code>y</code>直接赋值，因为它们是基本类型，不涉及动态内存管理。</li></ul></li><li><strong>动态内存管理：</strong><ul><li>赋值前，通过<code>delete[] p;</code>释放当前对象已有的动态内存，防止内存泄漏。</li><li>为被赋值的对象的动态字符串重新分配内存：<code>new char[strlen(a.p) + 1]</code>。</li><li>将赋值对象的字符串内容拷贝到新分配的内存中：<code>strcpy(p, a.p);</code>。</li></ul></li><li><strong>返回值：</strong><ul><li>返回<code>*this</code>，以支持链式赋值（如<code>a = b = c</code>）。</li></ul></li></ol><p><strong>构造函数和析构函数</strong></p><ul><li>构造函数为动态字符串分配内存。</li><li>析构函数在对象销毁时释放内存，避免内存泄漏。</li></ul><p><strong>PPT中的问题分析</strong></p><p><strong>问题1：idle pointer（悬空指针）</strong></p><ul><li>当<strong>没有重载赋值操作符时，编译器提供的默认赋值操作符会对指针成员<code>p</code>进行浅拷贝</strong>。</li><li>浅拷贝导致两个对象<code>a</code>和<code>b</code>的<code>p</code>指向同一片内存。</li><li>若一个对象析构时释放了这片内存，另一个对象的<code>p</code>变成悬空指针（指向已释放的内存）。</li></ul><p><strong>问题2：Memory leak（内存泄漏）</strong></p><ul><li>在赋值操作中，若没有释放当前对象已有的动态内存（即缺少<code>delete[] p</code>），就会导致内存泄漏。</li><li>每次重新分配内存时，旧的内存都丢失，无法释放。</li></ul><p><strong>赋值操作符重载的必要性</strong></p><ul><li>动态内存管理是重载赋值操作符的核心原因。若使用默认的赋值操作符（浅拷贝），将引发严重的内存问题：<ol><li><strong>悬空指针问题</strong></li><li><strong>内存泄漏问题</strong></li></ol></li></ul><p>通过重载赋值操作符，可以实现<strong>深拷贝</strong>，从而正确管理动态内存，避免上述问题。</p><p><strong>代码的改进点</strong></p><ol><li>防止自赋值</li></ol><p>当前代码没有处理<strong>自赋值问题</strong>（如<code>a = a</code>），这可能导致释放<code>p</code>后再访问已经释放的内存。</p><p>改进代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;a) &#123; <span class="comment">// 检查是否为自赋值</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = a.x;</span><br><span class="line">    y = a.y;</span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(a.p) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(p, a.p);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>拷贝构造函数</li></ol><p>除了赋值操作符，动态内存管理的类通常需要提供<strong>拷贝构造函数</strong>，以便正确初始化对象的动态成员。</p><p>实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">A</span>(<span class="type">const</span> A&amp; a) &#123;</span><br><span class="line">    x = a.x;</span><br><span class="line">    y = a.y;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(a.p) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(p, a.p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ol><li><strong>赋值操作符重载的必要性：</strong><ul><li>默认赋值操作符会导致悬空指针和内存泄漏问题。</li><li>通过重载赋值操作符，可以实现深拷贝，正确管理动态内存。</li></ul></li><li><strong>关键注意点：</strong><ul><li>释放当前内存（<code>delete[] p;</code>）防止内存泄漏。</li><li>防止自赋值（<code>if (this == &amp;a)</code>）。</li><li>返回<code>*this</code>以支持链式赋值。</li></ul></li><li><strong>最佳实践：</strong><ul><li>为动态内存管理的类提供<strong>拷贝构造函数</strong>、<strong>赋值操作符重载</strong>和<strong>析构函数</strong>，以遵循<strong>三法则（Rule of Three）</strong>。</li></ul></li></ol><img src="/2025/01/25/CPP-2-3/image-20241221113507128.png" class="" title="image-20241221113507128"><p><strong>避免自我赋值</strong></p><p>在重载赋值操作符时，如果不检查是否为自我赋值，可能会导致逻辑错误或程序崩溃。以下是常见问题及其影响：</p><ol><li><p><strong>自我赋值的定义</strong>：</p><ul><li>赋值操作的左值和右值是同一个对象，例如 <code>s = s;</code>。</li></ul></li><li><p><strong>问题举例</strong>：</p><ul><li>假设赋值操作符先释放当前对象的资源（如释放内存），然后将右值的资源拷贝到左值。如果是自我赋值，资源一旦被释放，后续操作将试图访问已释放的资源，导致未定义行为。</li></ul></li><li><p><strong>解决方案</strong>： 在赋值操作符中添加自我赋值检测，典型实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;a) &#123;  <span class="comment">// 检查是否为自我赋值</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行赋值操作</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>示例：<code>class string</code></strong>：</p><ul><li><code>class string</code> 是一个典型示例。如果字符串的内存管理未正确处理自我赋值，可能会导致释放原有数据后丢失当前数据。</li></ul></li></ol><p><strong>对象标识（Object Identity）</strong></p><p>对象标识用于区别两个对象是否为同一个实例，而不仅仅是内容相等。对象标识可以从以下几个维度理解：</p><ol><li><p><strong>Content（内容）</strong>：</p><ul><li>比较对象的实际数据。例如，对于两个字符串对象，比较它们的内容是否相等。</li></ul></li><li><p><strong>Same Memory Location（内存地址）</strong>：</p><ul><li>比较两个对象是否占用同一片内存，通常通过指针地址来判断。如果两个对象的内存地址相同，说明它们是同一个实例。</li></ul></li><li><p><strong>Object Identifier（对象标识符）</strong>：</p><ul><li><p><code>identity()</code> 是一个示例方法，返回对象的唯一标识符，可以是内存地址，也可以是其他唯一标识。</p></li><li><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A *p1, *p2;</span><br><span class="line"><span class="keyword">if</span> (p1-&gt;<span class="built_in">identity</span>() == p2-&gt;<span class="built_in">identity</span>()) &#123;</span><br><span class="line">    <span class="comment">// p1 和 p2 指向同一个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>关键代码解析</strong></p><p><strong>代码示例 1：避免自我赋值</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(A &amp;a1, A &amp;a2)</span> </span>&#123;</span><br><span class="line">    a1 = a2; <span class="comment">// 赋值不同对象，正常执行</span></span><br><span class="line">    a1 = a1; <span class="comment">// 赋值给自己，可能会出错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>解决方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;a) &#123; <span class="comment">// 检查是否是自我赋值</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他赋值逻辑</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>代码示例 2：对象标识</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ObjectID <span class="title">identity</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ...; <span class="comment">// 返回对象的唯一标识符，例如内存地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">A *p1, *p2;</span><br><span class="line"><span class="keyword">if</span> (p1-&gt;<span class="built_in">identity</span>() == p2-&gt;<span class="built_in">identity</span>()) &#123;</span><br><span class="line">    <span class="comment">// p1 和 p2 指向同一对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>identity()</code> 的返回值通常是内存地址，使用 <code>this</code> 指针实现。</li></ul><p><strong>总结</strong></p><ol><li><strong>自我赋值检查的重要性：</strong><ul><li>防止赋值操作中出现逻辑错误或未定义行为，尤其是涉及资源释放和重新分配的情况。</li></ul></li><li><strong>对象标识（Object Identity）的作用：</strong><ul><li>区分对象实例是否为同一对象，通常通过内存地址或唯一标识符实现。</li></ul></li><li><strong>最佳实践：</strong><ul><li>在赋值操作符中始终添加自我赋值检测。</li><li>为动态资源管理类实现 <code>identity()</code> 方法，以便识别和比较对象实例。</li></ul></li></ol><img src="/2025/01/25/CPP-2-3/image-20241221114135827.png" class="" title="image-20241221114135827"><p><strong>代码解析</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p; <span class="comment">// 动态分配的字符串数据存储</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数：动态分配存储空间，并复制字符串数据</span></span><br><span class="line">    <span class="built_in">string</span>(<span class="type">char</span> *p1) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(p1) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(p, p1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 [] 操作符，适用于非常量对象，返回引用（可修改）</span></span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 [] 操作符，适用于常量对象，返回值（不可修改）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数：释放动态分配的内存</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">string</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>关键点解析</strong></p><ol><li><p><strong>为什么需要两个版本的 <code>[]</code> 操作符</strong>：</p><ul><li><p><strong>非常量版本（非 <code>const</code>）</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span>;</span><br></pre></td></tr></table></figure><ul><li>返回一个引用，允许通过下标修改字符串内容。</li><li>适用于非常量对象（如 <code>string s(&quot;aacd&quot;);</code>）。</li><li>使用方式：<code>s[2] = 'b';</code>。</li></ul></li><li><p><strong>常量版本（<code>const</code>）</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span>;</span><br></pre></td></tr></table></figure><ul><li>返回一个值，禁止修改。</li><li>适用于常量对象（如 <code>const string cs(&quot;const&quot;);</code>）。</li><li>使用方式：<code>cout &lt;&lt; cs[0];</code>。</li></ul></li><li><p>通过 <code>const</code> 区分两种场景，编译器会根据上下文选择正确的重载版本。</p></li></ul></li><li><p><strong>动态内存管理</strong>：</p><ul><li>构造函数中为字符串动态分配内存。</li><li>析构函数中释放动态分配的内存，防止内存泄漏。</li></ul></li></ol><p><strong>测试用例解析</strong></p><p><strong>测试 1：非常量对象</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;aacd&quot;</span>)</span></span>;</span><br><span class="line">s[<span class="number">2</span>] = <span class="string">&#x27;b&#x27;</span>; <span class="comment">// 调用非常量版本的 operator[]</span></span><br></pre></td></tr></table></figure><ul><li>执行过程：<ul><li>调用非常量版本的 <code>operator[]</code>，返回对 <code>p[2]</code> 的引用。</li><li>修改 <code>p[2]</code> 为 <code>'b'</code>。</li></ul></li><li>结果：<ul><li><code>s</code> 的内容变为 <code>&quot;aabd&quot;</code>。</li></ul></li></ul><p><strong>测试 2：常量对象</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> string <span class="title">cs</span><span class="params">(<span class="string">&quot;const&quot;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; cs[<span class="number">0</span>];  <span class="comment">// 调用常量版本的 operator[]</span></span><br><span class="line">cs[<span class="number">0</span>] = <span class="string">&#x27;D&#x27;</span>;    <span class="comment">// 不允许，编译报错</span></span><br></pre></td></tr></table></figure><ul><li>执行过程：<ul><li><code>cout &lt;&lt; cs[0];</code> 调用常量版本的 <code>operator[]</code>，返回 <code>p[0]</code> 的值（<code>'c'</code>）。</li><li><code>cs[0] = 'D';</code> 不允许修改，因为 <code>cs</code> 是常量对象，只能调用常量版本的 <code>operator[]</code>，而常量版本返回值不是引用，无法修改。</li></ul></li><li>结果：<ul><li>输出为 <code>'c'</code>。</li><li><code>cs[0] = 'D';</code> 编译错误。</li></ul></li></ul><p><strong>注意事项</strong></p><ol><li><strong>重载时的<code>const</code>区分</strong>：<ul><li>对于类的重载函数，<code>const</code> 修饰符用于区分常量对象和非常量对象的行为。</li><li>如果没有常量版本的重载，常量对象调用 <code>operator[]</code> 会报错。</li></ul></li><li><strong>安全性</strong>：<ul><li>使用 <code>[]</code> 操作符访问字符串时，没有越界检查，可能导致未定义行为。</li><li>在实际开发中，可以添加越界检查逻辑。</li></ul></li></ol><p><strong>总结</strong></p><ol><li><strong>双版本 <code>[]</code> 操作符</strong>：<ul><li>非常量对象使用的版本返回引用，可修改。</li><li>常量对象使用的版本返回值，不可修改。</li></ul></li></ol><img src="/2025/01/25/CPP-2-3/image-20241221114501328.png" class="" title="image-20241221114501328"><p>这张PPT讨论了C++中通过操作符重载实现二维数组的模拟，主要内容涉及如何通过<code>operator[]</code>重载实现对二维数组的访问语法</p><p><strong>代码解析</strong></p><p><strong>class Array2D</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array2D</span> &#123;</span><br><span class="line">    <span class="type">int</span> n1, n2; <span class="comment">// 分别代表二维数组的行数和列数</span></span><br><span class="line">    <span class="type">int</span> *p;     <span class="comment">// 一维指针，用于存储二维数组的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Array2D</span>(<span class="type">int</span> l, <span class="type">int</span> c) : <span class="built_in">n1</span>(l), <span class="built_in">n2</span>(c) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="type">int</span>[n1 * n2]; <span class="comment">// 分配一维数组空间，用于存储 n1 行 n2 列的二维数组</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Array2D</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] p; <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现二维数组访问的第一层：返回指向第 i 行的指针</span></span><br><span class="line">    <span class="type">int</span> *<span class="keyword">operator</span>[](<span class="type">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">return</span> p + i * n2; <span class="comment">// 第 i 行的起始地址</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过方法实现数据访问</span></span><br><span class="line">    <span class="function"><span class="type">int</span> &amp;<span class="title">getElem</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p[i * n2 + j]; <span class="comment">// 返回二维数组中第 i 行第 j 列的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>如何使用？</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Array2D <span class="title">data</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>; <span class="comment">// 创建 2 行 3 列的二维数组</span></span><br><span class="line">data[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">0</span>;     <span class="comment">// 使用重载的 [] 访问二维数组第 1 行第 2 列</span></span><br><span class="line">data.<span class="built_in">getElem</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 通过 getElem 方法实现相同访问</span></span><br></pre></td></tr></table></figure><ul><li>访问过程：<ul><li><code>data[1]</code> 调用 <code>Array2D</code> 中重载的 <code>operator[]</code>，返回指向第 1 行首元素的指针。</li><li><code>data[1][2]</code> 解引用得到第 1 行第 2 列的元素。</li></ul></li></ul><p><strong>PPT中关键点解析</strong></p><ol><li><p><strong>动态分配的内存结构</strong>：</p><ul><li>通过 <code>new int[n1 * n2]</code> 分配了连续的一维数组。</li><li>数组的布局是按行存储的，<code>p[i * n2 + j]</code> 表示第 i 行第 j 列的元素。</li></ul></li><li><p><strong>操作符重载的语义</strong>：</p><ul><li><strong>第一层 <code>operator[]</code></strong>： 返回指向第 <code>i</code> 行首元素的指针：<code>p + i * n2</code>。</li><li><strong>第二层 <code>operator[]</code>（隐含）</strong>： 对一维指针的下标操作，返回对应列的元素。</li></ul></li><li><p><strong>数据存储方式</strong>：</p><ul><li><p>数据在内存中是线性存储的，二维数组通过索引计算找到对应的元素地址。</p></li><li><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="number">1</span>][<span class="number">2</span>] =&gt; *(p + <span class="number">1</span> * n2 + <span class="number">2</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>期望语法</strong>：</p><ul><li><code>data[1][2]</code> 是类似二维数组的访问方式。</li><li>实际等价于：<code>data.operator .operator </code>。</li></ul></li><li><p><strong>对比 <code>getElem</code> 方法</strong>：</p><ul><li><code>getElem(i, j)</code> 和 <code>data[i][j]</code> 实现了相同的功能。</li><li>使用重载的 <code>operator[]</code> 提供了更直观的数组访问方式。</li></ul></li></ol><p><strong>补充内容：实现多维数组的思路</strong></p><p>如果需要模拟更高维的数组（例如三维数组），可以扩展 <code>operator[]</code>，例如：</p><ul><li>将 <code>operator[]</code> 返回自定义类型（如二维数组的行）。</li><li>为返回的类型再实现 <code>operator[]</code>。</li></ul><p><strong>PPT中图解说明</strong></p><ol><li><p><strong>对象内存布局</strong>：</p><ul><li><code>p</code> 是一维指针，指向实际数据存储区域。</li><li>数据存储顺序按行展开，连续存储。</li></ul></li><li><p><strong>重载 <code>[]</code> 的访问逻辑</strong>：</p><ul><li><p><code>data[1]</code> 返回第 1 行的起始地址。</p></li><li><pre><code>data[1][2]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      实现为：</span><br><span class="line"></span><br><span class="line">     - `data.operator ` 返回 `p + i * n2`。</span><br><span class="line">     - `p[i * n2 + j]` 是对应的二维数组元素。</span><br><span class="line"></span><br><span class="line">3. **通过重载实现类似多维数组的语法**：</span><br><span class="line"></span><br><span class="line">   - `data[i][j]` 提供了更加直观和简洁的使用方式，隐藏了数组存储的实现细节。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20241221114836998](CPP-2-3/image-20241221114836998.png)</span><br><span class="line"></span><br><span class="line">**背景与目的**</span><br><span class="line"></span><br><span class="line">- **目标**：实现对二维数组的仿真，通过重载`operator[]`，实现类似原生二维数组的访问方式。</span><br><span class="line">- **问题**：直接重载`operator[]`只能返回一维数组的首地址，不能实现链式调用（`data[i][j]`）。</span><br><span class="line">- **解决方法**：使用代理类（proxy class），间接处理多维数组的访问。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">**代码解析**</span><br><span class="line"></span><br><span class="line">**代理类：`Array1D`**</span><br><span class="line"></span><br><span class="line">`Array1D`是一个代理类，专门为`Array2D`提供一维数组的接口：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">class Array1D &#123;</span><br><span class="line">public:</span><br><span class="line">    // 构造函数：接受一个指向一维数组首地址的指针</span><br><span class="line">    Array1D(int *p) &#123; this-&gt;p = p; &#125;</span><br><span class="line"></span><br><span class="line">    // 重载 operator[]，实现一维数组访问</span><br><span class="line">    int &amp;operator[](int index) &#123; return p[index]; &#125;         // 可修改元素</span><br><span class="line">    const int operator[](int index) const &#123; return p[index]; &#125; // 只读元素</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int *p; // 指向一维数组的起始地址</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ol><p><strong>关键点</strong>：</p><ul><li>核心功能：<ul><li><code>Array1D</code>接受一个指向数组的指针<code>p</code>。</li><li>通过重载<code>operator[]</code>，实现对一维数组中任意位置的访问。</li></ul></li><li>访问逻辑：<ul><li>例如：<code>data[1]</code>返回的是一个<code>Array1D</code>对象。</li><li><code>data[1][2]</code>先调用<code>Array2D</code>的<code>operator[]</code>返回<code>Array1D</code>，然后调用<code>Array1D</code>的<code>operator[]</code>返回元素。</li></ul></li></ul><p><strong>二维数组类：<code>Array2D</code></strong></p><p><code>Array2D</code>实现了二维数组的存储和操作逻辑：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array2D</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数：分配内存</span></span><br><span class="line">    <span class="built_in">Array2D</span>(<span class="type">int</span> n1, <span class="type">int</span> n2) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="type">int</span>[n1 * n2]; <span class="comment">// 一维存储</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;num1 = n1;      <span class="comment">// 行数</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;num2 = n2;      <span class="comment">// 列数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数：释放内存</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Array2D</span>() &#123; <span class="keyword">delete</span>[] p; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 operator[]：返回代理类 Array1D</span></span><br><span class="line">    Array1D <span class="keyword">operator</span>[](<span class="type">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array1D</span>(p + index * num2); <span class="comment">// 第 index 行的首地址</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常量版本的 operator[]，用于只读</span></span><br><span class="line">    <span class="type">const</span> Array1D <span class="keyword">operator</span>[](<span class="type">int</span> index) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array1D</span>(p + index * num2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *p;     <span class="comment">// 一维指针，存储二维数组的数据</span></span><br><span class="line">    <span class="type">int</span> num1;   <span class="comment">// 行数</span></span><br><span class="line">    <span class="type">int</span> num2;   <span class="comment">// 列数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>关键点</strong>：</p><ol><li><p><strong>存储结构</strong>：</p><ul><li>数据存储在一维数组<code>p</code>中，按行优先顺序存储。</li><li>第<code>i</code>行的首地址是<code>p + i * num2</code>。</li></ul></li><li><p><strong>访问逻辑</strong>：</p><ul><li><p><code>data[i]</code>返回一个<code>Array1D</code>对象，代表第<code>i</code>行。</p></li><li><pre><code>data[i][j]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     通过链式调用：</span><br><span class="line"></span><br><span class="line">     - `data[i]`调用`Array2D::operator[]`。</span><br><span class="line">     - `[j]`调用`Array1D::operator[]`。</span><br><span class="line"></span><br><span class="line">3. **内存管理**：</span><br><span class="line"></span><br><span class="line">   - 使用`new`动态分配内存，析构函数中使用`delete[]`释放。</span><br><span class="line"></span><br><span class="line">**调用示例**</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">Array2D data(2, 3);   // 创建 2x3 的二维数组</span><br><span class="line">data[0][0] = 1;       // 通过代理类设置第 0 行第 0 列元素</span><br><span class="line">data[1][2] = 5;       // 设置第 1 行第 2 列元素</span><br><span class="line">int x = data[1][2];   // 获取第 1 行第 2 列元素</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p><strong>调用过程</strong>：</p><ul><li><code>data[1]</code>调用<code>Array2D::operator[]</code>，返回第 1 行的代理类<code>Array1D</code>。</li><li><code>data[1][2]</code>调用<code>Array1D::operator[]</code>，访问第 1 行第 2 列的元素。</li></ul></li><li><p><strong>内存布局</strong>：</p><ul><li><p>数据在内存中是连续存储的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p[0], p[1], p[2], ..., p[n1*n2-1]</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>PPT中的关键术语</strong></p><ol><li><strong><code>proxy class</code>（代理类）</strong>：<ul><li><code>Array1D</code>作为代理类，为每一行提供访问接口。</li><li>将二维数组的复杂逻辑拆分为简单的一维数组操作。</li></ul></li><li><strong><code>Surrogate</code>（代理/替代）</strong>：<ul><li><code>Array1D</code>替代了原生一维数组指针，简化了访问逻辑。</li></ul></li><li><strong>多维访问</strong>：<ul><li>通过<code>Array1D</code>实现多维数组的访问，而无需直接操作底层数据。</li></ul></li></ol><img src="/2025/01/25/CPP-2-3/image-20241221184931276.png" class="" title="image-20241221184931276"><p><strong>左侧代码解析：函数调用操作符 <code>()</code> 重载</strong></p><p><strong>代码概述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Func</span> &#123;</span><br><span class="line">    <span class="type">double</span> para;</span><br><span class="line">    <span class="type">int</span> lowerBound, upperBound;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span>, <span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><p><strong>函数调用操作符重载</strong>：</p><ul><li>通过重载 <code>operator()</code>，类对象可以像函数一样被调用。</li><li>定义：<ul><li><code>double operator()(double, int, int)</code> 表示此操作符接受 3 个参数（<code>double</code>、<code>int</code>、<code>int</code>），返回一个 <code>double</code> 类型的值。</li></ul></li></ul></li><li><p><strong>调用方式</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Func f;         <span class="comment">// 定义一个函数对象</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">2.4</span>, <span class="number">0</span>, <span class="number">8</span>);   <span class="comment">// 通过函数调用操作符调用对象 f，传入 3 个参数</span></span><br></pre></td></tr></table></figure><ul><li><code>f</code> 是一个 <code>Func</code> 类型的对象。</li><li><code>f(2.4, 0, 8)</code> 实际上会调用 <code>f.operator()(2.4, 0, 8)</code>。</li></ul></li></ol><p><strong>用途</strong></p><ul><li><strong>函数对象</strong>：<ul><li>可以将类对象作为函数使用，方便存储和调用复杂逻辑。</li><li>常见于标准库中的 STL 算法，例如自定义的比较器或筛选器。</li></ul></li><li><strong>封装逻辑</strong>：<ul><li>操作符重载可以将复杂逻辑封装到类中，提高代码的复用性和可读性。</li></ul></li></ul><p><strong>右侧代码解析：二维数组访问</strong></p><p><strong>代码概述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array2D</span> &#123;</span><br><span class="line">    <span class="type">int</span> n1, n2; <span class="comment">// n1: 行数，n2: 列数</span></span><br><span class="line">    <span class="type">int</span> *p;     <span class="comment">// 存储数据的一维数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array2D</span>(<span class="type">int</span> l, <span class="type">int</span> c): <span class="built_in">n1</span>(l), <span class="built_in">n2</span>(c) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="type">int</span>[n1 * n2]; <span class="comment">// 动态分配内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Array2D</span>() &#123; <span class="keyword">delete</span>[] p; &#125; <span class="comment">// 析构函数，释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span>&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (p + i * n2)[j]; <span class="comment">// 返回第 i 行第 j 列的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><p><strong>内存布局</strong>：</p><ul><li><p>数组数据存储在一维数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p</span><br></pre></td></tr></table></figure><p>中，采用行优先存储的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p[0], p[1], ..., p[n2-1]     (第 0 行)</span><br><span class="line">p[n2], ..., p[2*n2-1]        (第 1 行)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>对于第 <code>i</code> 行第 <code>j</code> 列的数据，其内存地址为 <code>p + i * n2 + j</code>。</p></li></ul></li><li><p><strong>操作符 <code>()</code> 重载</strong>：</p><ul><li><p>重载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operator()</span><br></pre></td></tr></table></figure><p>，实现类似二维数组的访问方式：</p><ul><li><code>data(i, j)</code> 会被翻译为 <code>data.operator()(i, j)</code>。</li></ul></li><li><p>返回值是二维数组中具体元素的引用。</p></li></ul></li><li><p><strong>析构函数</strong>：</p><ul><li>使用 <code>new</code> 动态分配内存后，需通过析构函数 <code>delete[] p</code> 释放内存，防止内存泄漏。</li></ul></li></ol><p><strong>调用方式</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Array2D <span class="title">data</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>; <span class="comment">// 创建 2 行 3 列的二维数组</span></span><br><span class="line"><span class="built_in">data</span>(<span class="number">0</span>, <span class="number">1</span>) = <span class="number">10</span>;    <span class="comment">// 设置第 0 行第 1 列的值为 10</span></span><br><span class="line"><span class="type">int</span> x = <span class="built_in">data</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 获取第 1 行第 2 列的值</span></span><br></pre></td></tr></table></figure><ul><li><p>调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data(0, 1)</span><br></pre></td></tr></table></figure><p>时：</p><ul><li><code>operator()(0, 1)</code> 被调用，返回 <code>(p + 0 * n2)[1]</code> 的引用，即 <code>p[1]</code>。</li><li>因为返回的是引用，所以可以直接修改该元素。</li></ul></li></ul><p><strong>PPT中的要点总结</strong></p><ol><li><strong>左侧内容：函数调用操作符重载</strong><ul><li>通过重载 <code>operator()</code>，可以让类对象像函数一样被调用。</li><li>常用于实现函数对象（functor），在 STL 算法中应用广泛。</li></ul></li><li><strong>右侧内容：二维数组访问</strong><ul><li>重载 <code>operator()</code> 实现仿真二维数组。</li><li>类似原生二维数组访问方式，但底层使用一维数组存储。</li><li>提高代码可读性，方便操作和管理多维数据。</li></ul></li></ol><h3 id="类型转换运算符">类型转换运算符</h3><img src="/2025/01/25/CPP-2-3/image-20241221185151391.png" class="" title="image-20241221185151391"><p><strong>类型转换操作符概述</strong></p><ul><li><p>类型转换操作符允许将自定义类对象转换为其他类型（通常是基本数据类型，如 <code>int</code>、<code>double</code> 等）。</p></li><li><p>语法格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>type</code> 是目标类型，例如 <code>int</code> 或 <code>double</code>。</li><li>返回值是将对象转换为目标类型的结果。</li></ul></li></ul><p><strong>代码实现：Rational 类</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">int</span> n1, <span class="type">int</span> n2) &#123; n = n1; d = n2; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (<span class="type">double</span>)n / d; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, d; <span class="comment">// n: 分子, d: 分母</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><strong>构造函数</strong>：<ul><li><code>Rational(int n1, int n2)</code>：接受两个整数参数 <code>n1</code> 和 <code>n2</code>，分别表示分子和分母。</li></ul></li><li><strong>类型转换操作符</strong>：<ul><li><code>operator double()</code>：将 <code>Rational</code> 对象转换为 <code>double</code> 类型。</li><li>返回值是 <code>n / d</code> 的浮点数值。</li></ul></li></ol><p><strong>调用示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">r</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;   <span class="comment">// 创建一个分数对象，分子为 1，分母为 2</span></span><br><span class="line"><span class="type">double</span> x = r;       <span class="comment">// 隐式调用 operator double，将 r 转换为 double</span></span><br><span class="line">x = x + r;          <span class="comment">// 在混合运算中再次调用 operator double</span></span><br></pre></td></tr></table></figure><ol><li><strong><code>double x = r;</code></strong>：<ul><li>隐式调用 <code>operator double()</code>，将 <code>Rational</code> 对象 <code>r</code> 转换为 <code>double</code>。</li><li>结果是 <code>x = 0.5</code>。</li></ul></li><li><strong><code>x = x + r;</code></strong>：<ul><li><code>x</code> 是 <code>double</code> 类型，<code>r</code> 是 <code>Rational</code> 类型。</li><li>在运算时，<code>r</code> 会隐式调用 <code>operator double()</code>，先转换为 <code>double</code> 类型，然后参与计算。</li></ul></li></ol><p><strong>代码的核心思想</strong></p><ol><li><p><strong>减少操作符重载的数量</strong>：</p><ul><li><p>PPT提到：<strong>“减少混合计算中需要定义的操作符重载函数的数量”</strong>。</p></li><li><p>通过类型转换操作符，将复杂的操作转化为简单的基本数据类型操作。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x = r + <span class="number">1.5</span>; <span class="comment">// 转换 r 为 double，简化计算</span></span><br></pre></td></tr></table></figure></li><li><p>如果不使用类型转换操作符，则需要为 <code>Rational</code> 和 <code>double</code> 的每种运算符（如 <code>+</code>、<code>-</code>）都单独定义重载函数，导致代码复杂性增加。</p></li></ul></li><li><p><strong>适用于数值类型的类设计</strong>：</p><ul><li><code>operator double()</code> 的设计使得 <code>Rational</code> 类可以无缝参与数值计算。</li><li>可以通过定义多个类型转换操作符（如 <code>operator int()</code>），实现与不同类型的数据的兼容。</li></ul></li></ol><p><strong>PPT右侧的例子</strong></p><ol><li><p><strong><code>ostream</code> 和 <code>if</code> 判断</strong>：</p><ul><li><p>示例中提到了 <code>ostream</code> 和条件语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (f) ...</span><br></pre></td></tr></table></figure></li><li><p>这是因为 C++ 标准库中的某些类（如 <code>std::ifstream</code> 或 <code>std::ofstream</code>）定义了类型转换操作符，将类对象转换为布尔值以支持条件判断。</p></li><li><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (file) &#123;  <span class="comment">// 隐式转换为布尔值，表示文件是否成功打开</span></span><br><span class="line">    <span class="comment">// 处理文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>自定义类型和基本数据类型的兼容性</strong>：</p><ul><li><p>通过定义类型转换操作符，允许自定义类型像基本类型一样被使用。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">r</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> x = r;   <span class="comment">// 隐式转换为 double</span></span><br><span class="line"><span class="keyword">if</span> (r &gt; <span class="number">0.5</span>) &#123;  <span class="comment">// 隐式转换后与 double 比较</span></span><br><span class="line">    <span class="comment">// 逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><img src="/2025/01/25/CPP-2-3/image-20241221190209596.png" class="" title="image-20241221190209596"><p><strong>核心内容与概念</strong></p><ol><li><strong><code>-&gt;</code> 是一个二元运算符（binary operator）</strong><ul><li>常用于指针访问对象的成员，例如：<code>ptr-&gt;member</code>。</li><li>在自定义类中，可以通过重载<code>operator-&gt;</code>来控制类的指针行为。</li><li>重载时返回值必须是<strong>指针类型</strong>，或能够递归调用返回指针的对象。</li></ul></li><li><strong>智能指针中的应用</strong><ul><li>智能指针（如<code>std::shared_ptr</code>、<code>std::unique_ptr</code>）通常通过重载<code>-&gt;</code>，让用户以普通指针的方式访问封装的对象。</li><li>例如：<code>smart_ptr-&gt;member</code>。</li></ul></li></ol><p><strong>代码分析</strong></p><p><strong><code>CPen</code>类</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPen</span> &#123;</span><br><span class="line">    <span class="type">int</span> m_color;</span><br><span class="line">    <span class="type">int</span> m_width;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setColor</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123; m_color = c; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_width; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><strong>成员变量</strong>：<ul><li><code>m_color</code>：记录颜色。</li><li><code>m_width</code>：记录宽度。</li></ul></li><li><strong>方法</strong>：<ul><li><code>setColor(int c)</code>：设置颜色。</li><li><code>getWidth()</code>：获取宽度。</li></ul></li></ol><p><strong><code>CPanel</code>类</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPanel</span> &#123;</span><br><span class="line">    CPen m_pen;</span><br><span class="line">    <span class="type">int</span> m_bkColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CPen* <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> &amp;m_pen; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setBkColor</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123; m_bkColor = c; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><p><strong>成员变量</strong>：</p><ul><li><code>m_pen</code>：一个<code>CPen</code>对象。</li><li><code>m_bkColor</code>：背景颜色。</li></ul></li><li><p><strong>方法</strong>：</p><ul><li><p>重载了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operator-&gt;</span><br></pre></td></tr></table></figure><p>：</p><ul><li>返回<code>m_pen</code>对象的地址（<code>CPen*</code>类型）。</li><li>让用户可以通过<code>CPanel</code>类直接访问<code>CPen</code>对象的成员。</li></ul></li><li><pre><code>setBkColor(int c)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     ：</span><br><span class="line"></span><br><span class="line">     - 设置背景颜色。</span><br><span class="line"></span><br><span class="line">**关键知识点**</span><br><span class="line"></span><br><span class="line">**1. 重载`operator-&gt;`**</span><br><span class="line"></span><br><span class="line">- 语法：</span><br><span class="line"></span><br><span class="line">  ```cpp</span><br><span class="line">  返回类型 operator-&gt;();</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ol><ul><li><p>必须返回指针类型，或者递归调用最终返回指针。</p></li><li><p>用法：</p><ul><li>允许用户通过重载的对象直接访问指针对象的成员，如<code>panel-&gt;getWidth()</code>。</li></ul></li><li><p>注意：</p><ul><li>递归调用时，如<code>a-&gt;b-&gt;c</code>，每一步都要求返回值能继续调用<code>-&gt;</code>。</li></ul></li></ul><p><strong>2. 调用流程</strong></p><p>通过以下代码演示调用流程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CPanel c;</span><br><span class="line">c-&gt;<span class="built_in">setColor</span>(<span class="number">16</span>); <span class="comment">// 等效于 c.operator-&gt;()-&gt;setColor(16);</span></span><br><span class="line">c-&gt;<span class="built_in">getWidth</span>();   <span class="comment">// 等效于 c.operator-&gt;()-&gt;getWidth();</span></span><br></pre></td></tr></table></figure><ul><li><code>c-&gt;setColor(16)</code>：<ol><li><code>c</code>调用重载的<code>operator-&gt;</code>，返回<code>CPen*</code>类型指针。</li><li>然后通过返回的指针调用<code>CPen</code>类的<code>setColor</code>方法，设置颜色为<code>16</code>。</li></ol></li><li><code>c-&gt;getWidth()</code>：<ol><li>类似调用，先返回<code>CPen*</code>指针。</li><li>再调用<code>CPen</code>的<code>getWidth</code>方法，返回宽度。</li></ol></li></ul><p><strong>3. 智能指针模拟</strong></p><p>智能指针的实现通常会用到<code>operator-&gt;</code>重载，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line">    Object* ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Object* <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> ptr; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这使得智能指针对象可以像普通指针一样操作其内部对象。</p><p><strong>代码示例中的重要细节</strong></p><p><strong>调用递归行为</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="keyword">operator</span>-&gt;()-&gt;<span class="keyword">operator</span>-&gt;()-&gt;<span class="built_in">f</span>();</span><br></pre></td></tr></table></figure><ul><li>每次调用<code>operator-&gt;</code>返回值都会再调用<code>operator-&gt;</code>，直到返回一个指针。</li><li>类似递归过程，最终访问目标成员。</li></ul><p><strong>返回值必须是指针类型</strong></p><ul><li>在C++标准中规定，<code>-&gt;</code>重载必须返回指针类型，否则会编译错误。</li><li>这是为了保证成员访问的连贯性。</li></ul><p><strong>右侧注释与提问</strong></p><ul><li>必须返回指针类型？<ul><li>因为<code>-&gt;</code>运算符的语义要求返回一个可以直接解引用的对象地址。</li></ul></li></ul><img src="/2025/01/25/CPP-2-3/image-20241221190509006.png" class="" title="image-20241221190509006"><p><strong>1. 背景问题</strong></p><p>在C++中，动态分配内存时，使用<code>new</code>创建对象后需要显式调用<code>delete</code>释放内存。若开发者忘记<code>delete</code>对象，或者程序中存在异常导致<code>delete</code>未被调用，就会引发<strong>内存泄漏（Memory Leak）</strong>。</p><p>示例中涉及的类<code>A</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">(<span class="type">char</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>A</code>是一个普通的类，包含一些成员函数，但如果动态分配<code>A</code>的对象（<code>new A</code>），需要手动释放。</p><p><strong>2. 动态内存分配的问题</strong></p><p>在<code>void test()</code>函数中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A* p = <span class="keyword">new</span> A;</span><br><span class="line">p-&gt;<span class="built_in">f</span>();</span><br><span class="line">p-&gt;<span class="built_in">g</span>(<span class="number">1.1</span>);</span><br><span class="line">p-&gt;<span class="built_in">h</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure><p>如果在执行<code>p-&gt;f()</code>、<code>p-&gt;g()</code>等操作期间，发生异常或者忘记写<code>delete p;</code>，会导致动态分配的<code>A</code>对象没有释放，从而造成内存泄漏。</p><p><strong>3. 解决方案：封装动态分配对象</strong></p><p>使用封装类<code>AWrapper</code>，将动态分配的对象封装起来，利用析构函数自动释放内存，从而避免泄漏。</p><p><strong>AWrapper类设计</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AWrapper</span> &#123;</span><br><span class="line">    A* p; <span class="comment">// 指向动态分配的A对象</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AWrapper</span>(A* p) &#123; <span class="keyword">this</span>-&gt;p = p; &#125; <span class="comment">// 构造函数，接受一个指针</span></span><br><span class="line">    ~<span class="built_in">AWrapper</span>() &#123; <span class="keyword">delete</span> p; &#125;      <span class="comment">// 析构函数，自动释放内存</span></span><br><span class="line">    A* <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> p; &#125;  <span class="comment">// 重载-&gt;，支持直接访问A的成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>成员变量：<ul><li><code>A* p</code>：保存动态分配的<code>A</code>对象的指针。</li></ul></li><li>构造函数：<ul><li><code>AWrapper(A* p)</code>：初始化封装类，保存动态分配的指针。</li></ul></li><li>析构函数：<ul><li><code>~AWrapper()</code>：在<code>AWrapper</code>对象生命周期结束时自动调用<code>delete</code>释放内存。</li></ul></li><li>运算符重载：<ul><li><code>A* operator-&gt;()</code>：重载<code>-&gt;</code>运算符，使得<code>AWrapper</code>类能够像指针一样访问<code>A</code>对象的成员。</li></ul></li></ul><p><strong>4. 使用封装类AWrapper</strong></p><p>修改后的<code>test()</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">AWrapper <span class="title">p</span><span class="params">(<span class="keyword">new</span> A)</span></span>; <span class="comment">// 使用AWrapper封装动态分配的A对象</span></span><br><span class="line">    p-&gt;<span class="built_in">f</span>();            <span class="comment">// 调用A的成员函数f()</span></span><br><span class="line">    p-&gt;<span class="built_in">g</span>(<span class="number">1.1</span>);         <span class="comment">// 调用A的成员函数g(double)</span></span><br><span class="line">    p-&gt;<span class="built_in">h</span>(<span class="string">&#x27;A&#x27;</span>);         <span class="comment">// 调用A的成员函数h(char)</span></span><br><span class="line">&#125; <span class="comment">// 自动调用~AWrapper()，释放动态分配的内存</span></span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><ol><li>自动释放内存：<ul><li><code>AWrapper</code>的析构函数负责释放<code>A</code>对象的内存。</li><li>避免了手动调用<code>delete</code>的错误，防止内存泄漏。</li></ul></li><li>兼容指针语法：<ul><li>通过<code>operator-&gt;</code>的重载，用户仍然可以使用<code>p-&gt;f()</code>的形式调用<code>A</code>的成员函数。</li></ul></li><li>安全性增强：<ul><li>即使在<code>test()</code>函数中抛出异常，<code>AWrapper</code>对象析构时也会自动释放内存。</li></ul></li></ol><p><strong>注意事项</strong></p><ul><li><code>AWrapper</code>类只能封装一个动态分配的<code>A</code>对象，如果需要管理多个对象或资源，建议使用<strong>标准智能指针</strong>。</li></ul><p><strong>5. 与智能指针的对比</strong></p><p>标准库中已有智能指针（如<code>std::unique_ptr</code>和<code>std::shared_ptr</code>），功能类似<code>AWrapper</code>，但更通用、更安全。</p><p><strong>改用<code>std::unique_ptr</code>的示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;A&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> A)</span></span>; <span class="comment">// 使用unique_ptr封装动态分配的A对象</span></span><br><span class="line">    p-&gt;<span class="built_in">f</span>();</span><br><span class="line">    p-&gt;<span class="built_in">g</span>(<span class="number">1.1</span>);</span><br><span class="line">    p-&gt;<span class="built_in">h</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">&#125; <span class="comment">// unique_ptr自动释放内存</span></span><br></pre></td></tr></table></figure><ul><li>优势：<ul><li>标准实现，测试充分。</li><li>支持深拷贝、移动语义。</li><li>可用于复杂资源管理。</li></ul></li></ul><img src="/2025/01/25/CPP-2-3/image-20241221191041959.png" class="" title="image-20241221191041959"><p><strong>1. 背景与问题</strong></p><ul><li>默认行为：<ul><li>在C++中，<code>new</code> 和 <code>delete</code> 运算符会直接调用系统的内存管理函数（如 <code>malloc</code> 和 <code>free</code>），用于申请和释放内存。</li><li>问题：<ul><li><strong>频繁调用系统内存管理函数</strong> 会增加开销，降低程序性能，尤其是在高频分配/释放内存的场景。</li></ul></li></ul></li><li>需求：<ul><li>对内存管理进行优化，通过 <strong>自定义内存分配策略</strong> 来提升效率。</li><li>实现特定场景下更灵活的内存管理机制。</li></ul></li></ul><p><strong>2. 解决方案</strong></p><p>通过<strong>重载 <code>new</code> 和 <code>delete</code> 运算符</strong>实现自定义内存管理。包括：</p><ul><li>重载<code>new</code>：<ul><li>控制内存分配过程。</li><li>可申请更大块的内存并复用，减少系统调用。</li></ul></li><li>重载<code>delete</code>：<ul><li>控制内存释放过程。</li><li>确保资源的正确回收与管理。</li></ul></li></ul><p><strong>3. 重载的特性</strong></p><ol><li>静态成员函数：<ul><li><code>new</code> 和 <code>delete</code> 被设计为<strong>静态成员函数</strong>，因此与类的具体对象无关。</li><li>可以<strong>直接通过类名调用</strong>。</li></ul></li><li>可继承性：<ul><li>重载的 <code>new</code> 和 <code>delete</code> 运算符<strong>可以被子类继承</strong>，从而避免子类重复定义相同的内存管理逻辑。</li></ul></li><li>避免循环类的访问控制问题：<ul><li>通过重载的形式，程序可以更灵活地控制访问权限与内存管理行为。</li></ul></li></ol><p><strong>4. 实现方法</strong></p><p><strong>步骤</strong></p><ol><li>调用系统的内存分配函数（如 <code>malloc</code>）申请较大的一块内存。</li><li>针对这块内存，自己管理分配和回收。</li><li>重载 <code>new</code> 和 <code>delete</code> 运算符实现上述逻辑。</li></ol><p><strong>5. 实际应用</strong></p><ol><li>提高内存分配效率：<ul><li>在游戏开发、嵌入式开发等高频次内存操作场景中，通过重载<code>new</code> 和 <code>delete</code>可以实现高效内存池。</li></ul></li><li>内存对齐控制：<ul><li>对硬件或性能要求较高的系统，可以通过自定义分配函数实现对内存对齐的严格控制。</li></ul></li><li>内存使用统计与调试：<ul><li>自定义 <code>new</code> 和 <code>delete</code> 可以统计每次内存分配的大小和位置，便于调试和检测内存泄漏。</li></ul></li></ol><p><strong>6. 示例代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重载 new 运算符</span></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Custom new: Allocating &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes.\n&quot;</span>;</span><br><span class="line">        <span class="type">void</span>* p = std::<span class="built_in">malloc</span>(size); <span class="comment">// 使用 malloc 分配内存</span></span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 delete 运算符</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Custom delete: Releasing memory.\n&quot;</span>;</span><br><span class="line">        std::<span class="built_in">free</span>(p); <span class="comment">// 使用 free 释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass* obj = <span class="keyword">new</span> <span class="built_in">MyClass</span>(); <span class="comment">// 调用重载的 new</span></span><br><span class="line">    <span class="keyword">delete</span> obj;                  <span class="comment">// 调用重载的 delete</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Custom new: Allocating 1 bytes.</span><br><span class="line">Custom delete: Releasing memory.</span><br></pre></td></tr></table></figure><p><strong>7. 优点</strong></p><ol><li>提升效率：<ul><li>减少系统函数调用频率，优化性能。</li></ul></li><li>定制化内存管理：<ul><li>满足特定场景需求，例如内存池、内存对齐等。</li></ul></li><li>提高安全性：<ul><li>通过控制内存分配与释放逻辑，可以减少内存泄漏等问题。</li></ul></li></ol><p><strong>8. 注意事项</strong></p><ol><li>继承与多态的注意点：<ul><li>子类继承父类时，需确保重载的 <code>new</code> 和 <code>delete</code> 能正确处理父类和子类的内存分配需求。</li></ul></li></ol><img src="/2025/01/25/CPP-2-3/image-20241221191637190.png" class="" title="image-20241221191637190"><p><strong>1. 重载<code>new</code>的定义</strong></p><ul><li><p><code>void *operator new(size_t size, ...)</code></p><ul><li><p><strong>函数名称</strong>：<code>operator new</code></p></li><li><p><strong>返回类型</strong>：<code>void *</code>，因为<code>new</code>操作符本质上是在分配内存，其返回的是内存的首地址（通用指针<code>void*</code>）。</p></li><li><p>第一个参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_t size</span><br></pre></td></tr></table></figure><ul><li>这是分配内存时必需的参数，表示系统自动计算对象的大小。</li><li>编译器在调用<code>operator new</code>时，会自动计算传入<code>size</code>的值，即所需内存的字节大小。</li></ul></li><li><p>其他参数：可有可无</p><ul><li>允许开发者在重载<code>new</code>时传入额外的参数，从而实现更灵活的内存管理。</li></ul></li></ul></li></ul><p><strong>2. 使用方式</strong></p><ul><li><p>基本形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A* p = <span class="built_in">new</span>(...) A;</span><br></pre></td></tr></table></figure><ul><li><code>A</code> 是要分配的对象类型。</li><li><code>...</code> 表示可以为<code>new</code>操作符传递额外的参数，这些参数会传递给用户定义的<code>operator new</code>。</li></ul></li></ul><p><strong>3. 重载<code>new</code>的特性</strong></p><ul><li>可以有多个重载：<ul><li>允许根据不同的参数列表（如<code>operator new(size_t)</code>或<code>operator new(size_t, const std::nothrow_t&amp;)</code>）定义多个<code>operator new</code>，以便满足不同场景下的需求。</li></ul></li><li>替代默认行为：<ul><li>如果重载了<code>new</code>，那么通过<code>new</code>动态创建对象时，将调用用户定义的<code>operator new</code>，而不会调用默认的内置实现。</li></ul></li></ul><p><strong>4. 默认<code>new</code>的行为</strong></p><ul><li><p>默认情况下，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new</span><br></pre></td></tr></table></figure><p>操作符会执行以下两步操作：</p><ol><li>分配内存：<ul><li>调用全局或类的<code>operator new</code>来申请内存。</li></ul></li><li>调用构造函数：<ul><li>在分配的内存上调用对象的构造函数。</li></ul></li></ol></li><li><p>重载<code>new</code>时，用户可以替代默认的<strong>内存分配行为</strong>，但构造函数的调用顺序不会改变。</p></li></ul><p><strong>5. 示例代码</strong></p><p>假如需要重载<code>new</code>以追踪内存分配，可以这样实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载 operator new</span></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Custom operator new called. Allocating &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes.\n&quot;</span>;</span><br><span class="line">        <span class="type">void</span>* p = std::<span class="built_in">malloc</span>(size); <span class="comment">// 使用 malloc 分配内存</span></span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>(); <span class="comment">// 如果内存分配失败，抛出异常</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 operator delete</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Custom operator delete called. Freeing memory.\n&quot;</span>;</span><br><span class="line">        std::<span class="built_in">free</span>(p); <span class="comment">// 使用 free 释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* obj = <span class="keyword">new</span> A; <span class="comment">// 调用重载的 operator new</span></span><br><span class="line">    <span class="keyword">delete</span> obj;     <span class="comment">// 调用重载的 operator delete</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Custom operator new called. Allocating 4 bytes.</span><br><span class="line">Custom operator delete called. Freeing memory.</span><br></pre></td></tr></table></figure><img src="/2025/01/25/CPP-2-3/image-20241221191800380.png" class="" title="image-20241221191800380"><p><strong>1. 重载<code>delete</code>的定义</strong></p><ul><li><p>函数原型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>函数名称</strong>：<code>operator delete</code>。</p></li><li><p><strong>返回类型</strong>：<code>void</code>，因为<code>delete</code>操作本质上是释放内存，不需要返回值。</p></li><li><p>参数：</p><ol><li><p><code>void *p</code>：</p><ul><li>要删除对象的指针。</li><li>表示需要释放的内存地址。</li></ul></li><li><p><code>size_t size</code></p><p>（可选参数）：</p><ul><li>要删除对象的大小。</li><li>如果指定了该参数，必须是<code>size_t</code>类型。</li><li>通常，编译器会自动传递对象的大小。</li></ul></li></ol></li></ul></li></ul><p><strong>2. 使用场景</strong></p><ul><li>释放动态内存：<ul><li><code>delete</code>操作符用于释放<code>new</code>分配的内存。</li><li>重载<code>delete</code>可以实现自定义的内存释放逻辑。</li></ul></li><li>配合重载<code>new</code>：<ul><li>如果对类重载了<code>new</code>，通常也需要重载<code>delete</code>，以确保配对使用。</li></ul></li></ul><p><strong>3. 重载的限制</strong></p><ol><li><strong><code>delete</code>的重载只能有一个</strong>：<ul><li>每个类只能定义一个<code>operator delete</code>版本。</li><li>这是因为<code>delete</code>的行为与内存释放的本质相关，不允许过多重载。</li></ul></li><li><strong>覆盖默认行为</strong>：<ul><li>如果重载了<code>delete</code>，那么使用<code>delete</code>释放对象时将调用用户自定义的<code>operator delete</code>。</li><li>不会再调用系统提供的默认<code>delete</code>。</li></ul></li></ol><p><strong>4. 默认<code>delete</code>的行为</strong></p><ul><li><p>默认</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete</span><br></pre></td></tr></table></figure><p>操作符会：</p><ol><li>调用析构函数：<ul><li>先销毁对象。</li></ul></li><li>释放内存：<ul><li>调用全局或类的<code>operator delete</code>释放内存。</li></ul></li></ol></li></ul><p><strong>5. 示例代码</strong></p><p>下面是一个重载<code>delete</code>操作符的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 operator new</span></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Custom operator new called. Allocating &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes.\n&quot;</span>;</span><br><span class="line">        <span class="type">void</span>* p = std::<span class="built_in">malloc</span>(size);</span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 operator delete</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Custom operator delete called. Freeing memory.\n&quot;</span>;</span><br><span class="line">        std::<span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* obj = <span class="keyword">new</span> A; <span class="comment">// 调用重载的 operator new</span></span><br><span class="line">    <span class="keyword">delete</span> obj;     <span class="comment">// 调用重载的 operator delete</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Custom operator new called. Allocating 4 bytes.</span><br><span class="line">Custom operator delete called. Freeing memory.</span><br></pre></td></tr></table></figure><p><strong>6. 带<code>size</code>参数的重载<code>delete</code></strong></p><p>在C++17中，引入了可以带<code>size</code>参数的<code>operator delete</code>，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Deleting object of size &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes.\n&quot;</span>;</span><br><span class="line">    std::<span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译器支持的场景</strong>：</p><ul><li>当删除对象时，编译器会自动将对象大小传递给<code>size</code>参数。</li></ul><p><strong>7. 注意事项</strong></p><ol><li>与<code>new</code>配套使用：<ul><li>如果对类定义了自定义<code>operator new</code>，建议同时定义对应的<code>operator delete</code>，以确保内存分配和释放的逻辑一致。</li></ul></li><li>析构函数调用：<ul><li>无论是否重载<code>delete</code>，析构函数的调用顺序不会受到影响。</li></ul></li><li>内存泄漏：<ul><li>重载<code>delete</code>时需要确保所有分配的内存都被正确释放，否则可能导致内存泄漏。</li></ul></li><li>性能问题：<ul><li>频繁的内存分配和释放会影响性能，自定义的<code>delete</code>可以优化释放逻辑。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习Pytorch/Pycharm等 踩坑记录</title>
      <link href="/2024/10/20/Pytorch%20%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/10/20/Pytorch%20%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1>深度学习代码/软件 踩坑记录</h1><h2 id="pycharm">pycharm</h2><h3 id="1-远程调试时，调试文件使用的是C盘JetBrains文件夹下的映射文件，而不是实际项目文件">1. 远程调试时，调试文件使用的是C盘JetBrains文件夹下的映射文件，而不是实际项目文件</h3><p>在调试时，会跳到断点位置，但是是C盘映射部分的对应文件，而不是pycharm中实际的打断点的文件</p><p>解决方案：在运行/调试设置中，增加路径映射：</p><img src="/2024/10/20/Pytorch%20%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/image-20241014144606967.png" class="" title="image-20241014144606967"><h3 id="2-远程调试设置文件路径出现FileNotFoundError-Errno-2-No-such-file-or-directory，找不到文件">2. 远程调试设置文件路径出现FileNotFoundError: [Errno 2] No such file or directory，找不到文件</h3><p>在经过1的路径映射设置和远程服务器正确配置后如果仍出现该问题，一般是工作目录设置成了子目录或者一些奇怪的地方，把工作目录改成项目目录即可，如下</p><img src="/2024/10/20/Pytorch%20%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/image-20241014144727017.png" class="" title="image-20241014144727017"><ul><li>这里原来是…/detrex/tools，默认设置成子目录了，导致相对路径错误</li></ul><h3 id="3-远程调用jupyternotebook报错">3. 远程调用jupyternotebook报错</h3><p><strong>报错信息：</strong></p><ul><li>如：Jupyter 服务器进程退出，代码为 1 [I 2024-10-21 02:50:57.667 ServerApp] jupyter_lsp | extension was successfully</li><li>主要最后一行含有：<code>Running as root is not recommended. Use --allow-root to bypass.</code></li></ul><p>这个报错的意思是你作为<code>root</code>访问远程服务器，但是 jupyter 不允许running as root</p><p><strong>解决方案：</strong></p><p>修改jupyter配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda activate your_environment_name</span><br><span class="line">vim ~/.jupyter/jupyter_notebook_config.py</span><br></pre></td></tr></table></figure><p>输入上述指令后，如果发现 config 文件不存在（即vim打开为空），则需用如下指令重新创建一个：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure><p>如果 config 文件已存在，则会进入到<a href="https://so.csdn.net/so/search?q=%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&amp;spm=1001.2101.3001.7020">配置文件</a>界面的中，我们需要使用vim指令对其进行编辑：<br>可以看到，<code>c.NotebookApp.allow_root/c.ServerApp.allow_root</code>默认是<code>False</code>，改成<code>True</code>即可解决问题。</p><img src="/2024/10/20/Pytorch%20%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/image-20241021111742034.png" class="" title="image-20241021111742034"><h2 id="pytorch">pytorch</h2><h3 id="1-4090最低可以用cuda11-0">1. 4090最低可以用cuda11.0</h3><h3 id="2-pip-install-e-报错：OSError">2. pip install -e ./ 报错：OSError</h3><p>完整报错如下：</p><p>![image-20241016144522371](Pytorch 踩坑记录/image-20241016144522371.png)![image-20241016144539350](Pytorch 踩坑记录/image-20241016144539350-17290611398871.png)</p><p>主要是两个错误：</p><ol><li>OSError: /root/miniconda3/envs/cdfsod/lib/python3.9/site-packages/torch/lib/…/…/nvidia/cublas/lib/libcublas.so.11: symbol cublasLtGetStatusString version libcublasLt.so.11 not defined in file libcublasLt.so.11 with link time reference</li><li>OSError: /root/miniconda3/envs/cdfsod/lib/python3.9/site-packages/nvidia/cublas/lib/libcublas.so.11: symbol cublasLtGetStatusString version libcublasLt.so.11 not defined in file libcublasLt.so.11 with link time reference</li></ol><p>这俩本质一样</p><p>解决方案：增加一个临时变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/root/miniconda3/envs/cdfsod/lib/python3.9/site-packages/nvidia/cublas/lib/:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure><ul><li>这里的路径参考上面报错的路径，对应一下即可</li></ul><h3 id="3-RuntimeError-weight-tensor-should-be-defined-either-for-all-or-no-classes">3.RuntimeError: weight tensor should be defined either for all or no classes</h3><ul><li>主要是weight的维度和实际不符，比如10个类，你的分类头是81维</li><li>修改维度或者取消weight的初始化即可</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习服务器常用Linux命令小结</title>
      <link href="/2024/10/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/"/>
      <url>/2024/10/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1>深度学习服务器常用Linux命令小结</h1><h2 id="说明">说明</h2><p>本博客记录了在利用Xshell，Xftp等访问服务器时用到的一些常用命令，持续更新中。</p><h2 id="更改文件夹访问权限">更改文件夹访问权限</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 /path</span><br></pre></td></tr></table></figure><h2 id="pip配置清华源">pip配置清华源</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip config <span class="built_in">set</span> global.index-url https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple</span><br></pre></td></tr></table></figure><h2 id="删除conda环境">删除conda环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove --name your_env_name --all</span><br></pre></td></tr></table></figure><h2 id="解压tar-gz文件">解压tar.gz文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf file.tar.gz</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DL服务器命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch Tensor 操作全面教程</title>
      <link href="/2024/10/14/PyTorch%20Tensor%20%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
      <url>/2024/10/14/PyTorch%20Tensor%20%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1>PyTorch Tensor 操作全面教程</h1><p>这篇博客将讨论PyTorch 中的tensor相关操作，分为四个主要部分：</p><ol><li>tensor的初始化</li><li>tensor的数学操作和比较</li><li>tensor的索引操作</li><li>tensor的重塑</li></ol><h2 id="1-初始化张量">1. 初始化张量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">device = <span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>  <span class="comment"># 如果有GPU可用，则使用GPU</span></span><br></pre></td></tr></table></figure><h3 id="1-1-张量的初始化">1.1 张量的初始化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_tensor = torch.tensor(</span><br><span class="line">    [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]], dtype=torch.float32, device=device, requires_grad=<span class="literal">True</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><code>torch.tensor()</code>：用于创建张量。</li><li><code>[[1, 2, 3], [4, 5, 6]]</code>：定义张量的数据，形状为 2 行 3 列。</li><li><code>dtype=torch.float32</code>：指定张量的数据类型为 32 位浮点数。</li><li><code>device=device</code>：将张量分配到之前设置的设备上（GPU 或 CPU）。</li><li><code>requires_grad=True</code>：表示是否需要对该张量进行求导，这在反向传播中非常重要。</li></ul><h3 id="1-2-张量属性">1.2 张量属性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Information about tensor: <span class="subst">&#123;my_tensor&#125;</span>&quot;</span>)  <span class="comment"># 打印张量的数据信息，包括设备和梯度信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Type of Tensor &#123;my_tensor.dtype&#125;&quot;</span>)  <span class="comment"># 打印张量的数据类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Device Tensor is on <span class="subst">&#123;my_tensor.device&#125;</span>&quot;</span>)  <span class="comment"># 打印张量所在的设备</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Shape of tensor <span class="subst">&#123;my_tensor.shape&#125;</span>&quot;</span>)  <span class="comment"># 打印张量的形状</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Requires gradient: <span class="subst">&#123;my_tensor.requires_grad&#125;</span>&quot;</span>)  <span class="comment"># 打印是否需要计算梯度</span></span><br></pre></td></tr></table></figure><ul><li><code>my_tensor.dtype</code>：获取张量的数据类型。</li><li><code>my_tensor.device</code>：获取张量所在的设备（CPU 或 CUDA）。</li><li><code>my_tensor.shape</code>：获取张量的形状。</li><li><code>my_tensor.requires_grad</code>：获取张量是否需要计算梯度。</li></ul><h3 id="1-3-常见的初始化方法">1.3 常见的初始化方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = torch.empty(size=(<span class="number">3</span>, <span class="number">3</span>))  <span class="comment"># 生成一个形状为 3x3 的张量，其中数据未初始化</span></span><br><span class="line">x = torch.zeros((<span class="number">3</span>, <span class="number">3</span>))  <span class="comment"># 生成一个形状为 3x3 的全零张量</span></span><br><span class="line">x = torch.rand((<span class="number">3</span>, <span class="number">3</span>))  <span class="comment"># 生成一个形状为 3x3 的张量，元素为 [0, 1) 区间的均匀分布随机数</span></span><br><span class="line">x = torch.ones((<span class="number">3</span>, <span class="number">3</span>))  <span class="comment"># 生成一个形状为 3x3 的全为 1 的张量</span></span><br><span class="line">x = torch.eye(<span class="number">5</span>, <span class="number">5</span>)  <span class="comment"># 生成一个 5x5 的单位矩阵</span></span><br><span class="line">x = torch.arange(start=<span class="number">0</span>, end=<span class="number">5</span>, step=<span class="number">1</span>)  <span class="comment"># 生成从 0 到 4 的张量，步长为 1</span></span><br><span class="line">x = torch.linspace(start=<span class="number">0.1</span>, end=<span class="number">1</span>, steps=<span class="number">10</span>)  <span class="comment"># 在 [0.1, 1] 区间内生成 10 个等间隔的数</span></span><br><span class="line">x = torch.empty(size=(<span class="number">1</span>, <span class="number">5</span>)).normal_(mean=<span class="number">0</span>, std=<span class="number">1</span>)  <span class="comment"># 生成一个均值为 0，标准差为 1 的正态分布张量</span></span><br><span class="line">x = torch.empty(size=(<span class="number">1</span>, <span class="number">5</span>)).uniform_(<span class="number">0</span>, <span class="number">1</span>)  <span class="comment"># 生成一个均匀分布在 [0, 1) 的张量</span></span><br><span class="line">x = torch.diag(torch.ones(<span class="number">3</span>))  <span class="comment"># 生成一个 3x3 的对角矩阵</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>torch.empty(size)</code></strong>：创建未初始化的 Tensor，内存中的随机值会填充。</li><li><strong><code>torch.zeros(size)</code></strong>：创建全 0 Tensor。</li><li><strong><code>torch.ones(size)</code></strong>：创建全 1 Tensor。</li><li><strong><code>torch.eye(n)</code></strong>：创建<strong>单位矩阵</strong>，对角线为 1，其他位置为 0。</li><li><strong><code>torch.arange(start, end, step)</code></strong>：生成从 <code>start</code> 到 <code>end</code>（不含 <code>end</code>）的序列，步长为 <code>step</code>。</li><li><strong><code>torch.linspace(start, end, steps)</code></strong>：在 <code>start</code> 和 <code>end</code> 之间生成 <code>steps</code> 个均匀间隔的数。</li><li><strong><code>torch.randn(size)</code></strong>：生成符合标准正态分布的随机数。</li><li><strong><code>torch.diag(tensor)</code></strong>：生成对角矩阵。</li></ul><h3 id="1-4-数据类型转换">1.4 数据类型转换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tensor = torch.arange(<span class="number">4</span>)  <span class="comment"># [0, 1, 2, 3]，默认类型为 int64</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Converted Boolean: <span class="subst">&#123;tensor.<span class="built_in">bool</span>()&#125;</span>&quot;</span>)  <span class="comment"># 转换为布尔类型：非零为 True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Converted int16 <span class="subst">&#123;tensor.short()&#125;</span>&quot;</span>)  <span class="comment"># 转换为 int16 类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Converted int64 <span class="subst">&#123;tensor.long()&#125;</span>&quot;</span>)  <span class="comment"># 转换为 int64 类型（非常常用）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Converted float16 <span class="subst">&#123;tensor.half()&#125;</span>&quot;</span>)  <span class="comment"># 转换为 float16 类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Converted float32 <span class="subst">&#123;tensor.<span class="built_in">float</span>()&#125;</span>&quot;</span>)  <span class="comment"># 转换为 float32 类型（非常常用）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Converted float64 <span class="subst">&#123;tensor.double()&#125;</span>&quot;</span>)  <span class="comment"># 转换为 float64 类型</span></span><br></pre></td></tr></table></figure><ul><li><code>tensor.bool()</code>：将张量的元素转换为布尔类型。</li><li><code>tensor.short()</code>：将张量的元素转换为 16 位整数。</li><li><code>tensor.long()</code>：将张量的元素转换为 64 位整数，这是非常常用的类型。</li><li><code>tensor.half()</code>：将张量的元素转换为 16 位浮点数。</li><li><code>tensor.float()</code>：将张量的元素转换为 32 位浮点数，这是深度学习中非常常用的类型。</li><li><code>tensor.double()</code>：将张量的元素转换为 64 位浮点数。</li></ul><h3 id="1-5-张量与-NumPy-数组的转换">1.5 张量与 NumPy 数组的转换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np_array = np.zeros((<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">tensor = torch.from_numpy(np_array)</span><br><span class="line">np_array_again = tensor.numpy()  <span class="comment"># 将张量转换回 NumPy 数组</span></span><br></pre></td></tr></table></figure><ul><li><code>torch.from_numpy(np_array)</code>：将 NumPy 数组转换为 PyTorch 张量。</li><li><code>tensor.numpy()</code>：将张量转换为 NumPy 数组。这种转换是共享内存的，因此更改其中一个也会更改另一个。</li></ul><h2 id="2-张量的数学与比较操作">2. 张量的数学与比较操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">y = torch.tensor([<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加法</span></span><br><span class="line">z1 = torch.empty(<span class="number">3</span>)</span><br><span class="line">torch.add(x, y, out=z1)  <span class="comment"># 通过 `out` 参数指定输出张量</span></span><br><span class="line">z2 = torch.add(x, y)  <span class="comment"># 直接相加</span></span><br><span class="line">z = x + y  <span class="comment"># 最简洁的加法方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 减法</span></span><br><span class="line">z = x - y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 除法</span></span><br><span class="line">z = torch.true_divide(x, y)  <span class="comment"># 元素间逐一相除</span></span><br></pre></td></tr></table></figure><ul><li><code>torch.add(x, y, out=z1)</code>：通过 <code>out</code> 参数指定将结果存储在 <code>z1</code> 中。</li><li><code>z = x + y</code>：最简洁的加法操作方式。</li><li><code>torch.true_divide(x, y)</code>：<strong>元素级</strong>逐一相除。</li></ul><h3 id="2-1-原地操作">2.1 原地操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = torch.zeros(<span class="number">3</span>)</span><br><span class="line">t.add_(x)  <span class="comment"># 原地相加，修改 `t` 本身</span></span><br><span class="line">t += x  <span class="comment"># 同样是原地操作</span></span><br></pre></td></tr></table></figure><ul><li><code>t.add_(x)</code> 和 <code>t += x</code>：原地操作会直接修改变量本身，这些操作在变量名后面带有 <code>_</code> 后缀。</li></ul><h3 id="2-2-幂运算与比较">2.2 幂运算与比较</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">z = x.<span class="built_in">pow</span>(<span class="number">2</span>)  <span class="comment"># 计算 x 的每个元素的平方</span></span><br><span class="line">z = x**<span class="number">2</span>  <span class="comment"># 等价于 `x.pow(2)`</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较操作</span></span><br><span class="line">z = x &gt; <span class="number">0</span>  <span class="comment"># 返回 [True, True, True]</span></span><br><span class="line">z = x &lt; <span class="number">0</span>  <span class="comment"># 返回 [False, False, False]</span></span><br></pre></td></tr></table></figure><ul><li><code>x.pow(2)</code> 和 <code>x**2</code>：计算张量每个元素的平方，结果相同。</li><li><code>x &gt; 0</code> 和 <code>x &lt; 0</code>：比较操作会逐元素返回布尔值。</li></ul><h3 id="2-3-矩阵乘法">2.3 矩阵乘法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x1 = torch.rand((<span class="number">2</span>, <span class="number">5</span>))</span><br><span class="line">x2 = torch.rand((<span class="number">5</span>, <span class="number">3</span>))</span><br><span class="line">x3 = torch.mm(x1, x2)  <span class="comment"># 矩阵乘法，输出形状为 2x3</span></span><br><span class="line">x3 = x1.mm(x2)  <span class="comment"># 与上一行等价</span></span><br></pre></td></tr></table></figure><ul><li><code>torch.mm(x1, x2)</code>：执行矩阵乘法，<code>x1</code> 的列数必须等于 <code>x2</code> 的行数。</li><li><code>x1.mm(x2)</code>：另一种调用矩阵乘法的方法，结果与 <code>torch.mm(x1, x2)</code> 相同。</li></ul><h3 id="2-4-矩阵的幂运算">2.4 矩阵的幂运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matrix_exp = torch.rand(<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(matrix_exp.matrix_power(<span class="number">3</span>))  <span class="comment"># 计算矩阵的三次幂，相当于 matrix_exp (mm) matrix_exp (mm) matrix_exp</span></span><br></pre></td></tr></table></figure><ul><li><code>matrix_exp.matrix_power(3)</code>：计算矩阵的三次幂，即将矩阵自身与自身相乘三次。</li></ul><h3 id="2-5-元素级乘法与点积">2.5 元素级乘法与点积</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">z = x * y  <span class="comment"># 元素级乘法，z = [9, 16, 21] = [1*9, 2*8, 3*7]</span></span><br><span class="line"></span><br><span class="line">z = torch.dot(x, y)  <span class="comment"># 计算向量的点积，结果为 1*9 + 2*8 + 3*7</span></span><br></pre></td></tr></table></figure><ul><li><code>x * y</code>：元素级乘法，每个元素对应相乘。</li><li><code>torch.dot(x, y)</code>：计算两个向量的点积。</li></ul><h3 id="2-6-批量矩阵乘法">2.6 批量矩阵乘法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">batch = <span class="number">32</span></span><br><span class="line">n = <span class="number">10</span></span><br><span class="line">m = <span class="number">20</span></span><br><span class="line">p = <span class="number">30</span></span><br><span class="line">tensor1 = torch.rand((batch, n, m))</span><br><span class="line">tensor2 = torch.rand((batch, m, p))</span><br><span class="line">out_bmm = torch.bmm(tensor1, tensor2)  <span class="comment"># 输出形状为 (batch, n, p)</span></span><br></pre></td></tr></table></figure><ul><li><code>torch.bmm(tensor1, tensor2)</code>：执行批量矩阵乘法，<code>tensor1</code> 和 <code>tensor2</code> 的第一个维度是批量大小，后面的维度表示矩阵的形状。</li></ul><h3 id="2-7-广播机制示例">2.7 广播机制示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x1 = torch.rand((<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">x2 = torch.ones((<span class="number">1</span>, <span class="number">5</span>))</span><br><span class="line">z = x1 - x2  <span class="comment"># 形状为 5x5，x2 会广播以匹配 x1 的形状</span></span><br><span class="line">z = x1**x2  <span class="comment"># 形状为 5x5，元素级指数运算，x2 会广播</span></span><br></pre></td></tr></table></figure><ul><li><code>x1 - x2</code>：<code>x2</code> 的形状是 <code>(1, 5)</code>，会自动广播为 <code>(5, 5)</code>，然后逐元素相减。</li><li><code>x1**x2</code>：<code>x2</code> 同样会广播为 <code>(5, 5)</code>，然后<strong>逐元素</strong>进行指数运算。</li></ul><h3 id="2-8-其他有用的张量操作">2.8 其他有用的张量操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sum_x = torch.<span class="built_in">sum</span>(x, dim=<span class="number">0</span>)  <span class="comment"># 在维度 0 上求和，结果为 6</span></span><br><span class="line">values, indices = torch.<span class="built_in">max</span>(x, dim=<span class="number">0</span>)  <span class="comment"># 获取最大值及其索引</span></span><br><span class="line">values, indices = torch.<span class="built_in">min</span>(x, dim=<span class="number">0</span>)  <span class="comment"># 获取最小值及其索引</span></span><br><span class="line">abs_x = torch.<span class="built_in">abs</span>(x)  <span class="comment"># 对每个元素取绝对值</span></span><br><span class="line">z = torch.argmax(x, dim=<span class="number">0</span>)  <span class="comment"># 获取最大值的索引</span></span><br><span class="line">z = torch.argmin(x, dim=<span class="number">0</span>)  <span class="comment"># 获取最小值的索引</span></span><br><span class="line">mean_x = torch.mean(x.<span class="built_in">float</span>(), dim=<span class="number">0</span>)  <span class="comment"># 求平均值，x 需要转换为浮点数</span></span><br><span class="line">z = torch.eq(x, y)  <span class="comment"># 逐元素比较是否相等，返回布尔值张量</span></span><br><span class="line">sorted_y, indices = torch.sort(y, dim=<span class="number">0</span>, descending=<span class="literal">False</span>)  <span class="comment"># 对张量排序</span></span><br><span class="line"></span><br><span class="line">z = torch.clamp(x, <span class="built_in">min</span>=<span class="number">0</span>)  <span class="comment"># 将所有小于 0 的值设为 0，大于 0 的值保持不变</span></span><br></pre></td></tr></table></figure><ul><li><code>torch.sum(x, dim=0)</code>：在指定维度上求和。</li><li><code>torch.max(x, dim=0)</code> 和 <code>torch.min(x, dim=0)</code>：获取最大值或最小值及其索引。</li><li><code>torch.abs(x)</code>：计算每个元素的绝对值。</li><li><code>torch.argmax(x, dim=0)</code> 和 <code>torch.argmin(x, dim=0)</code>：获取最大值或最小值的索引。</li><li><code>torch.mean(x.float(), dim=0)</code>：计算平均值，需要将整数类型转换为浮点数。</li><li><code>torch.eq(x, y)</code>：逐元素比较是否相等。</li><li><code>torch.sort(y, dim=0)</code>：对张量进行排序。</li><li><code>torch.clamp(x, min=0)</code>：将张量中的值限制在指定范围内。</li></ul><h3 id="2-9-布尔值操作">2.9 布尔值操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], dtype=torch.<span class="built_in">bool</span>)  <span class="comment"># 布尔值张量</span></span><br><span class="line">z = torch.<span class="built_in">any</span>(x)  <span class="comment"># 如果任一元素为 True，则返回 True</span></span><br><span class="line">z = torch.<span class="built_in">all</span>(x)  <span class="comment"># 如果所有元素为 True，则返回 True</span></span><br></pre></td></tr></table></figure><ul><li><code>torch.any(x)</code>：检查张量中是否有任一元素为 <code>True</code>。</li><li><code>torch.all(x)</code>：检查张量中是否所有元素都为 <code>True</code>。</li></ul><h2 id="3-张量的索引操作">3. 张量的索引操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">10</span></span><br><span class="line">features = <span class="number">25</span></span><br><span class="line">x = torch.rand((batch_size, features))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取第一个样本的所有特征</span></span><br><span class="line"><span class="built_in">print</span>(x[<span class="number">0</span>].shape)  <span class="comment"># 输出形状为 [25]，等同于 x[0, :]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有样本的第一个特征</span></span><br><span class="line"><span class="built_in">print</span>(x[:, <span class="number">0</span>].shape)  <span class="comment"># 输出形状为 [10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取第三个样本的前十个特征</span></span><br><span class="line"><span class="built_in">print</span>(x[<span class="number">2</span>, <span class="number">0</span>:<span class="number">10</span>].shape)  <span class="comment"># 输出形状为 [10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改特定元素的值</span></span><br><span class="line">x[<span class="number">0</span>, <span class="number">0</span>] = <span class="number">100</span></span><br></pre></td></tr></table></figure><ul><li><code>x[0]</code>：获取第一个样本的所有特征。</li><li><code>x[:, 0]</code>：获取所有样本的第一个特征。</li><li><code>x[2, 0:10]</code>：获取第三个样本的前十个特征。</li><li><code>x[0, 0] = 100</code>：将第一个样本的第一个特征值修改为 100。</li></ul><h3 id="3-1-花式索引">3.1 花式索引</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = torch.arange(<span class="number">10</span>)</span><br><span class="line">indices = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line"><span class="built_in">print</span>(x[indices])  <span class="comment"># 输出 [2, 5, 8]</span></span><br><span class="line"></span><br><span class="line">x = torch.rand((<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line">rows = torch.tensor([<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">cols = torch.tensor([<span class="number">4</span>, <span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(x[rows, cols])  <span class="comment"># 获取第二行第五列和第一行第一列的值</span></span><br></pre></td></tr></table></figure><ul><li><code>x[indices]</code>：使用索引列表进行索引。</li><li><code>x[rows, cols]</code>：获取指定行和列的元素值。</li></ul><h3 id="3-2-更多高级索引">3.2 更多高级索引</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = torch.arange(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(x[(x &lt; <span class="number">2</span>) | (x &gt; <span class="number">8</span>)])  <span class="comment"># 输出 [0, 1, 9]</span></span><br><span class="line"><span class="built_in">print</span>(x[x.remainder(<span class="number">2</span>) == <span class="number">0</span>])  <span class="comment"># 输出 [0, 2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure><ul><li><code>(x &lt; 2) | (x &gt; 8)</code>：逻辑或操作符，用于筛选满足条件的元素。</li><li><code>x.remainder(2) == 0</code>：筛选出能够被 2 整除的元素。</li></ul><h3 id="3-3-索引操作的有用函数">3.3 索引操作的有用函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(torch.where(x &gt; <span class="number">5</span>, x, x * <span class="number">2</span>))  <span class="comment"># 如果 x &gt; 5，则返回 x，否则返回 x * 2</span></span><br><span class="line">x = torch.tensor([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).unique()  <span class="comment"># 返回 [0, 1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">print</span>(x.ndimension())  <span class="comment"># 返回张量的维度数量</span></span><br><span class="line">x = torch.arange(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(x.numel())  <span class="comment"># 返回张量中的元素总数</span></span><br></pre></td></tr></table></figure><ul><li><code>torch.where(condition, x, y)</code>：根据条件选择返回 <code>x</code> 或 <code>y</code>。</li><li><code>x.unique()</code>：返回张量中唯一的元素。</li><li><code>x.ndimension()</code>：返回张量的维度数量。</li><li><code>x.numel()</code>：返回张量中的元素总数。</li></ul><h2 id="4-张量的重塑">4. 张量的重塑</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = torch.arange(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重塑为 3x3</span></span><br><span class="line">x_3x3 = x.view(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># view 和 reshape 的区别</span></span><br><span class="line">x_3x3 = x.reshape(<span class="number">3</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><ul><li><code>x.view(3, 3)</code>：将张量重塑为 3x3。</li><li><code>x.reshape(3, 3)</code>：与 <code>view</code> 类似，但 <code>reshape</code> 可以处理非连续存储的张量。</li></ul><h3 id="4-1-其他重塑操作">4.1 其他重塑操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y = x_3x3.t()</span><br><span class="line"><span class="built_in">print</span>(y.is_contiguous())  <span class="comment"># 检查张量是否是连续存储的，结果为 False</span></span><br><span class="line"><span class="built_in">print</span>(y.contiguous().view(<span class="number">9</span>))  <span class="comment"># 调用 `.contiguous()` 使其连续存储后再使用 view</span></span><br></pre></td></tr></table></figure><ul><li><code>y.is_contiguous()</code>：检查张量是否是连续存储的。</li><li><code>y.contiguous().view(9)</code>：将张量转换为连续存储后再重塑。</li></ul><h3 id="4-2-张量拼接与展开">4.2 张量拼接与展开</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x1 = torch.rand(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">x2 = torch.rand(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(torch.cat((x1, x2), dim=<span class="number">0</span>).shape)  <span class="comment"># 拼接后形状为 4x5</span></span><br><span class="line"><span class="built_in">print</span>(torch.cat((x1, x2), dim=<span class="number">1</span>).shape)  <span class="comment"># 拼接后形状为 2x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 展开张量</span></span><br><span class="line">z = x1.view(-<span class="number">1</span>)  <span class="comment"># 展开为一维向量</span></span><br></pre></td></tr></table></figure><ul><li><code>torch.cat((x1, x2), dim=0)</code>：在指定维度上拼接张量。</li><li><code>x1.view(-1)</code>：将张量展开为一维向量。</li></ul><h3 id="4-3-改变维度顺序与添加-移除维度">4.3 改变维度顺序与添加/移除维度</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">batch = <span class="number">64</span></span><br><span class="line">x = torch.rand((batch, <span class="number">2</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改变维度顺序</span></span><br><span class="line">z = x.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)  <span class="comment"># 交换维度 1 和维度 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加维度</span></span><br><span class="line">x = torch.arange(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(x.unsqueeze(<span class="number">0</span>).shape)  <span class="comment"># 形状变为 [1, 10]</span></span><br><span class="line"><span class="built_in">print</span>(x.unsqueeze(<span class="number">1</span>).shape)  <span class="comment"># 形状变为 [10, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除维度</span></span><br><span class="line">x = torch.arange(<span class="number">10</span>).unsqueeze(<span class="number">0</span>).unsqueeze(<span class="number">1</span>)</span><br><span class="line">z = x.squeeze(<span class="number">1</span>)  <span class="comment"># 移除维度，形状变为 [1, 10]</span></span><br></pre></td></tr></table></figure><ul><li><code>x.permute(0, 2, 1)</code>：重新排列张量的维度。</li><li><code>x.unsqueeze(dim)</code>：在指定位置添加一个维度。</li><li><code>x.squeeze(dim)</code>：移除指定的维度。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Pytorch应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于docker的服务器深度学习环境构建——pycharm连接调试全流程</title>
      <link href="/2024/10/13/%E5%9F%BA%E4%BA%8Edocker%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94pycharm%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B/"/>
      <url>/2024/10/13/%E5%9F%BA%E4%BA%8Edocker%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94pycharm%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1>基于docker的服务器深度学习环境构建——pycharm连接调试全流程</h1><h2 id="说明">说明</h2><p>该博客教程基于2024最新版pycharm。由于网上的配置教程一般都是几年前的，导致在按照往年教程配置深度学习环境过程中，会出现各种难以解决的问题。</p><p>本教程基于最新版pycharm，docker等，帮你一站式解决深度学习环境配置问题，包括：</p><ul><li>在服务器上构建docker容器</li><li>在docker容器上配置conda深度学习环境</li><li><strong>在本机pycharm上远程连接docker容器的深度学习环境，并可在主机直接进行运行，调试等</strong></li></ul><p><strong>You’re just a few steps away from success!</strong></p><h2 id="环境">环境</h2><p>服务器：Ubuntu20.04</p><p>Pycharm Professtional：2024.1.6</p><ul><li>注意，如果要远程连接服务器，pycharm必须使用professtional版，community版无法进行远程连接</li></ul><h2 id="零-基本环境配置">零. 基本环境配置</h2><p>默认你的深度学习服务器已经安装了<strong>Nvidia Driver, CUDA和cuDNN</strong>等深度学习组件，该教程不进行上述基本环境的配置讲解，请自行搜索（资源太多了）。</p><p>ps：如果你已经安装了docker容器，但是配置错误，建议根据本教程将已有docker容器删除后进行重新配置，删除命令如下，其中我的docker容器起名为<code>pycharm_lkq</code>，请根据你的需要自己取名。</p><img src="/2024/10/13/%E5%9F%BA%E4%BA%8Edocker%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94pycharm%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B/image-20241013101809660.png" class="" title="image-20241013101809660"><h2 id="一-在远程服务器上构建docker容器">一. 在远程服务器上构建docker容器</h2><h3 id="1-启动并运行容器">1. 启动并运行容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker run -it --name pycharm_lkq --shm-size 8g -v /home/lkq/PycharmProjects/qa/:/workspace/qa -p 8080:22 --gpus all -e NVIDIA_DRIVER_CAPABILITIES=compute,utility -e NVIDIA_VISIBLE_DEVICES=all registry.cn-hangzhou.aliyuncs.com/alter_images/pytorch:1.10.0-cuda11.3-cudnn8-devel /bin/bash</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker run -it \</span><br><span class="line">    --name pycharm_lkq \</span><br><span class="line">    --shm-size 8g \</span><br><span class="line">    -v /home/lkq/PycharmProjects/:/workspace \</span><br><span class="line">    -v /mnt/data/lkq:/workspace/data \</span><br><span class="line">    -p 8080:22 \</span><br><span class="line">    --gpus all \</span><br><span class="line">    -e NVIDIA_DRIVER_CAPABILITIES=compute,utility \</span><br><span class="line">    -e NVIDIA_VISIBLE_DEVICES=all \</span><br><span class="line">    registry.cn-hangzhou.aliyuncs.com/alter_images/pytorch:1.10.0-cuda11.3-cudnn8-devel \</span><br><span class="line">    /bin/bash</span><br></pre></td></tr></table></figure><p>注意几个重要参数</p><ul><li><code>-p 8080:22</code>：主机端口是8080，容器端口是22。建议不要更改容器端口，如果8080被占用，可以更改主机端口为8081等合法端口号</li><li><code>registry.cn-hangzhou.aliyuncs.com/alter_images/pytorch:1.10.0-cuda11.3-cudnn8-devel /bin/bash</code>：这里的基础镜像请与你需要的pytorch环境保持一致，不用与示例一样</li><li><code>--shm-size 8g</code>：可选，如果服务器内存够大建议添加，可扩大docker容器内存，避免后期容器内存不够的情况</li><li><code>-e NVIDIA_DRIVER_CAPABILITIES=compute,utility -e NVIDIA_VISIBLE_DEVICES=all</code>：可选，建议添加，作用可自行检索</li><li>其他参数请自行搜索</li></ul><p><strong>在执行上述命令后，会默认进入到docker容器中。下面的步骤2-6都在容器中执行。</strong></p><h3 id="2-进入容器后修改root密码">2. 进入容器后修改root密码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure><img src="/2024/10/13/%E5%9F%BA%E4%BA%8Edocker%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94pycharm%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B/image-20241013104628151.png" class="" title="image-20241013104628151"><h3 id="3-更新-etc-apt-source-list中的源">3. 更新/etc/apt/source.list中的源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure><p>（可选）可能出现错误：</p><img src="/2024/10/13/%E5%9F%BA%E4%BA%8Edocker%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94pycharm%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B/image-20241013102528684.png" class="" title="image-20241013102528684"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E: The repository &#x27;https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64  InRelease&#x27; is no longer signed.</span><br></pre></td></tr></table></figure><p>解决方案：</p><p>后两行代码需要注意ubuntu对应的版本，如果是18.04就可以直接复制，如果不是就改成当前ubuntu系统对应的版本，我已经将其改成了ubuntu2004</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> /etc/apt/sources.list.d/cuda.list</span><br><span class="line"><span class="built_in">rm</span> /etc/apt/sources.list.d/nvidia-ml.list</span><br><span class="line">apt-key del 7fa2af80</span><br><span class="line">apt-key adv --fetch-keys https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2004/x86_64/3bf863cc.pub</span><br><span class="line">apt-key adv --fetch-keys https://developer.download.nvidia.com/compute/machine-learning/repos/ubuntu2004/x86_64/7fa2af80.pub</span><br></pre></td></tr></table></figure><p>再次运行：</p><img src="/2024/10/13/%E5%9F%BA%E4%BA%8Edocker%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94pycharm%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B/image-20241013105028085.png" class="" title="image-20241013105028085"><ul><li>运行成功</li></ul><h3 id="4-安装容器远程连接等必要的组件">4. 安装容器远程连接等必要的组件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apt-get install openssh-server</span><br><span class="line">apt-get install openssh-client</span><br><span class="line">apt-get install vim</span><br><span class="line">apt-get install iputils-ping</span><br><span class="line">apt-get install wget</span><br><span class="line">apt-get install procps</span><br></pre></td></tr></table></figure><h3 id="5-修改SSH配置文件">5. 修改SSH配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>以上命令打开sshd_config文件，在文件最后面添加：<code>PermitRootLogin yes</code></p><ul><li>即允许root用户使用ssh登录</li></ul><h3 id="6-重启ssh服务：">6. 重启ssh服务：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/ssh restart</span><br></pre></td></tr></table></figure><img src="/2024/10/13/%E5%9F%BA%E4%BA%8Edocker%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94pycharm%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B/image-20241013105347991.png" class="" title="image-20241013105347991"><h3 id="7-退出容器进行连接测试">7. 退出容器进行连接测试</h3><p>使用exit命令退出容器</p><p>执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@127.0.0.1 -p 8080</span><br></pre></td></tr></table></figure><ul><li>root：容器内部系统的root账号，不是服务器的用户账号</li><li>127.0.0.1：服务器本机ip</li><li>-p 端口号：这里的端口就是我们在步骤1 启动容器时映射的主机端口号8080，不是容器的端口22<ul><li>主机端口号根据你的设置进行修改</li></ul></li></ul><p>（可选）<strong>执行上述命令后</strong>可能会出现很多问题，按照时间顺序梳理如下：</p><ol><li><img src="/2024/10/13/%E5%9F%BA%E4%BA%8Edocker%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94pycharm%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B/image-20241013110121446.png" class="" title="image-20241013110121446"></li></ol><p>这是因为你的docker容器没有启动，在主机上执行<code>sudo docker start pycharm_lkq</code></p><ol start="2"><li><img src="/2024/10/13/%E5%9F%BA%E4%BA%8Edocker%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94pycharm%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B/image-20241013110158834.png" class="" title="image-20241013110158834"></li></ol><p>需要重新进入docker容器，在容器内执行<code>service ssh restart</code></p><img src="/2024/10/13/%E5%9F%BA%E4%BA%8Edocker%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94pycharm%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B/image-20241028160844098.png" class="" title="image-20241028160844098"><ol start="3"><li><img src="/2024/10/13/%E5%9F%BA%E4%BA%8Edocker%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94pycharm%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B/image-20241013110336770.png" class="" title="image-20241013110336770"></li></ol><p>该问题大多数情况出现在你重新配置了已删除的docker容器。在主机上执行<code>vim ~/.ssh/known_hosts</code>，而后清空该文件中的内容，从而去除过时的认证</p><p>成功连接如下图所示：</p><img src="/2024/10/13/%E5%9F%BA%E4%BA%8Edocker%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94pycharm%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B/image-20241013105745406.png" class="" title="image-20241013105745406"><p><strong>如果该步如图所示，那么表明第一阶段的docker容器配置已经成功！</strong></p><h2 id="二-在docker容器上配置conda环境">二. 在docker容器上配置conda环境</h2><ul><li>请你重新进入docker容器，而后在容器内执行以下步骤</li></ul><h3 id="1-确定CUDA版本">1. 确定CUDA版本</h3><p>执行<code>nvcc -V</code>确定CUDA版本，并检查docker容器内环境是否成功配置</p><p>（可选）可能出现<code>-bash: nvcc: command not found</code>错误。不要慌，如果服务器上的环境配置正确，那么该docker容器中的环境大概率仍是正确的，只需要进行如下配置</p><p>首先，查看cuda的bin目录下是否有nvcc：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/cuda/bin</span><br></pre></td></tr></table></figure><p>如果存在，直接将cuda路径加入系统路径即可：</p><p><code>vim ~/.bashrc</code>进入配置文件，而后在文件末尾添加以下两行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/usr/local/cuda/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/local/cuda/lib64:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure><p>最后更新配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>再次执行nvcc -V就能看到相应cuda版本了，例如：</p><img src="/2024/10/13/%E5%9F%BA%E4%BA%8Edocker%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94pycharm%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B/image-20241013110933273.png" class="" title="image-20241013110933273"><h3 id="2-安装miniconda">2. 安装miniconda</h3><p>进入<a href="https://docs.conda.io/projects/miniconda/en/latest/">miniconda官网</a>，选择命令行下载，获取命令行下载的指令。</p><img src="/2024/10/13/%E5%9F%BA%E4%BA%8Edocker%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94pycharm%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B/image-20241013111102171.png" class="" title="image-20241013111102171"><p>（可选）：miniconda官网的下载指令可能会更新，可以使用以下指令，在目前阶段经过测试一直是可用的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/miniconda3</span><br><span class="line">wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/miniconda3/miniconda.sh</span><br><span class="line">bash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3</span><br><span class="line"><span class="built_in">rm</span> ~/miniconda3/miniconda.sh</span><br></pre></td></tr></table></figure><p>初始化miniconda和shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/miniconda3/bin/conda init bash</span><br><span class="line">~/miniconda3/bin/conda init zsh</span><br></pre></td></tr></table></figure><p>此时使用<code>exit</code>退出容器，而后重新进入，就可以看到base环境已经成功构建了<img src="/2024/10/13/%E5%9F%BA%E4%BA%8Edocker%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94pycharm%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B/image-20241013111226256.png" class="" title="image-20241013111226256"></p><h3 id="3-配置conda环境">3. 配置conda环境</h3><ul><li>这里根据你的需要配置环境即可，这里举一个简单的例子</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n detrex python=3.8</span><br><span class="line">conda activate detrex</span><br></pre></td></tr></table></figure><ul><li>此时你就拥有了一个名为<code>detrex</code>，同时python版本为3.8的conda环境，你可以在这里面进行其他包的安装，<strong>后续的教程默认你已经配置好完成的conda环境</strong></li></ul><h2 id="三-在pycharm上远程连接docker容器的conda环境">三. 在pycharm上远程连接docker容器的conda环境</h2><h3 id="1-配置远程连接到服务器">1. 配置远程连接到服务器</h3><p>点击工具，进入部署的配置选项</p><img src="/2024/10/13/%E5%9F%BA%E4%BA%8Edocker%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94pycharm%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B/image-20241013094632487.png" class=""><p>点击加号，选择SFTP</p><img src="/2024/10/13/%E5%9F%BA%E4%BA%8Edocker%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94pycharm%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B/image-20241013111505596.png" class="" title="image-20241013111505596"><p>首先看到的是右图，点击其中SSH配置框右侧的<code>...</code>，弹出左图</p><ul><li>主机：远程服务器ip</li><li>端口号：docker容器映射到的主机端口号</li><li>用户名：docker容器内部的root账户</li><li>身份验证类型：密码（之前设置过的docker容器内的密码）</li></ul><p>而后点击<strong>测试连接</strong>查看是否能成功连接</p><img src="/2024/10/13/%E5%9F%BA%E4%BA%8Edocker%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94pycharm%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B/image-20241013094807262.png" class="" title="image-20241013094807262"><p>而后配置路径映射：</p><p>本地路径即为该项目所在路径，一般不用改</p><p>部署路径即为你希望将你的项目部署在服务器的位置</p><img src="/2024/10/13/%E5%9F%BA%E4%BA%8Edocker%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94pycharm%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B/image-20241013094921865.png" class="" title="image-20241013094921865"><h3 id="2-上传本地代码数据到docker容器中">2. 上传本地代码数据到docker容器中</h3><p>右键项目根目录，点击部署，上传到…，将本地代码数据上传到服务器上的docker容器中</p><img src="/2024/10/13/%E5%9F%BA%E4%BA%8Edocker%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94pycharm%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B/image-20241013094957291.png" class="" title="image-20241013094957291"><p>（可选）：在工具栏中点击<strong>自动上传（始终）<strong>和</strong>浏览远程主机</strong>，方便之后代码的修改和调试</p><img src="/2024/10/13/%E5%9F%BA%E4%BA%8Edocker%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94pycharm%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B/image-20241013095052338.png" class="" title="image-20241013095052338"><h3 id="3-配置python解释器">3. 配置python解释器</h3><p>点击文件——设置</p><img src="/2024/10/13/%E5%9F%BA%E4%BA%8Edocker%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94pycharm%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B/image-20241013112205222.png" class="" title="image-20241013112205222"><p>选择项目——python解释器，点击右侧的“添加解释器”——SSH</p><img src="/2024/10/13/%E5%9F%BA%E4%BA%8Edocker%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94pycharm%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B/image-20241013100139446.png" class="" title="image-20241013100139446"><p>点击“现有”，选择刚刚配置好的docker容器</p><img src="/2024/10/13/%E5%9F%BA%E4%BA%8Edocker%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94pycharm%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B/image-20241013113609442.png" class="" title="image-20241013113609442"><p>点击下一步</p><img src="/2024/10/13/%E5%9F%BA%E4%BA%8Edocker%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94pycharm%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B/image-20241013100228212.png" class="" title="image-20241013100228212"><p>现在SSH已经设置好，接下来就该配置conda环境了</p><p>下面是最坑的地方之一。由于pycharm2024的更新，<strong>导致原有的很多教程的设置都是错误的</strong>。</p><p>如下图：</p><img src="/2024/10/13/%E5%9F%BA%E4%BA%8Edocker%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94pycharm%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B/image-20241013113646993.png" class="" title="image-20241013113646993"><p>如果此时你按照常理选择了”Conda环境“，你会发现不管你使用教程的方法配置，还是自己折腾，基本全会报错，比如下图的错误：</p><img src="/2024/10/13/%E5%9F%BA%E4%BA%8Edocker%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94pycharm%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B/image-20241013114012190.png" class="" title="image-20241013114012190"><p><strong>解决方法：</strong></p><ol><li>在docker容器内执行<code>which conda</code>，找到conda路径</li></ol><img src="/2024/10/13/%E5%9F%BA%E4%BA%8Edocker%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94pycharm%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B/image-20241013100510257.png" class="" title="image-20241013100510257"><ul><li>如上图，我们可以知道conda位于<code>/root/miniconda3/bin</code>目录下</li></ul><ol start="2"><li>回到pycharm，选择默认的<strong>Virtualenv环境</strong>，点击“现有”，点击解释器右边的<code>...</code>，根据上述conda路径选择对应envs中的<code>/bin/python</code>文件</li></ol><img src="/2024/10/13/%E5%9F%BA%E4%BA%8Edocker%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94pycharm%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B/image-20241013100729725.png" class="" title="image-20241013100729725"><p>同步文件夹：映射目录根据你的设置选择容器中的目录</p><img src="/2024/10/13/%E5%9F%BA%E4%BA%8Edocker%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94pycharm%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B/image-20241013100933057.png" class="" title="image-20241013100933057"><h2 id="四、小结">四、小结</h2><p>至此，如果你已经成功完成了以上三步，那么恭喜你，已经成功完成了pycharm连接docker容器深度学习环境的全流程！</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DL环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RevisitingML_从数学角度重游机器学习</title>
      <link href="/2024/10/07/Revisiting_ML/"/>
      <url>/2024/10/07/Revisiting_ML/</url>
      
        <content type="html"><![CDATA[<h1>Revisiting_ML</h1><h2 id="基础回顾">基础回顾</h2><h3 id="向量的模与范数">向量的模与范数</h3><p>在机器学习中，<strong>范数（Norm）</strong> 是一个非常重要的概念，用来衡量向量的长度或大小。常见的范数包括 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">L^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span> 范数、 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">L^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 范数和一般的  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mi>p</mi></msup></mrow><annotation encoding="application/x-tex">L^p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span></span> 范数，它们在不同的场景下有不同的作用。下面我们详细解释几种常见的范数及其在机器学习中的应用。</p><ol><li>一般的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>L</mi><mi>p</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(L^p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>范数</li></ol><p>范数的通用公式为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∥</mi><mi>x</mi><msub><mi mathvariant="normal">∥</mi><mi>p</mi></msub><mo>=</mo><msup><mrow><mo fence="true">(</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mi>i</mi></msub><msup><mi mathvariant="normal">∣</mi><mi>p</mi></msup><mo fence="true">)</mo></mrow><mfrac><mn>1</mn><mi>p</mi></mfrac></msup></mrow><annotation encoding="application/x-tex">\|x\|_p = \left( \sum_{i=1}^{n} |x_i|^p \right)^{\frac{1}{p}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord">∥</span><span class="mord mathnormal">x</span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.3716em;vertical-align:-1.2777em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">(</span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size4">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:2.0939em;"><span style="top:-4.5029em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4829em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>其中，向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 的分量为 ( <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>…</mo></mrow><annotation encoding="application/x-tex">\dots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.123em;"></span><span class="minner">…</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> )，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 是一个大于等于1的实数，表示不同的范数。范数的通用定义适用于所有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>p</mi><mo>≥</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">( p \geq 1 )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，它是对向量分量绝对值的某种程度上的综合度量。</p><ol start="2"><li>特殊的范数： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">L^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 和  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">L^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></li></ol><p>在机器学习中，最常用的范数是 ( L^2 ) 范数和 ( L^1 ) 范数。</p><h5 id="L-2-范数（欧几里得范数）">( L^2 ) 范数（欧几里得范数）</h5><p>当 ( p = 2 ) 时，范数称为<strong>欧几里得范数</strong>，其定义为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∥</mi><mi>x</mi><msub><mi mathvariant="normal">∥</mi><mn>2</mn></msub><mo>=</mo><msup><mrow><mo fence="true">(</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mi>i</mi></msub><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo fence="true">)</mo></mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></msup></mrow><annotation encoding="application/x-tex">\|x\|_2 = \left( \sum_{i=1}^{n} |x_i|^2 \right)^{\frac{1}{2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord mathnormal">x</span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.3716em;vertical-align:-1.2777em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">(</span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size4">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:2.0939em;"><span style="top:-4.5029em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>这个公式实际上就是我们在几何中常见的<strong>欧几里得距离</strong>，它表示向量 ( x ) 在 ( n )-维空间中的长度，或从原点出发到向量 ( x ) 所在点的距离。</p><ul><li><strong>应用</strong>：欧几里得范数在机器学习中十分常见，特别是在梯度下降优化、神经网络权重的正则化等问题中，它常常用于度量误差（如均方误差, Mean Squared Error, MSE）。由于其几何性质，( L^2 ) 范数可以捕捉到向量各个分量的平方和，这意味着远离零的元素对范数的贡献较大，因此 ( L^2 ) 范数对大分量更为敏感。</li></ul><h5 id="L-1-范数（曼哈顿范数）">( L^1 ) 范数（曼哈顿范数）</h5><p>当 ( p = 1 ) 时，范数称为<strong>曼哈顿范数</strong>，其定义为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∥</mi><mi>x</mi><msub><mi mathvariant="normal">∥</mi><mn>1</mn></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\|x\|_1 = \sum_{i=1}^{n} |x_i|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord mathnormal">x</span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span></span></p><p>它表示向量中每个分量的绝对值之和。( L^1 ) 范数通常用于强调稀疏性，因为它对零和非零元素之间的变化敏感，因此有助于筛选出重要的特征。</p><ul><li><strong>应用</strong>：$( L^1 ) 范数在机器学习中通常用于构建<strong>稀疏模型</strong>，例如 Lasso 回归（L1 正则化）中，它通过对系数向量施加 ( L^1 ) 正则化约束，使得某些系数变为零，从而实现特征选择和模型的稀疏化。在数据集稀疏化问题中（例如稀疏编码、稀疏矩阵分解等），( L^1 ) 范数经常用于作为正则化项，因为它能有效地引导模型忽略不重要的特征，从而得到稀疏解。</li></ul><h5 id="范数的几何解释">范数的几何解释</h5><ul><li><strong>欧几里得距离 vs 曼哈顿距离</strong>：当我们使用 ( L^2 ) 范数时，距离的几何解释是直线距离，也就是两个点之间的最短路径，这就是欧几里得距离。而使用 ( L^1 ) 范数时，距离的几何解释为“曼哈顿距离”，即在格子网格上行走时，沿水平和垂直方向移动的总距离。曼哈顿距离更注重维度之间的单独影响，而欧几里得距离更关心整体距离。</li></ul><h5 id="不同范数的选择">不同范数的选择</h5><p>选择不同的范数会对机器学习算法的效果产生不同的影响：</p><ol><li><p><strong>( L^2 ) 范数（欧几里得范数）</strong>：</p><ul><li><strong>优点</strong>：对大分量敏感，因此能够惩罚离散值。常用于机器学习中的误差度量和正则化，帮助模型更平滑。</li><li><strong>缺点</strong>：对异常值较为敏感，因为大值的平方会导致较大的影响。</li></ul></li><li><p><strong>( L^1 ) 范数（曼哈顿范数）</strong>：</p><ul><li><strong>优点</strong>：对稀疏性敏感，可以有效减少模型中不重要的特征。广泛应用于特征选择和稀疏模型中。</li><li><strong>缺点</strong>：由于只看每个分量的绝对值，对整体几何信息的捕捉不如 ( L^2 ) 范数。</li></ul></li></ol><h5 id="p-趋于无穷的-L-infty-范数">( p ) 趋于无穷的 ( L^\infty ) 范数</h5><p>当 ( p ) 趋于无穷时，( L^p ) 范数将趋向于 <strong>最大值范数</strong>，即：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∥</mi><mi>x</mi><msub><mi mathvariant="normal">∥</mi><mi mathvariant="normal">∞</mi></msub><mo>=</mo><munder><mrow><mi>max</mi><mo>⁡</mo></mrow><mi>i</mi></munder><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\|x\|_\infty = \max_i |x_i|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord mathnormal">x</span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4777em;vertical-align:-0.7277em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.4306em;"><span style="top:-2.3723em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">max</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7277em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span></span></p><p>这表示向量中最大的分量的绝对值。它专注于单一维度的极值，而忽略了其他维度的贡献。在某些优化问题中使用 ( L^\infty ) 范数可以使模型更为保守，因为它只关注最极端的误差。</p><h3 id="总结">总结</h3><p>在机器学习中，范数是用于衡量向量大小的基本工具，选择合适的范数可以帮助我们更好地控制模型的行为：</p><ul><li><strong>( L^2 ) 范数</strong> 用于度量整体的误差和距离，强调较大值的影响；</li><li><strong>( L^1 ) 范数</strong> 强调稀疏性，适合稀疏模型的构建；</li><li><strong>( L^\infty ) 范数</strong> 专注于极值，适合某些保守的优化问题。</li></ul><h3 id="loss">loss</h3><h2 id="Introduction">Introduction</h2><p>对概率的诠释有两大学派，一种是频率派另一种是贝叶斯派。后面我们对观测集采用下面记号：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>X</mi><mrow><mi>N</mi><mo>×</mo><mi>p</mi></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>x</mi><mi>N</mi></msub><msup><mo stretchy="false">)</mo><mi>T</mi></msup><mo separator="true">,</mo><msub><mi>x</mi><mi>i</mi></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>x</mi><mrow><mi>i</mi><mn>2</mn></mrow></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>x</mi><mrow><mi>i</mi><mi>p</mi></mrow></msub><msup><mo stretchy="false">)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">X_{N\times p}=(x_{1},x_{2},\cdots,x_{N})^{T},x_{i}=(x_{i1},x_{i2},\cdots,x_{ip})^{T}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1413em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1774em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>这个记号表示有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个样本，每个样本都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 维向量。其中每个观测都是由 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(x|\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span> 生成的。</p><h3 id="频率派的观点">频率派的观点</h3><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(x|\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span>中的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 是一个常量。对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个观测来说观测集的概率为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo><munder><mo><mo>=</mo></mo><mrow><mi>i</mi><mi>i</mi><mi>d</mi></mrow></munder><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><mi>p</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(X|\theta)\mathop{=}\limits _{iid}\prod\limits _{i=1}^{N}p(x_{i}|\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.506em;vertical-align:-0.9777em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3669em;"><span style="top:-2.3479em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ii</span><span class="mord mathnormal mtight">d</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">=</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7521em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5283em;"><span style="top:-2.1223em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∏</span></span></span><span style="top:-3.95em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span> 。为了求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 的大小，我们采用最大对数似然MLE的方法：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>θ</mi><mrow><mi>M</mi><mi>L</mi><mi>E</mi></mrow></msub><mo>=</mo><munder><mo><mi>a</mi><mi>r</mi><mi>g</mi><mi>m</mi><mi>a</mi><mi>x</mi></mo><mi>θ</mi></munder><mi>log</mi><mo>⁡</mo><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo><munder><mo><mo>=</mo></mo><mrow><mi>i</mi><mi>i</mi><mi>d</mi></mrow></munder><munder><mo><mi>a</mi><mi>r</mi><mi>g</mi><mi>m</mi><mi>a</mi><mi>x</mi></mo><mi>θ</mi></munder><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mi>log</mi><mo>⁡</mo><mi>p</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\theta_{MLE}=\mathop{argmax}\limits _{\theta}\log p(X|\theta)\mathop{=}\limits _{iid}\mathop{argmax}\limits _{\theta}\sum\limits _{i=1}^{N}\log p(x_{i}|\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mord mathnormal mtight">L</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.106em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.4306em;"><span style="top:-2.1535em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9465em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3669em;"><span style="top:-2.3479em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ii</span><span class="mord mathnormal mtight">d</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">=</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7521em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.4306em;"><span style="top:-2.1535em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9465em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span></span></p><h3 id="贝叶斯派的观点">贝叶斯派的观点</h3><p>贝叶斯派认为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(x|\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span> 中的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 不是一个常量。这个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 满足一个预设的先验的分布 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>∼</mo><mi>p</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\theta\sim p(\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span> 。于是根据贝叶斯定理依赖观测集参数的后验可以写成：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>θ</mi><mi mathvariant="normal">∣</mi><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>p</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>p</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><mrow><munder><mo>∫</mo><mi>θ</mi></munder><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>p</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mi>d</mi><mi>θ</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">p(\theta|X)=\frac{p(X|\theta)\cdot p(\theta)}{p(X)}=\frac{p(X|\theta)\cdot p(\theta)}{\int\limits _{\theta}p(X|\theta)\cdot p(\theta)d\theta}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.1802em;vertical-align:-1.7532em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.3044em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8056em;"><span style="top:-2.0423em;margin-left:-0.1945em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-3.0006em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op" style="margin-right:0.19445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0577em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.7532em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>为了求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 的值，我们要最大化这个参数后验MAP：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>θ</mi><mrow><mi>M</mi><mi>A</mi><mi>P</mi></mrow></msub><mo>=</mo><munder><mo><mi>a</mi><mi>r</mi><mi>g</mi><mi>m</mi><mi>a</mi><mi>x</mi></mo><mi>θ</mi></munder><mi>p</mi><mo stretchy="false">(</mo><mi>θ</mi><mi mathvariant="normal">∣</mi><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo><mi>a</mi><mi>r</mi><mi>g</mi><mi>m</mi><mi>a</mi><mi>x</mi></mo><mi>θ</mi></munder><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>p</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\theta_{MAP}=\mathop{argmax}\limits _{\theta}p(\theta|X)=\mathop{argmax}\limits _{\theta}p(X|\theta)\cdot p(\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.6965em;vertical-align:-0.9465em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.4306em;"><span style="top:-2.1535em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9465em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.6965em;vertical-align:-0.9465em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.4306em;"><span style="top:-2.1535em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9465em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span></span></p><p>其中第二个等号是由于分母和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 没有关系。求解这个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 值后计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>p</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><mrow><munder><mo>∫</mo><mi>θ</mi></munder><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>p</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mi>d</mi><mi>θ</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{p(X|\theta)\cdot p(\theta)}{\int\limits _{\theta}p(X|\theta)\cdot p(\theta)d\theta}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.1613em;vertical-align:-1.1513em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6261em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop op-limits mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8056em;"><span style="top:-1.8374em;margin-left:-0.1945em;"><span class="pstrut" style="height:2.805em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-2.8056em;"><span class="pstrut" style="height:2.805em;"></span><span><span class="mop op-symbol small-op mtight" style="margin-right:0.19445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1106em;"><span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mathnormal mtight">p</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span><span class="mord mtight">∣</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="mclose mtight">)</span><span class="mbin mtight">⋅</span><span class="mord mathnormal mtight">p</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="mclose mtight">)</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span><span class="mord mtight">∣</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="mclose mtight">)</span><span class="mbin mtight">⋅</span><span class="mord mathnormal mtight">p</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1513em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> ，就得到了参数的后验概率。其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(X|\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span> 叫似然，是我们的模型分布。得到了参数的后验分布后，我们可以将这个分布用于预测贝叶斯预测：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub><mi mathvariant="normal">∣</mi><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∫</mo><mi>θ</mi></munder><mi>p</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>p</mi><mo stretchy="false">(</mo><mi>θ</mi><mi mathvariant="normal">∣</mi><mi>X</mi><mo stretchy="false">)</mo><mi>d</mi><mi>θ</mi></mrow><annotation encoding="application/x-tex">p(x_{new}|X)=\int\limits _{\theta}p(x_{new}|\theta)\cdot p(\theta|X)d\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9744em;vertical-align:-1.6132em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3611em;"><span style="top:-1.8468em;margin-left:-0.4445em;"><span class="pstrut" style="height:3.36em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-3.3611em;"><span class="pstrut" style="height:3.36em;"></span><span><span class="mop op-symbol large-op" style="margin-right:0.44445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.6132em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span></span></p><p>其中积分中的被乘数是模型，乘数是后验分布。</p><h3 id="小结">小结</h3><p>频率派和贝叶斯派分别给出了一系列的机器学习算法。频率派的观点导出了一系列的统计机器学习算法而贝叶斯派导出了概率图理论。在应用频率派的 MLE 方法时最优化理论占有重要地位。而贝叶斯派的算法无论是后验概率的建模还是应用这个后验进行推断时积分占有重要地位。因此采样积分方法如 MCMC 有很多应用。</p><h2 id="Math">Math</h2><h3 id="先验、后验与似然概率">先验、后验与似然概率</h3><p>属于<strong>朴素贝叶斯</strong>（Naive Bayes）相关概念</p><p><strong>1、先验概率(prior probability)</strong></p><p>百度百科：先验概率（prior probability）是指<strong>根据以往经验和分析得到的概率</strong>，如全概率公式，它往往作为“由因求果”问题中的“因”出现的概率。</p><p>维基百科：在贝叶斯统计中，某一不确定量p的先验概率（prior probability）分布是<strong>在考虑“观测数据”前，能表达p不确定性的概率分布</strong>。它旨在描述这个不确定量的不确定程度，而不是这个不确定量的随机性。这个不确定量可以是一个参数，或者是一个隐含变量（英语：latent variable）。</p><p>我们可以发现这两个定义有一个共同点，即<strong>先验概率是不依靠观测数据的概率分布</strong>，也就是与其他因素独立的分布。在<a href="https://so.csdn.net/so/search?q=%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF&amp;spm=1001.2101.3001.7020">朴素贝叶斯</a>中，<strong>类别c的概率就是先验概率，表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(C)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span>。</strong></p><p><strong>2、后验概率(posterior probability)</strong></p><p>百度百科：后验概率是指<strong>在得到“结果”的信息后重新修正的概率</strong>，是“执果寻因”问题中的&quot;果&quot;。</p><p>维基百科：在贝叶斯统计中，一个随机事件或者一个不确定事件的后验概率（posterior probability）是在考虑和给出相关证据或数据后所得到的条件概率。同样，后验概率分布是一个未知量（视为随机变量）基于试验和调查后得到的概率分布。“后验”在本文中代表考虑了被测试事件的相关证据。</p><p>在朴素贝叶斯中，<strong>后验概率指给定数据x后，类别<img src="https://latex.csdn.net/eq?c%5Cin%20C" alt="cn C">的概率<img src="https://latex.csdn.net/eq?P%28c%20%7C%20x%29" alt="P(c | x)">。</strong></p><p>先验概率与后验概率有不可分割的联系，后验概率的计算要以先验概率为基础。<strong>事情还没有发生，要求这件事情发生的可能性的大小，是先验概率。事情已经发生，要求这件事情发生的原因是由某个因素引起的可能性的大小，是后验概率。</strong></p><p><strong>3、似然概率(likelihood)</strong></p><p>百度百科：统计学中，似然函数是一种关于统计模型参数的函数。<strong>给定输出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>时，关于参数<img src="https://latex.csdn.net/eq?%5Ctheta" alt="heta">的似然函数 <img src="https://latex.csdn.net/eq?L%28%5Ctheta%7Cx%29" alt="L(heta|x)">（在数值上）等于给定参数<img src="https://latex.csdn.net/eq?%5Ctheta" alt="heta">后变量X的概率：<img src="https://latex.csdn.net/eq?L%28%5Ctheta%7Cx%29%3DP%28X%3Dx%7C%5Ctheta%29" alt="L(heta|x)=P(X=x|heta)">。</strong></p><p>维基百科：在数理统计学中，似然函数（英语：likelihood function）是一种关于统计模型中的参数的函数，表示模型参数中的似然性（英语：likelihood）。</p><p>似然概率其实很好理解，就是说我们现在有一堆数据，现在需要构建一组参数对这些数据建模，以使得模型能够尽可能地拟合这些数据。所以我们要做的就是从很多组参数中选出一组使得模型对数据的拟合程度最高，所以也常常说最大似然概率。</p><p>注意“似然”与“概率”意思相近，都是指某种事件发生的可能性，但是在统计学中，“似然”和“概率”又有明确的区分：</p><ul><li><strong>“概率”描述了给定模型参数后，描述结果的合理性，而不涉及任何观察到的数据</strong></li><li><strong>“似然”描述了给定了特定观测值后，描述模型参数是否合理</strong></li></ul><p>举个栗子，抛一枚均匀的硬币，拋20次，问15次拋得正面的可能性有多大？这里的可能性就是“概率”；而拋一枚硬币，拋20次，结果15次正面向上，问其为均匀的可能性？这里的可能性就是“似然”。</p><p><strong>4、先验、后验概率与似然之间的关系</strong></p><ul><li>先验概率：<img src="https://latex.csdn.net/eq?P%20%28%20c%20%29" alt="P ( c )"></li><li>后验概率：<img src="https://latex.csdn.net/eq?P%20%28c%7Cx%29" alt="P (c|x)"></li><li>似然：<img src="https://latex.csdn.net/eq?P%28X%3Dx%7C%5Ctheta%20%3Dc%29" alt="P(X=x|heta =c)"></li></ul><p>存在的关系</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c8d6c3d64446feba7d8143d0ecc1d85c.png" alt="img"></p><p>一般而言数据X的分布是已知的，因此</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f586b7b52b252b58fe387526bdc4bc08.png" alt="img"></p><p>此外，当参数<img src="https://latex.csdn.net/eq?%5Ctheta" alt="heta">是均匀分布时，后验概率与似然概率成正比，即</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f9be3263524a33ed33ca4dec068776b2.png" alt="img"></p><h3 id="极大似然估计">极大似然估计</h3><p>考虑在一个正态分布中随机抽样，抽样出一组值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mo stretchy="false">[</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">X=[x_1,x_2,...,x_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>，这组值独立同分布，都符合某一个正态分布。此时我希望通过这组抽样出来的值（结果）反推出<strong>最有可能抽出这一组结果的原有分布</strong>（参数），这个过程即为似然。</p><p>对于这组抽样出来的值的概率，即为在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo separator="true">,</mo><mi>σ</mi></mrow><annotation encoding="application/x-tex">\mu,\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">μ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>的分布<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>μ</mi><mo separator="true">,</mo><msup><mi>σ</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N(\mu,\sigma^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathnormal">μ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>下的条件概率。由于他们是相互独立的，那么条件概率即为各个抽样值的概率的连乘：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>max</mi><mo>⁡</mo><mrow><mo fence="true">[</mo><msubsup><mo>∏</mo><mi>i</mi><mi>n</mi></msubsup><mi mathvariant="script">N</mi><mrow><mo fence="true">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>∣</mo><mi>μ</mi><mo separator="true">,</mo><mi>σ</mi><mo fence="true">)</mo></mrow><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\max \left[\prod_{i}^{n} \mathcal{N}\left(x_{i} \mid \mu, \sigma\right)\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104em;vertical-align:-0.2997em;"></span><span class="mop">max</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathcal" style="margin-right:0.14736em;">N</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">μ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span>，将其取log即为<strong>对数似然</strong>，所以极大似然估计即为通过求对数似然的最大值，来找到最合适的参数。</p><p>以线性回归举例</p><p>在给定x的情况下，因为y是不确定的，相当于给y增加了一个均值为0的高斯噪声<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>。<img src="/2024/10/07/Revisiting_ML/undefined"  alt="image-20241003001600366" style="zoom:50%;" /><img src="/2024/10/07/Revisiting_ML/undefined"  alt="image-20241003001615573" style="zoom:50%;" /></p><p>现在y的分布即为一个如图的高斯分布</p><p>在给定散点x，y的情况下，我要求线性回归模型，即求最合适的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>。这不就是对其做极大似然估计嘛？</p><p>过程如下：</p><p>有极大似然函数：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mi>i</mi></msub><mi>ln</mi><mo>⁡</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><msub><mi>y</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mi>ω</mi><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msup><mi>σ</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{i} \ln \mathcal{N}(y_i | \omega x_i, \sigma^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1138em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">ln</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathcal" style="margin-right:0.14736em;">N</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>概率密度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mi>σ</mi><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt></mrow></mfrac><msup><mi>e</mi><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mrow><mo fence="true">(</mo><mfrac><mrow><mi>x</mi><mo>−</mo><mi>μ</mi></mrow><mi>σ</mi></mfrac><mo fence="true">)</mo></mrow><mn>2</mn></msup></mrow></msup></mrow><annotation encoding="application/x-tex">f(x) = \frac{1}{\sigma \sqrt{2 \pi}} e^{-\frac{1}{2} \left( \frac{x - \mu}{\sigma} \right)^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.721em;vertical-align:-0.538em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.551em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">σ</span><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9128em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span><span style="top:-2.8728em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1272em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.538em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.183em;"><span style="top:-3.4103em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="minner mtight"><span class="minner mtight"><span class="mopen sizing reset-size3 size6 mtight delimcenter" style="top:0.075em;"><span class="mtight">(</span></span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.879em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">σ</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.4624em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">μ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mclose sizing reset-size3 size6 mtight delimcenter" style="top:0.075em;"><span class="mtight">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.1039em;"><span style="top:-3.1436em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>最终将噪声的参数部分去掉，仅留下包含w的部分，即为下图，<strong>与最小二乘法的结果完全一致</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo>−</mo><mo stretchy="false">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>−</mo><mi>ω</mi><msub><mi>x</mi><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\sum_{i=1}^{n} - (y_i - \omega x_i)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><h2 id="Model">Model</h2>]]></content>
      
      
      <categories>
          
          <category> 机器学习理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
