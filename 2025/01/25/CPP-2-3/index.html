<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++高级程序设计笔记（C2-3） | ChocStar🍫</title><meta name="author" content="Liu Kai-Qi"><meta name="copyright" content="Liu Kai-Qi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="CPP-2-3 多态   多态的定义  多态（Polymorphism）是一种面向对象程序设计的基本特性，指的是同一逻辑域中一个元素可以具有多种解释或形式。在C++中，多态有以下特点：  提升语言的灵活性：通过多态，程序可以在不修改已有代码的情况下扩展新功能。 多态在面向对象编程中实现了代码复用和扩展性，是实现动态绑定的基础。   多态在程序设计语言中的体现  PPT中提到了三种多态的形式，分别是">
<meta property="og:type" content="article">
<meta property="og:title" content="C++高级程序设计笔记（C2-3）">
<meta property="og:url" content="http://example.com/2025/01/25/CPP-2-3/index.html">
<meta property="og:site_name" content="ChocStar🍫">
<meta property="og:description" content="CPP-2-3 多态   多态的定义  多态（Polymorphism）是一种面向对象程序设计的基本特性，指的是同一逻辑域中一个元素可以具有多种解释或形式。在C++中，多态有以下特点：  提升语言的灵活性：通过多态，程序可以在不修改已有代码的情况下扩展新功能。 多态在面向对象编程中实现了代码复用和扩展性，是实现动态绑定的基础。   多态在程序设计语言中的体现  PPT中提到了三种多态的形式，分别是">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/C++.jpg">
<meta property="article:published_time" content="2025-01-25T14:10:32.000Z">
<meta property="article:modified_time" content="2025-02-05T09:29:42.320Z">
<meta property="article:author" content="Liu Kai-Qi">
<meta property="article:tag" content="C++高级程序设计">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/C++.jpg"><link rel="shortcut icon" href="/img/web_label.png"><link rel="canonical" href="http://example.com/2025/01/25/CPP-2-3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: Liu Kai-Qi","link":"链接: ","source":"来源: ChocStar🍫","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++高级程序设计笔记（C2-3）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-02-05 17:29:42'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/background.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post type-C++高级程序设计" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/C++.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">ChocStar🍫</span></a><a class="nav-page-title" href="/"><span class="site-name">C++高级程序设计笔记（C2-3）</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">C++高级程序设计笔记（C2-3）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-25T14:10:32.000Z" title="发表于 2025-01-25 22:10:32">2025-01-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-05T09:29:42.320Z" title="更新于 2025-02-05 17:29:42">2025-02-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">C++高级程序设计</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">17.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>60分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>CPP-2-3</h1>
<h2 id="多态">多态</h2>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-3/image-20241221102705367.png" class="" title="image-20241221102705367">
<ol>
<li><strong>多态的定义</strong></li>
</ol>
<p><strong>多态（Polymorphism）是一种面向对象程序设计的基本特性，指的是同一逻辑域中一个元素可以具有多种解释或形式</strong>。在C++中，多态有以下特点：</p>
<ul>
<li><strong>提升语言的灵活性</strong>：通过多态，程序可以在不修改已有代码的情况下扩展新功能。</li>
<li>多态在面向对象编程中实现了<strong>代码复用和扩展性</strong>，是实现动态绑定的基础。</li>
</ul>
<ol start="2">
<li><strong>多态在程序设计语言中的体现</strong></li>
</ol>
<p>PPT中提到了三种多态的形式，分别是：</p>
<p>（1）<strong>一名多用</strong>（函数重载）</p>
<p>这是静态多态（Compile-time Polymorphism）的一种形式：</p>
<ul>
<li>
<p>函数重载（Function Overloading）：同名函数可以根据参数的类型或数量不同而表现出不同的行为。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>根据传入的参数类型，编译器在编译时决定调用哪个函数版本。</li>
</ul>
</li>
</ul>
<p>（2）<strong>类属</strong>（模板）</p>
<p>这是另一种静态多态的实现方式：</p>
<ul>
<li>
<p>模板（Template）：C++通过模板实现通用编程，使同一段代码能够处理多种数据类型。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用模板，<code>add&lt;int&gt;</code>可以处理整数，<code>add&lt;double&gt;</code>可以处理浮点数。</li>
</ul>
</li>
</ul>
<p>（3）<strong>OO程序设计（虚函数）</strong></p>
<p>这是动态多态（Run-time Polymorphism）的形式：</p>
<ul>
<li>
<p>虚函数（Virtual Function）：C++通过虚函数和动态绑定实现运行时的多态。</p>
<ul>
<li>
<p>父类定义一个虚函数，子类可以重写（override）该函数。在运行时，通过基类指针调用函数时，会根据对象的实际类型动态决定调用哪一个函数实现。</p>
</li>
<li>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing Shape&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing Circle&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Shape* s = <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br><span class="line">s-&gt;<span class="built_in">draw</span>(); <span class="comment">// 输出 &quot;Drawing Circle&quot;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>总结</strong></p>
<p>这张PPT强调了多态作为C++语言核心特性之一的灵活性，以及它在编程中的三种主要体现：</p>
<ol>
<li><strong>静态多态</strong>（函数重载、模板）</li>
<li><strong>动态多态</strong>（虚函数） 通过这些机制，C++能够高效地支持面向对象编程和泛型编程，提升代码的复用性和可扩展性。</li>
</ol>
<h2 id="操作符重载">操作符重载</h2>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-3/image-20241221103247206.png" class="" title="image-20241221103247206">
<ol>
<li><strong>函数重载</strong></li>
</ol>
<p>定义</p>
<ul>
<li><strong>函数重载（Function Overloading）**是C++的一种静态多态（Compile-time Polymorphism），允许在同一作用域中定义多个**同名但参数列表不同</strong>的函数。</li>
<li>特点：
<ul>
<li><strong>名称相同，参数不同</strong>：函数名相同，但参数的个数、类型或顺序不同。</li>
<li><strong>静态绑定</strong>：在编译时由编译器根据调用的参数类型和数量决定调用哪个版本的函数。</li>
</ul>
</li>
</ul>
<p>实现机制</p>
<ul>
<li>
<p>编译器通过“函数签名（Function Signature）”来区分函数。</p>
<ul>
<li>函数签名包括函数名和参数列表（不包括返回值）。</li>
</ul>
</li>
<li>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span></span>;      <span class="comment">// 打印整数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> x)</span></span>;   <span class="comment">// 打印浮点数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(string x)</span></span>;   <span class="comment">// 打印字符串</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>优点</p>
<ul>
<li>提高<strong>代码可读性</strong>：同一功能的操作使用相同的名称，更加直观。</li>
<li>提高<strong>代码扩展性</strong>：通过重载扩展功能，而不需要为每种类型单独定义不同的函数名。</li>
</ul>
<ol start="2">
<li><strong>操作符重载</strong></li>
</ol>
<p>定义</p>
<ul>
<li>**操作符重载（Operator Overloading）**是C++的一种特性，允许程序员为自定义类型定义操作符（如<code>+</code>、<code>-</code>、<code>==</code>等）的行为。</li>
<li>特点：
<ul>
<li>C++中大多数内置操作符（如<code>+</code>、<code>*</code>、<code>==</code>等）可以重载，只有少数操作符（如<code>::</code>、<code>.*</code>、<code>sizeof</code>等）不能重载。</li>
<li>可以对内置类型或用户自定义类型（如类）进行操作符重载。</li>
</ul>
</li>
</ul>
<p>实现方式</p>
<ul>
<li>
<p>通过定义一个特殊的成员函数或友元函数来实现。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &quot;+&quot; 运算符</span></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; c) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;real + c.real, imag + c.imag&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>使用场景</p>
<ul>
<li><strong>扩展性</strong>：当需要对自定义类型（如类）进行操作符操作时。</li>
<li><strong>提高代码可读性</strong>：通过重载操作符，使得自定义类型的操作更贴近直观的数学逻辑。</li>
</ul>
<ol start="3">
<li><strong>编译器/链接器的处理过程</strong></li>
</ol>
<p>编译器（Compiler）</p>
<ul>
<li>编译器负责检查函数调用时的重载匹配，根据<strong>调用的参数类型和数量</strong>来决定使用哪个版本。</li>
<li>编译器会尝试寻找“最匹配”的函数（即符合参数列表的函数）。</li>
<li>如果有多个候选函数，编译器会根据如下规则选择最佳匹配：
<ul>
<li>参数顺序：参数列表的类型和顺序是否完全匹配。</li>
<li><strong>更好匹配</strong>：如果存在隐式类型转换（如<code>int</code>到<code>double</code>），编译器会选择最少类型转换的函数。</li>
<li><strong>窄转换问题（窄转换）</strong>：如果需要类型转换（如浮点数转整数），可能会导致精度损失，因此尽量避免。</li>
</ul>
</li>
</ul>
<p>链接器（Linker）</p>
<ul>
<li>如果函数的重载匹配不唯一（存在歧义），会导致链接错误。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-3/image-20241221103522031.png" class="" title="image-20241221103522031">
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-3/image-20241221103618783.png" class="" title="image-20241221103618783">
<ol>
<li><strong>背景：友元函数重载<code>+</code>操作符</strong></li>
</ol>
<p>在前一张PPT中，展示了通过<strong>成员函数</strong>重载操作符<code>+</code>的实现方式。但成员函数方式存在以下局限：</p>
<ul>
<li><strong>限制左操作数的类型</strong>：成员函数的重载要求左操作数必须是类的对象（或者能够隐式转换为类的对象）。</li>
<li><strong>灵活性不足</strong>：如果需要支持左操作数为其他类型（如内置类型），只能通过友元函数来实现。</li>
</ul>
<p>因此，这张PPT使用了<strong>友元函数</strong>重载<code>+</code>操作符。</p>
<ol start="2">
<li><strong>代码讲解</strong></li>
</ol>
<p><strong>类定义</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line">    <span class="type">double</span> real, imag;  <span class="comment">// 实部和虚部</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>() &#123; real = <span class="number">0</span>; imag = <span class="number">0</span>; &#125;                       <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i) &#123; real = r; imag = i; &#125;    <span class="comment">// 带参数构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(Complex&amp; c1, Complex&amp; c2);    <span class="comment">// 声明友元函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>friend</code>关键字声明了一个友元函数<code>operator+</code>，该函数<strong>不属于类成员</strong>，但可以访问类的私有成员。</p>
</li>
<li>
<pre><code>operator+(Complex&amp; c1, Complex&amp; c2)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ：</span><br><span class="line"></span><br><span class="line">  - 接受两个`Complex`对象作为参数。</span><br><span class="line">  - 不依赖于类对象的上下文（不是成员函数）。</span><br><span class="line">  - 可以直接访问`c1`和`c2`的私有数据成员`real`和`imag`。</span><br><span class="line"></span><br><span class="line">**友元函数定义**</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">Complex operator+(Complex&amp; c1, Complex&amp; c2) &#123;</span><br><span class="line">    Complex temp;</span><br><span class="line">    temp.real = c1.real + c2.real;  // 实部相加</span><br><span class="line">    temp.imag = c1.imag + c2.imag;  // 虚部相加</span><br><span class="line">    return temp;  // 返回结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li>
<p>在函数中，将两个<code>Complex</code>对象的实部和虚部分别相加，构造一个新的<code>Complex</code>对象并返回。</p>
</li>
<li>
<p>这是一个<strong>非成员函数</strong>，可以直接访问类的私有成员。</p>
</li>
</ul>
<p><strong>使用示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span>, c</span>;</span><br><span class="line">c = a + b;  <span class="comment">// 等价于 operator+(a, b)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当调用<code>a + b</code>时，编译器会自动调用友元函数<code>operator+</code>。</li>
<li>重载操作符的作用是让表达式更符合直观的数学表达方式。</li>
</ul>
<ol start="3">
<li><strong>友元函数的优点</strong></li>
</ol>
<ul>
<li>灵活性更高：
<ul>
<li>友元函数不需要左操作数是类的对象，这在某些场景下更加灵活。</li>
<li>例如，如果需要支持<code>Complex + double</code>这样的表达式，友元函数可以轻松扩展。</li>
</ul>
</li>
<li>访问权限：
<ul>
<li>友元函数可以直接访问类的私有成员，避免了额外的访问函数开销。</li>
</ul>
</li>
<li>非对称操作符：
<ul>
<li>对于需要非对称操作符（如<code>&lt;&lt;</code>和<code>&gt;&gt;</code>），友元函数是必不可少的实现方式。</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>与成员函数的对比</strong></li>
</ol>
<table>
<thead>
<tr>
<th><strong>特点</strong></th>
<th><strong>成员函数重载</strong></th>
<th><strong>友元函数重载</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>左操作数类型</strong></td>
<td>必须是类的对象或其派生类</td>
<td>可以是任意类型</td>
</tr>
<tr>
<td><strong>是否依赖类对象</strong></td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td><strong>访问权限</strong></td>
<td>只能通过<code>this</code>访问本类成员</td>
<td>可以直接访问所有私有/保护成员</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>左操作数是类对象的情况</td>
<td>左操作数不确定的情况</td>
</tr>
</tbody>
</table>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-3/image-20241221104059763.png" class="" title="image-20241221104059763">
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-3/image-20241221104156533.png" class="" title="image-20241221104156533">
<p><strong>1. 基本原则</strong></p>
<p><strong>(1) 重载方式</strong></p>
<ul>
<li><strong>类成员函数</strong>：
<ul>
<li>如果某个操作符是类的成员函数，则该操作符的左操作数必须是该类的对象。</li>
<li>例如，<code>operator+</code> 可以定义为类的成员函数。</li>
</ul>
</li>
<li><strong>带有类参数的全局函数</strong>：
<ul>
<li>也可以将操作符重载定义为全局函数，但需要将操作数之一声明为该类的对象。</li>
<li>通常在需要对两类不同对象进行操作时使用全局函数。</li>
<li>例如，重载 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 操作符通常需要定义为全局函数。</li>
</ul>
</li>
</ul>
<p><strong>(2) 避免歧义性</strong></p>
<ul>
<li><strong>单目/双目运算符</strong>：
<ul>
<li>一些操作符既可以用作单目操作符（如 <code>-a</code>），也可以用作双目操作符（如 <code>a - b</code>）。在重载时需要明确处理单目和双目运算。</li>
</ul>
</li>
<li><strong>优先级</strong>：
<ul>
<li>操作符的优先级是由编译器定义的，无法通过重载改变。</li>
<li>例如，<code>*</code>（乘法）操作符的优先级高于<code>+</code>（加法）。</li>
</ul>
</li>
<li><strong>结合性</strong>：
<ul>
<li>操作符的结合性（从左向右或从右向左）同样是固定的，无法通过重载改变。</li>
<li>例如，赋值操作符<code>=</code>的结合性是从右向左。</li>
</ul>
</li>
</ul>
<p><strong>2. 示例代码解释</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i) : <span class="built_in">x</span>(i) &#123;&#125;   <span class="comment">// 构造函数，初始化成员x</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; ... &#125;     <span class="comment">// 普通成员函数f</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; ... &#125;     <span class="comment">// 普通成员函数g</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>指向成员函数的指针</strong></p>
<ul>
<li>声明：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (A::*p_f)();</span><br></pre></td></tr></table></figure>
<ul>
<li>含义：
<ul>
<li><code>p_f</code> 是一个指向 <code>A</code> 类的成员函数的指针，指向的是返回值为 <code>void</code> 且无参数的成员函数。</li>
</ul>
</li>
<li>使用：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p_f = &amp;A::f;    <span class="comment">// 将指针p_f指向A类的成员函数f</span></span><br><span class="line">(a.*p_f)();     <span class="comment">// 使用成员函数指针调用对象a的成员函数f</span></span><br></pre></td></tr></table></figure>
<ul>
<li>说明：
<ul>
<li><code>.*</code> 是成员指针访问操作符，用于通过对象访问成员函数。</li>
<li>该操作符无法被重载，因此始终具有固定语法和行为。</li>
</ul>
</li>
</ul>
<h3 id="双目操作符重载">双目操作符重载</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-3/image-20241221105128911.png" class="" title="image-20241221105128911">
<p><strong>1. 双目操作符重载</strong></p>
<ul>
<li>双目操作符：
<ul>
<li>是需要两个操作数的操作符，例如 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>==</code> 等。</li>
<li>双目操作符通常是类的成员函数，用于实现类对象之间的操作逻辑。</li>
</ul>
</li>
</ul>
<p><strong>2. 格式</strong></p>
<p>重载双目操作符的成员函数格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">return</span> type&gt; <span class="keyword">operator</span>#(&lt;arg&gt;)</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong><code>operator#</code></strong>：</p>
<ul>
<li>
<p>这里的 <code>#</code> 是占位符，表示具体的操作符，例如 <code>+</code>, <code>-</code>。</p>
</li>
<li>
<p>例如，重载加法操作符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+</span><br></pre></td></tr></table></figure>
<p>时，函数声明为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; other);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong><code>&lt;arg&gt;</code></strong>：</p>
<ul>
<li>表示操作符<strong>右侧的操作数</strong>，作为函数的参数传入。</li>
<li><strong>左操作数是隐式的，表示当前对象</strong>（通过 <code>this</code> 指针访问）。</li>
</ul>
</li>
<li>
<p><strong><code>&lt;return type&gt;</code></strong>：</p>
<ul>
<li>操作符的返回值类型。</li>
<li>一般情况下，<strong>返回值是一个新的对象</strong>，表示<strong>操作符的运算结果</strong>。</li>
</ul>
</li>
</ul>
<p><strong>3. 隐式的 <code>this</code> 指针</strong></p>
<ul>
<li>
<p>在操作符重载的成员函数中，<strong>左操作数</strong>是隐式传递的，表示当前调用对象。</p>
</li>
<li>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Complex a, b;</span><br><span class="line">a + b;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>等价于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="keyword">operator</span>+(b);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.operator+(b)</span><br></pre></td></tr></table></figure>
<p>中：</p>
<ul>
<li><code>a</code> 是隐式的，通过 <code>this</code> 指针表示；</li>
<li><code>b</code> 是显式传递的参数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>4. 使用</strong></p>
<p>举例说明使用方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="title class_">name</span>&gt; a, b;</span><br><span class="line">a <span class="meta"># b;</span></span><br><span class="line">a.<span class="keyword">operator</span>#(b);</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<p>以下是一个完整的操作符重载代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r = <span class="number">0</span>, <span class="type">double</span> i = <span class="number">0</span>) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载加法操作符（双目操作符）</span></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(real + other.real, imag + other.imag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; real &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; imag &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    Complex c = a + b;  <span class="comment">// 等价于 a.operator+(b);</span></span><br><span class="line">    c.<span class="built_in">display</span>();        <span class="comment">// 输出 (4, 6)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(4, 6)</span><br></pre></td></tr></table></figure>
<p><strong>5. 总结</strong></p>
<ul>
<li>
<p>双目操作符重载</p>
<p>可以通过类的成员函数实现，格式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ret type&gt; <span class="keyword">operator</span>#(&lt;arg&gt;);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>左操作数通过 <code>this</code> 隐式传</strong>递，右操作数作为函数参数传递。</p>
</li>
<li>
<p>使用时，<code>a # b</code> 等价于 <code>a.operator#(b)</code>。</p>
</li>
<li>
<p>重载操作符可以使代码更简洁和易读，但需要遵循操作符的语义规范，避免滥用。</p>
</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-3/image-20241221105410774.png" class="" title="image-20241221105410774">
<p><strong>1. 全局函数的操作符重载</strong></p>
<ul>
<li>
<p><strong>全局函数</strong>形式的操作符重载适用于以下场景：</p>
<ul>
<li>操作符的左侧不是类的对象。</li>
<li>操作符需要访问两个或更多参数，但不需要直接访问类的私有/保护成员。</li>
</ul>
</li>
<li>
<p><strong>友元函数（<code>friend</code>）</strong></p>
<ul>
<li>
<p>如果需要让全局函数访问类的私有或保护成员，则可以将该全局函数声明为类的友元。</p>
</li>
<li>
<p>格式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> &lt;ret type&gt; <span class="keyword">operator</span># (&lt;arg1&gt;, &lt;arg2&gt;);</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>**<code>friend</code>**关键字使得全局函数可以访问类的内部成员。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r = <span class="number">0</span>, <span class="type">double</span> i = <span class="number">0</span>) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; c1, <span class="type">const</span> Complex&amp; c2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; c1, <span class="type">const</span> Complex&amp; c2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(c<span class="number">1.</span>real + c<span class="number">2.</span>real, c<span class="number">1.</span>imag + c<span class="number">2.</span>imag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>2. 格式</strong></p>
<ul>
<li>
<p>全局函数形式的操作符重载函数格式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ret type&gt; <span class="keyword">operator</span># (&lt;arg1&gt;, &lt;arg2&gt;);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>返回值类型</strong>：表示操作符的结果。</li>
<li>参数列表：
<ul>
<li>通常需要两个参数，分别表示操作符的两个操作数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>3. 为什么 <code>=</code>, <code>()</code>, <code>[]</code> 不能作为全局函数重载？</strong></p>
<p>这三种操作符具有特殊含义和行为，因此只能通过<strong>类的成员函数</strong>进行重载。</p>
<p><strong>赋值操作符 <code>=</code></strong></p>
<ul>
<li>
<p>原因：</p>
<ul>
<li>赋值操作符需要访问当前对象的所有成员以完成深拷贝、浅拷贝或其他自定义行为。</li>
<li>如果允许全局函数重载 <code>=</code>，就无法隐式访问左操作数（当前对象）的私有成员。</li>
</ul>
</li>
<li>
<p>解决方式：</p>
<ul>
<li>
<p>只能作为类的成员函数重载：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; other) &#123;</span><br><span class="line">        <span class="comment">// 实现赋值逻辑</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>函数调用操作符 <code>()</code></strong></p>
<ul>
<li>
<p>原因：</p>
<ul>
<li><code>()</code> 是用于模拟函数调用的操作符，必须与一个特定的类对象关联。</li>
<li>它通常用于创建可调用对象（如仿函数），需要访问类的成员。</li>
</ul>
</li>
<li>
<p>解决方式：</p>
<ul>
<li>
<p>只能作为类的成员函数重载：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Called with &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Callable obj;</span><br><span class="line"><span class="built_in">obj</span>(<span class="number">10</span>);  <span class="comment">// 调用 operator()</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>下标操作符 <code>[]</code></strong></p>
<ul>
<li>
<p>原因：</p>
<ul>
<li><code>[]</code> 用于访问容器或类似容器的类对象的元素。</li>
<li>需要访问类的内部数据（例如数组、指针等）。</li>
</ul>
</li>
<li>
<p>解决方式：</p>
<ul>
<li>
<p>只能作为类的成员函数重载：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line">    <span class="type">int</span> data[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Array arr;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">10</span>;  <span class="comment">// 调用 operator[]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>4. 总结</strong></p>
<ul>
<li>
<p>某些操作符（如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=</span><br></pre></td></tr></table></figure>
<p>、</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()</span><br></pre></td></tr></table></figure>
<p>、</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]</span><br></pre></td></tr></table></figure>
<p>）只能作为</p>
<p>类的成员函数</p>
<p>重载，原因是：</p>
<ul>
<li>它们<strong>必须与一个特定的类对象绑定</strong>。</li>
<li>它们需要<strong>直接访问类的私有或保护成员</strong>。</li>
</ul>
</li>
<li>
<p><strong>全局函数形式的操作符重载</strong>适用于需要<strong>访问两个或多个对象</strong>的操作符（例如 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 等），且不需要直接访问类的内部成员时。</p>
</li>
</ul>
<p><strong>PPT中 “Why?” 的解答</strong></p>
<ul>
<li>赋值操作符 <code>=</code>、函数调用操作符 <code>()</code> 和下标操作符 <code>[]</code> 之所以不能作为全局函数重载，是因为它们需要<strong>直接与类对象绑定并访问其内部成员</strong>，因此设计上只允许作为类的成员函数重载。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-3/image-20241221105729906.png" class="" title="image-20241221105729906">
<p><strong>1. 重点问题</strong></p>
<p>在C++中，操作符重载通常作为类的<strong>成员函数</strong>实现，但某些情况下需要通过<strong>全局函数</strong>进行补充，尤其是在操作符的左侧操作数不是类对象的情况。例如：</p>
<ul>
<li><strong><code>obj + 10</code></strong>：可以通过类的成员函数 <code>operator+</code> 实现，因为左侧是类对象。</li>
<li><strong><code>10 + obj</code></strong>：需要通过全局函数 <code>operator+</code> 实现，因为左侧不是类对象，成员函数无法处理这种场景。</li>
</ul>
<p><strong>2. 代码讲解</strong></p>
<p><strong>类定义</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CL</span> &#123;</span><br><span class="line">    <span class="type">int</span> count;  <span class="comment">// 类的私有成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明友元函数</span></span><br><span class="line">    <span class="keyword">friend</span> CL <span class="keyword">operator</span>+(<span class="type">int</span> i, CL&amp; a);   <span class="comment">// 用于处理 &quot;10 + obj&quot; 的情况</span></span><br><span class="line">    <span class="keyword">friend</span> CL <span class="keyword">operator</span>+(CL&amp; a, <span class="type">int</span> i);  <span class="comment">// 用于处理 &quot;obj + 10&quot; 的情况</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>成员变量 <code>count</code></strong>：<code>CL</code> 类包含一个私有成员变量 <code>count</code>，用于存储某些信息。</p>
</li>
<li>
<p>友元函数</p>
<p>：</p>
<ul>
<li>
<pre><code>friend CL operator+(int i, CL&amp; a)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ：</span><br><span class="line"></span><br><span class="line">  - 处理左操作数为整型 `int`，右操作数为 `CL` 类对象的情况（例如 `10 + obj`）。</span><br><span class="line">  - 必须声明为友元函数以访问类的私有成员。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  friend CL operator+(CL&amp; a, int i)</span><br></pre></td></tr></table></figure>

：

- 处理左操作数为 `CL` 类对象，右操作数为整型 `int` 的情况（例如 `obj + 10`）。
- 同样需要访问私有成员，因此声明为友元函数。

</code></pre>
</li>
</ul>
</li>
</ul>
<p><strong>友元函数实现</strong></p>
<p>假设类 <code>CL</code> 的成员变量 <code>count</code> 表示某种计数器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CL <span class="keyword">operator</span>+(<span class="type">int</span> i, CL&amp; a) &#123;</span><br><span class="line">    CL temp;               <span class="comment">// 创建一个新的 CL 对象</span></span><br><span class="line">    temp.count = i + a.count;  <span class="comment">// 将 int 和 CL 对象的 count 相加</span></span><br><span class="line">    <span class="keyword">return</span> temp;           <span class="comment">// 返回新对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CL <span class="keyword">operator</span>+(CL&amp; a, <span class="type">int</span> i) &#123;</span><br><span class="line">    CL temp;               <span class="comment">// 创建一个新的 CL 对象</span></span><br><span class="line">    temp.count = a.count + i;  <span class="comment">// 将 CL 对象的 count 和 int 相加</span></span><br><span class="line">    <span class="keyword">return</span> temp;           <span class="comment">// 返回新对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 实现原理</strong></p>
<ul>
<li>当<strong>操作符左侧是类对象时，C++ 会优先调用类的成员函数来进行操作符重</strong>载。</li>
<li>当<strong>左侧不是类对象（如 <code>10 + obj</code>），类的成员函数无法处理，因此需要全局函数作为补充</strong>。</li>
<li>为了让全局函数能够访问类的私有成员，通常将其声明为<strong>友元函数</strong>。</li>
</ul>
<p><strong>4. 示例解释</strong></p>
<p>以下是如何调用操作符重载的代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CL obj1, obj2;</span><br><span class="line">obj<span class="number">1.</span>count = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用成员函数实现的操作符重载</span></span><br><span class="line">obj2 = obj1 + <span class="number">10</span>;  <span class="comment">// 调用 friend CL operator+(CL&amp;, int)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用全局函数实现的操作符重载</span></span><br><span class="line">obj2 = <span class="number">10</span> + obj1;  <span class="comment">// 调用 friend CL operator+(int, CL&amp;)</span></span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<ul>
<li><strong><code>obj1 + 10</code></strong>：<code>obj1</code> 是类对象，C++ 会优先调用 <code>CL</code> 类的成员函数 <code>operator+</code> 或对应的友元函数 <code>operator+(CL&amp;, int)</code>。</li>
<li><strong><code>10 + obj1</code></strong>：左操作数 <code>10</code> 不是类对象，C++ 无法调用成员函数，因此使用全局友元函数 <code>operator+(int, CL&amp;)</code>。</li>
</ul>
<p><strong>5. 结论</strong></p>
<ul>
<li><strong>成员函数重载</strong>适用于左操作数是类对象的情况。</li>
<li><strong>全局函数重载</strong>可以<strong>补充处理左操作数不是类对象的情况</strong>（如 <code>10 + obj</code>）。</li>
<li><strong>友元声明</strong>允许全局函数访问类的私有成员，从而实现完整的操作符重载。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-3/image-20241221105953158.png" class="" title="image-20241221105953158">
<p><strong>1. 核心问题</strong></p>
<p>逻辑操作符 <code>&amp;&amp;</code> 和 <code>||</code> 是<strong>短路操作符</strong>，在C++中具有特殊的行为：</p>
<ul>
<li>
<p>短路求值：</p>
<ul>
<li>
<p>对于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp;</span><br></pre></td></tr></table></figure>
<p>：</p>
<ul>
<li>如果第一个表达式为 <code>false</code>，则整个表达式结果必然为 <code>false</code>，不再计算第二个表达式。</li>
</ul>
</li>
<li>
<p>对于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">||</span><br></pre></td></tr></table></figure>
<p>：</p>
<ul>
<li>如果第一个表达式为 <code>true</code>，则整个表达式结果必然为 <code>true</code>，不再计算第二个表达式。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>重载 <code>&amp;&amp;</code> 和 <code>||</code> 会改变这种短路行为，从而导致与直觉不符的结果。</p>
<p><strong>2. PPT中的示例解释</strong></p>
<p>示例代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p;</span><br><span class="line"><span class="keyword">if</span> ((p != <span class="number">0</span>) &amp;&amp; (<span class="built_in">strlen</span>(p) &gt; <span class="number">10</span>)) ...</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>这里</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp;</span><br></pre></td></tr></table></figure>
<p>是短路操作符：</p>
<ul>
<li>如果 <code>p != 0</code> 为 <code>false</code>，表达式立即为 <code>false</code>，不会调用 <code>strlen(p)</code>。</li>
<li>避免了潜在的运行时错误（如 <code>p</code> 为 <code>nullptr</code> 时调用 <code>strlen(p)</code> 会导致崩溃）。</li>
</ul>
</li>
</ul>
<p>重载后的行为</p>
<p>如果 <code>&amp;&amp;</code> 被重载，会变成以下形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression1 &amp;&amp; expression2) ...</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression<span class="number">1.</span><span class="keyword">operator</span>&amp;&amp;(expression2)) ...</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">operator</span>&amp;&amp;(expression1, expression2)) ...</span><br></pre></td></tr></table></figure>
<p><strong>问题：</strong></p>
<ul>
<li>重载后的逻辑操作符不会短路：
<ul>
<li>即使 <code>expression1</code> 为 <code>false</code>，<code>expression2</code> 仍然会被计算。</li>
<li>这可能导致与短路语义不一致的行为，进而引发潜在的逻辑错误或性能问题。</li>
</ul>
</li>
</ul>
<p><strong>3. 为什么不能重载</strong></p>
<ol>
<li><strong>语义破坏</strong></li>
</ol>
<p><code>&amp;&amp;</code> 和 <code>||</code> 是语言级别的操作符，其<strong>短路特性是内置的</strong>。如果重载这些操作符：</p>
<ul>
<li>表达式的语义不再直观，可能导致程序员误解或未预料的行为。</li>
</ul>
<ol start="2">
<li><strong>潜在错误</strong></li>
</ol>
<ul>
<li>如果操作数包含昂贵的计算或可能引发副作用（如函数调用），未短路的行为可能导致意外问题。</li>
</ul>
<ol start="3">
<li><strong>语言限制</strong></li>
</ol>
<p>C++ 明确规定：</p>
<ul>
<li><strong>逻辑操作符 <code>&amp;&amp;</code> 和 <code>||</code> 无法完全通过重载模仿其内置行为，因此禁止重载这些操作符。</strong></li>
</ul>
<p><strong>4. 小结</strong></p>
<ul>
<li><code>&amp;&amp;</code> 和 <code>||</code> 不允许重载的原因：
<ul>
<li>保持短路行为；</li>
<li>避免语义破坏；</li>
<li>防止性能和逻辑错误。</li>
</ul>
</li>
<li>C++ 的操作符重载机制允许我们重载大多数操作符，但对某些关键操作符（如 <code>&amp;&amp;</code>、<code>||</code>、<code>.</code>、<code>.*</code>、<code>::</code>、<code>sizeof</code>）进行了限制，以确保代码的可读性和一致性。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-3/image-20241221110156566.png" class="" title="image-20241221110156566">
<p><strong>1. 类定义的核心</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">int</span>, <span class="type">int</span>);  <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; r) <span class="type">const</span>;  <span class="comment">// 重载乘法操作符</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, d;  <span class="comment">// 分子和分母</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>数据成员：
<ul>
<li><code>n</code>：分子。</li>
<li><code>d</code>：分母。</li>
</ul>
</li>
<li>重载的乘法操作符：
<ul>
<li>函数声明中，返回值是<code>const Rational&amp;</code>，表示返回的结果是一个<code>Rational</code>类的引用，且这个引用是只读的（不可修改）。</li>
<li>参数是一个常量引用<code>const Rational&amp; r</code>，提高了传参效率，避免了值传递导致的拷贝。</li>
<li><code>const</code> 修饰函数，表明操作符不会修改当前对象的状态。</li>
</ul>
</li>
</ul>
<p><strong>2. 操作符<code>*</code>的多种实现方式</strong></p>
<p>PPT中列出了几种实现乘法操作符的方法，每种方式都对应不同的性能和安全性特点：</p>
<p><strong>实现方式 1：直接返回临时对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">Rational</span>(n * r.n, d * r.d);</span><br></pre></td></tr></table></figure>
<ul>
<li>优点：
<ul>
<li>简单易懂，效率较高。</li>
<li>不涉及动态分配内存，临时对象会在栈上创建，作用域结束后自动销毁。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>返回的是一个临时对象的引用，而临时对象在函数调用结束后就会被销毁，导致悬空引用（Dangling Reference）。</li>
<li>如<code>const Rational&amp; operator*()</code>返回引用，调用者可能操作失效的内存。</li>
</ul>
</li>
</ul>
<p><strong>实现方式 2：动态分配内存</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rational *result = <span class="keyword">new</span> <span class="built_in">Rational</span>(n * r.n, d * r.d);</span><br><span class="line"><span class="keyword">return</span> *result;</span><br></pre></td></tr></table></figure>
<ul>
<li>优点：
<ul>
<li>返回的是一个有效的对象，避免了悬空引用问题。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>内存泄漏风险：调用者需要显式删除返回的对象，如果忘记<code>delete</code>，会导致内存泄漏。</li>
<li>动态分配的性能开销较大，效率低于栈上分配。</li>
</ul>
</li>
</ul>
<p><strong>实现方式 3：返回静态对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Rational result;</span><br><span class="line">result.n = n * r.n;</span><br><span class="line">result.d = d * r.d;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<ul>
<li>优点：
<ul>
<li>避免了动态内存分配，性能较高。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>使用静态对象可能导致线程不安全问题。</li>
<li>每次调用操作符时会覆盖静态对象的值，这意味着返回的结果在下一次调用时可能被修改，无法应用于复杂计算。</li>
</ul>
</li>
</ul>
<p><strong>3. PPT中的重要提示</strong></p>
<p><strong>绿色框的建议</strong></p>
<ul>
<li>
<p>提出一个重要的编程原则：</p>
<blockquote>
<p>尽可能让事情有效率，但不要过度有效率。</p>
</blockquote>
<ul>
<li>过度优化可能会带来复杂性和安全问题（如悬空引用、内存泄漏等）。</li>
<li>编写代码时，应优先保证代码的安全性和易维护性，在此基础上再考虑优化。</li>
</ul>
</li>
</ul>
<p><strong>复杂表达式的潜在问题</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w = x * y * z;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果操作符<code>*</code>返回的是引用，会导致重复使用同一个对象（如静态对象）或操作失效的内存，结果不可靠。</li>
</ul>
<p><strong>4. 总结与建议</strong></p>
<p><strong>选择返回值的方式</strong></p>
<ol>
<li>
<p><strong>返回值推荐</strong>：</p>
<ul>
<li>
<p>操作符重载通常返回一个值（按值传递，而不是引用），例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; r) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>(n * r.n, d * r.d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>确保返回的对象在调用结束后仍然有效。</li>
<li>编译器会优化返回值拷贝（通过返回值优化 RVO 技术）。</li>
</ul>
</li>
<li>
<p>返回引用（如<code>const Rational&amp;</code>）仅适用于<strong>已有的成员对象</strong>，不适用于返回临时对象。</p>
</li>
</ul>
</li>
<li>
<p><strong>使用动态内存需谨慎</strong>：</p>
<ul>
<li>如果需要返回动态分配的对象，应明确调用者的职责（如<code>delete</code>操作）。</li>
<li>一般情况下，避免使用动态分配对象，除非有非常明确的需求。</li>
</ul>
</li>
</ol>
<p><strong>5. 操作符<code>*</code>的正确实现示例</strong></p>
<p>以下是推荐的实现方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">int</span> n, <span class="type">int</span> d) : <span class="built_in">n</span>(n), <span class="built_in">d</span>(d) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按值返回</span></span><br><span class="line">    Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; r) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Rational</span>(n * r.n, d * r.d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此实现避免了悬空引用、内存泄漏和线程安全问题，同时效率较高且易于理解。</p>
<h3 id="单目操作符重载">单目操作符重载</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-3/image-20241221111041350.png" class="" title="image-20241221111041350">
<p><strong>1. 单目操作符的重载</strong></p>
<p>单目操作符</p>
<ul>
<li>单目操作符是只作用于一个操作数的操作符，例如：<code>+</code>（正号）、<code>-</code>（负号）、<code>*</code>（解引用）、<code>&amp;</code>（取地址）、<code>!</code>（逻辑非）、<code>~</code>（按位取反）、<code>++</code>（前置自增）、<code>--</code>（前置自减）等。</li>
</ul>
<p>重载的方式</p>
<p>单目操作符可以通过以下两种方式重载：</p>
<ol>
<li><strong>类成员函数</strong>形式</li>
<li><strong>全局函数</strong>形式</li>
</ol>
<p><strong>2. 类成员函数重载单目操作符</strong></p>
<p>特点</p>
<ul>
<li>成员函数形式的单目操作符重载<strong>隐含一个<code>this</code>指针</strong>，因为成员函数本质上总是作用于调用该操作符的对象。</li>
<li>重载的函数只需要一个参数，即操作符本身的对象实例。</li>
</ul>
<p>格式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ret_type&gt; <span class="keyword">operator</span>#();</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>ret_type</code></strong>：操作符重载函数的返回值类型。可以是一个值、引用或指针，取决于操作符的实际需求。</li>
<li><strong><code>operator#</code></strong>：<code>#</code>是占位符，实际使用时需要替换成具体的操作符（如<code>+</code>、<code>-</code>等）。</li>
<li><strong>参数</strong>：对于单目操作符重载，成员函数<strong>不需要额外的参数</strong>，因为操作的对象是隐式的，即调用该函数的对象。</li>
</ul>
<p>示例代码</p>
<p>以下是单目操作符<code>-</code>（取负号）的重载示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Number</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载单目操作符-</span></span><br><span class="line">    Number <span class="keyword">operator</span>-() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(-value); <span class="comment">// 返回一个取反后的新对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>用法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Number <span class="title">n</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">Number m = -n;  <span class="comment">// 调用重载的operator-()</span></span><br><span class="line">std::cout &lt;&lt; m.<span class="built_in">getValue</span>(); <span class="comment">// 输出 -5</span></span><br></pre></td></tr></table></figure>
<p>总结</p>
<ul>
<li>类成员函数形式更适用于操作符直接作用于类的私有数据（如上述<code>value</code>）。</li>
<li>隐式使用<code>this</code>指针，语法简洁。</li>
</ul>
<p><strong>3. 全局函数重载单目操作符</strong></p>
<p>特点</p>
<ul>
<li>全局函数形式的重载操作符需要显式指定操作数。</li>
<li><strong>操作符作用的对象需要通过参数传递，而不是隐式的<code>this</code></strong>。</li>
</ul>
<p>格式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ret_type&gt; <span class="keyword">operator</span>#(&lt;arg&gt;);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>ret_type</code></strong>：操作符重载函数的返回值类型。</li>
<li><strong><code>#</code></strong>：占位符，表示实际的操作符。</li>
<li><strong><code>&lt;arg&gt;</code></strong>：单目操作符重载时需要一个参数，即操作的对象。</li>
</ul>
<p>示例代码</p>
<p>以下是重载取负号操作符的全局函数版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Number</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元函数</span></span><br><span class="line">    <span class="keyword">friend</span> Number <span class="keyword">operator</span>-(<span class="type">const</span> Number&amp; n);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义全局重载函数</span></span><br><span class="line">Number <span class="keyword">operator</span>-(<span class="type">const</span> Number&amp; n) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>(-n.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>用法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Number <span class="title">n</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">Number m = -n;  <span class="comment">// 调用全局重载的operator-()</span></span><br><span class="line">std::cout &lt;&lt; m.<span class="built_in">getValue</span>(); <span class="comment">// 输出 -5</span></span><br></pre></td></tr></table></figure>
<p><strong>4. 类成员函数与全局函数的选择</strong></p>
<p>类成员函数适合的情况</p>
<ul>
<li>操作符直接作用于类的成员数据（如<code>value</code>）。</li>
<li>不需要跨多个类使用操作符时。</li>
</ul>
<p>全局函数适合的情况</p>
<ul>
<li>操作符涉及多个类或非类类型（如<code>int</code>、<code>double</code>等）之间的运算。</li>
<li>需要访问类的私有或保护成员时，可以通过将全局函数声明为类的友元函数实现。</li>
</ul>
<p>比较</p>
<table>
<thead>
<tr>
<th>特点</th>
<th>类成员函数</th>
<th>全局函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>调用对象</td>
<td>隐式调用，使用<code>this</code></td>
<td>显式调用，通过参数传递</td>
</tr>
<tr>
<td>参数数量</td>
<td>无额外参数</td>
<td>至少需要一个参数</td>
</tr>
<tr>
<td>使用复杂性</td>
<td>操作符仅与类数据关联时较简单</td>
<td>需要访问多个类或外部数据时较简单</td>
</tr>
</tbody>
</table>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-3/image-20241221111332091.png" class="" title="image-20241221111332091">
<p><strong>1. 前置自增（<code>++a</code>）</strong></p>
<p>特点：</p>
<ul>
<li><strong>操作符位置</strong>：写在变量前面，例如：<code>++a</code>。</li>
<li><strong>返回值</strong>：前置自增操作符返回变量自身的引用（左值引用），以便支持链式操作（如<code>+++a</code>）。</li>
<li><strong>行为</strong>：在执行操作时，变量的值会先增加，然后再返回增加后的变量。</li>
</ul>
<p>实现方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Counter&amp; <span class="keyword">operator</span>++() <span class="comment">// 前置自增</span></span><br><span class="line">&#123;</span><br><span class="line">    value++;          <span class="comment">// 增加成员变量的值</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;     <span class="comment">// 返回当前对象自身的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Counter a;</span><br><span class="line">++a; <span class="comment">// 调用前置自增</span></span><br></pre></td></tr></table></figure>
<p>适用场景：</p>
<ul>
<li>当需要链式调用时，例如<code>+++a</code>。</li>
<li>需要高效操作，因为不需要生成额外的临时对象。</li>
</ul>
<p><strong>2. 后置自增（<code>a++</code>）</strong></p>
<p>特点：</p>
<ul>
<li><strong>操作符位置</strong>：写在变量后面，例如：<code>a++</code>。</li>
<li><strong>返回值</strong>：后置自增操作符返回变量的值（未增加前）的副本。</li>
<li><strong>行为</strong>：在执行操作时，变量的值会先被保存到一个临时对象中，然后变量本身的值增加，最后返回临时对象。</li>
</ul>
<p>实现方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Counter <span class="keyword">operator</span>++(<span class="type">int</span>) <span class="comment">// 后置自增</span></span><br><span class="line">&#123;</span><br><span class="line">    Counter temp = *<span class="keyword">this</span>; <span class="comment">// 保存当前对象</span></span><br><span class="line">    value++;              <span class="comment">// 增加成员变量的值</span></span><br><span class="line">    <span class="keyword">return</span> temp;          <span class="comment">// 返回原始值的副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：这里的<code>int</code>参数是一个哑参数（dummy argument），并没有实际意义，它只是用来区分前置和后置版本。</p>
</blockquote>
<p>使用示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Counter a;</span><br><span class="line">a++; <span class="comment">// 调用后置自增</span></span><br></pre></td></tr></table></figure>
<p>适用场景：</p>
<ul>
<li>当需要保存变量增加前的状态，例如在循环中记录或处理操作前的值。</li>
</ul>
<p><strong>3. 前置自增与后置自增的区别</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>前置自增（<code>++a</code>）</th>
<th>后置自增（<code>a++</code>）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>返回值</strong></td>
<td>返回增加后的变量（引用）。</td>
<td>返回增加前的变量（副本）。</td>
</tr>
<tr>
<td><strong>效率</strong></td>
<td>更高效，不需要创建临时对象。</td>
<td>较低效，需要创建并返回一个临时对象。</td>
</tr>
<tr>
<td><strong>用途</strong></td>
<td>用于高效操作，适合链式调用（如<code>+++a</code>）。</td>
<td>用于需要操作前值的场景。</td>
</tr>
<tr>
<td><strong>实现</strong></td>
<td>没有额外参数，只是操作当前对象。</td>
<td>带有一个哑参数<code>int</code>用于区分后置操作。</td>
</tr>
</tbody>
</table>
<p><strong>4. 代码解析</strong></p>
<p>定义的类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Counter</span>() &#123; value = <span class="number">0</span>; &#125; <span class="comment">// 默认构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置自增操作符</span></span><br><span class="line">    Counter&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        value++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回自身引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置自增操作符</span></span><br><span class="line">    Counter <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">        Counter temp = *<span class="keyword">this</span>; <span class="comment">// 保存当前对象到临时变量</span></span><br><span class="line">        value++;              <span class="comment">// 增加当前对象的值</span></span><br><span class="line">        <span class="keyword">return</span> temp;          <span class="comment">// 返回保存的临时变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>5. 总结</strong></p>
<ul>
<li>**前置自增（<code>++a</code>）**效率高，适合需要链式操作的场景，因为它直接返回对象自身，不生成临时副本。</li>
<li>**后置自增（<code>a++</code>）**适合需要操作之前值的场景，但因为需要生成一个副本对象，效率较低。</li>
<li>哑参数<code>int</code>是<strong>后置版本的标志</strong>，前置版本则没有参数。</li>
</ul>
<h3 id="特殊操作符重载">特殊操作符重载</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-3/image-20241221111609105.png" class="" title="image-20241221111609105">
<p><strong>1. 默认赋值操作符重载函数</strong></p>
<p>C++中的赋值操作符<code>=</code>在没有明确重载时，编译器会自动为类生成一个<strong>默认赋值操作符</strong>。该默认操作符具有以下特点：</p>
<p><strong>1.1 默认行为</strong></p>
<ul>
<li>成员赋值（member-wise assignment）：
<ul>
<li>对于类的每个非静态成员，默认赋值操作符会调用它们的赋值操作符。</li>
<li>如果成员是基础类型（如<code>int</code>、<code>float</code>等），直接按值赋值。</li>
<li>如果成员是对象，则递归调用该对象的赋值操作符。</li>
</ul>
</li>
</ul>
<p><strong>1.2 递归调用</strong></p>
<ul>
<li>如果类中包含成员对象，则默认赋值操作符会递归调用成员对象的赋值操作符，直至完成所有成员的赋值。这种递归行为保证了成员对象之间的赋值是正确且完整的。</li>
</ul>
<p><strong>2. 为什么赋值操作符重载不能继承？</strong></p>
<p>PPT中的问题是：<strong>为什么赋值操作符重载不能继承？</strong></p>
<p><strong>原因分析</strong></p>
<ol>
<li><strong>赋值操作符是类特定的：</strong>
<ul>
<li>赋值操作符的实现高度依赖于类的成员变量的类型和数量。</li>
<li>派生类的成员变量和基类可能完全不同，因此基类的赋值操作符对于派生类来说通常不适用。</li>
</ul>
</li>
<li><strong>派生类需要自定义赋值逻辑：</strong>
<ul>
<li>派生类可能有额外的成员变量，或者需要特定的赋值逻辑。</li>
<li>如果派生类直接使用基类的赋值操作符，会导致派生类特定的成员变量无法正确赋值。</li>
</ul>
</li>
<li><strong>覆盖的语义问题：</strong>
<ul>
<li>如果基类提供了一个赋值操作符，而派生类没有定义自己的赋值操作符，那么<strong>派生类会自动生成一个默认的赋值操作符，而不是继承基类的赋值操作符</strong>。</li>
<li>这避免了错误的赋值行为（如只处理基类部分的成员）。</li>
</ul>
</li>
<li><strong>遵循C++的默认规则：</strong>
<ul>
<li>C++中，<strong>特殊成员函数</strong>（包括<strong>拷贝构造函数、移动构造函数、析构函数和赋值操作符等）默认是为每个类单独生成的，不会被继承</strong>。</li>
<li>这是为了让每个类都有一组与自身成员匹配的特殊成员函数，而不是直接复用基类的实现。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<p>赋值操作符重载不能继承的核心原因在于：</p>
<ul>
<li><strong>派生类通常有不同的成员变量和赋值逻辑</strong>。</li>
<li><strong>为保证正确性和语义一致性，C++默认为每个类单独生成赋值操作符，而不是继承基类的实现</strong>。</li>
</ul>
<p><strong>3. 自定义赋值操作符重载</strong></p>
<p>当默认赋值操作符无法满足需求时，可以手动重载赋值操作符：</p>
<p><strong>实现方式</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 防止自赋值</span></span><br><span class="line">        x = other.x; <span class="comment">// 按成员赋值</span></span><br><span class="line">        y = other.y;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回当前对象的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong></p>
<ol>
<li><strong>防止自赋值（Self-assignment）</strong>：
<ul>
<li>当<code>this == &amp;other</code>时，直接返回<code>*this</code>，防止不必要的操作。</li>
</ul>
</li>
<li><strong>返回当前对象的引用</strong>：
<ul>
<li>返回<code>*this</code>可以支持链式操作，例如：<code>a = b = c;</code></li>
</ul>
</li>
</ol>
<p><strong>4. 总结</strong></p>
<ul>
<li>默认赋值操作符：
<ul>
<li>是编译器生成的特殊成员函数，支持递归调用成员变量的赋值操作符。</li>
</ul>
</li>
<li>不能继承赋值操作符：
<ul>
<li>基于类成员的不同需求，<strong>派生类需要单独定义自己的赋值操作符</strong>。</li>
</ul>
</li>
<li>重载赋值操作符：
<ul>
<li>必要时，可以手动实现赋值操作符重载，以满足特殊需求，并保证安全性（防止自赋值）。</li>
</ul>
</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-3/image-20241221112239567.png" class="" title="image-20241221112239567">
<p>这张PPT讲解了赋值操作符（<code>=</code>）重载中的一个经典问题：<strong>浅拷贝与深拷贝的内存管理问题</strong>。</p>
<p><strong>代码含义解析</strong></p>
<p>类定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">char</span> *p; <span class="comment">// 动态分配的字符串指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span> *s):<span class="built_in">x</span>(i), <span class="built_in">y</span>(j) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s) + <span class="number">1</span>]; <span class="comment">// 动态分配内存存储字符串</span></span><br><span class="line">        <span class="built_in">strcpy</span>(p, s);               <span class="comment">// 拷贝字符串内容到动态内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] p;                 <span class="comment">// 析构时释放动态内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    A&amp; <span class="keyword">operator</span> = (A&amp; a) &#123;</span><br><span class="line">        x = a.x;                    <span class="comment">// 直接拷贝基本类型</span></span><br><span class="line">        y = a.y;</span><br><span class="line">        <span class="keyword">delete</span>[] p;                 <span class="comment">// 释放当前对象已有的动态内存，防止内存泄漏</span></span><br><span class="line">        p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(a.p) + <span class="number">1</span>]; <span class="comment">// 为新值重新分配动态内存</span></span><br><span class="line">        <span class="built_in">strcpy</span>(p, a.p);             <span class="comment">// 拷贝新字符串</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;               <span class="comment">// 返回当前对象，支持链式赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>赋值操作逻辑</strong></p>
<ol>
<li><strong>基本类型的拷贝：</strong>
<ul>
<li>成员变量<code>x</code>和<code>y</code>直接赋值，因为它们是基本类型，不涉及动态内存管理。</li>
</ul>
</li>
<li><strong>动态内存管理：</strong>
<ul>
<li>赋值前，通过<code>delete[] p;</code>释放当前对象已有的动态内存，防止内存泄漏。</li>
<li>为被赋值的对象的动态字符串重新分配内存：<code>new char[strlen(a.p) + 1]</code>。</li>
<li>将赋值对象的字符串内容拷贝到新分配的内存中：<code>strcpy(p, a.p);</code>。</li>
</ul>
</li>
<li><strong>返回值：</strong>
<ul>
<li>返回<code>*this</code>，以支持链式赋值（如<code>a = b = c</code>）。</li>
</ul>
</li>
</ol>
<p><strong>构造函数和析构函数</strong></p>
<ul>
<li>构造函数为动态字符串分配内存。</li>
<li>析构函数在对象销毁时释放内存，避免内存泄漏。</li>
</ul>
<p><strong>PPT中的问题分析</strong></p>
<p><strong>问题1：idle pointer（悬空指针）</strong></p>
<ul>
<li>当<strong>没有重载赋值操作符时，编译器提供的默认赋值操作符会对指针成员<code>p</code>进行浅拷贝</strong>。</li>
<li>浅拷贝导致两个对象<code>a</code>和<code>b</code>的<code>p</code>指向同一片内存。</li>
<li>若一个对象析构时释放了这片内存，另一个对象的<code>p</code>变成悬空指针（指向已释放的内存）。</li>
</ul>
<p><strong>问题2：Memory leak（内存泄漏）</strong></p>
<ul>
<li>在赋值操作中，若没有释放当前对象已有的动态内存（即缺少<code>delete[] p</code>），就会导致内存泄漏。</li>
<li>每次重新分配内存时，旧的内存都丢失，无法释放。</li>
</ul>
<p><strong>赋值操作符重载的必要性</strong></p>
<ul>
<li>动态内存管理是重载赋值操作符的核心原因。若使用默认的赋值操作符（浅拷贝），将引发严重的内存问题：
<ol>
<li><strong>悬空指针问题</strong></li>
<li><strong>内存泄漏问题</strong></li>
</ol>
</li>
</ul>
<p>通过重载赋值操作符，可以实现<strong>深拷贝</strong>，从而正确管理动态内存，避免上述问题。</p>
<p><strong>代码的改进点</strong></p>
<ol>
<li>防止自赋值</li>
</ol>
<p>当前代码没有处理<strong>自赋值问题</strong>（如<code>a = a</code>），这可能导致释放<code>p</code>后再访问已经释放的内存。</p>
<p>改进代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;a) &#123; <span class="comment">// 检查是否为自赋值</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = a.x;</span><br><span class="line">    y = a.y;</span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(a.p) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(p, a.p);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>拷贝构造函数</li>
</ol>
<p>除了赋值操作符，动态内存管理的类通常需要提供<strong>拷贝构造函数</strong>，以便正确初始化对象的动态成员。</p>
<p>实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">A</span>(<span class="type">const</span> A&amp; a) &#123;</span><br><span class="line">    x = a.x;</span><br><span class="line">    y = a.y;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(a.p) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(p, a.p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li><strong>赋值操作符重载的必要性：</strong>
<ul>
<li>默认赋值操作符会导致悬空指针和内存泄漏问题。</li>
<li>通过重载赋值操作符，可以实现深拷贝，正确管理动态内存。</li>
</ul>
</li>
<li><strong>关键注意点：</strong>
<ul>
<li>释放当前内存（<code>delete[] p;</code>）防止内存泄漏。</li>
<li>防止自赋值（<code>if (this == &amp;a)</code>）。</li>
<li>返回<code>*this</code>以支持链式赋值。</li>
</ul>
</li>
<li><strong>最佳实践：</strong>
<ul>
<li>为动态内存管理的类提供<strong>拷贝构造函数</strong>、<strong>赋值操作符重载</strong>和<strong>析构函数</strong>，以遵循<strong>三法则（Rule of Three）</strong>。</li>
</ul>
</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-3/image-20241221113507128.png" class="" title="image-20241221113507128">
<p><strong>避免自我赋值</strong></p>
<p>在重载赋值操作符时，如果不检查是否为自我赋值，可能会导致逻辑错误或程序崩溃。以下是常见问题及其影响：</p>
<ol>
<li>
<p><strong>自我赋值的定义</strong>：</p>
<ul>
<li>赋值操作的左值和右值是同一个对象，例如 <code>s = s;</code>。</li>
</ul>
</li>
<li>
<p><strong>问题举例</strong>：</p>
<ul>
<li>假设赋值操作符先释放当前对象的资源（如释放内存），然后将右值的资源拷贝到左值。如果是自我赋值，资源一旦被释放，后续操作将试图访问已释放的资源，导致未定义行为。</li>
</ul>
</li>
<li>
<p><strong>解决方案</strong>： 在赋值操作符中添加自我赋值检测，典型实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;a) &#123;  <span class="comment">// 检查是否为自我赋值</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行赋值操作</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>示例：<code>class string</code></strong>：</p>
<ul>
<li><code>class string</code> 是一个典型示例。如果字符串的内存管理未正确处理自我赋值，可能会导致释放原有数据后丢失当前数据。</li>
</ul>
</li>
</ol>
<p><strong>对象标识（Object Identity）</strong></p>
<p>对象标识用于区别两个对象是否为同一个实例，而不仅仅是内容相等。对象标识可以从以下几个维度理解：</p>
<ol>
<li>
<p><strong>Content（内容）</strong>：</p>
<ul>
<li>比较对象的实际数据。例如，对于两个字符串对象，比较它们的内容是否相等。</li>
</ul>
</li>
<li>
<p><strong>Same Memory Location（内存地址）</strong>：</p>
<ul>
<li>比较两个对象是否占用同一片内存，通常通过指针地址来判断。如果两个对象的内存地址相同，说明它们是同一个实例。</li>
</ul>
</li>
<li>
<p><strong>Object Identifier（对象标识符）</strong>：</p>
<ul>
<li>
<p><code>identity()</code> 是一个示例方法，返回对象的唯一标识符，可以是内存地址，也可以是其他唯一标识。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A *p1, *p2;</span><br><span class="line"><span class="keyword">if</span> (p1-&gt;<span class="built_in">identity</span>() == p2-&gt;<span class="built_in">identity</span>()) &#123;</span><br><span class="line">    <span class="comment">// p1 和 p2 指向同一个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p><strong>关键代码解析</strong></p>
<p><strong>代码示例 1：避免自我赋值</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(A &amp;a1, A &amp;a2)</span> </span>&#123;</span><br><span class="line">    a1 = a2; <span class="comment">// 赋值不同对象，正常执行</span></span><br><span class="line">    a1 = a1; <span class="comment">// 赋值给自己，可能会出错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>解决方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;a) &#123; <span class="comment">// 检查是否是自我赋值</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他赋值逻辑</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>代码示例 2：对象标识</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ObjectID <span class="title">identity</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ...; <span class="comment">// 返回对象的唯一标识符，例如内存地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">A *p1, *p2;</span><br><span class="line"><span class="keyword">if</span> (p1-&gt;<span class="built_in">identity</span>() == p2-&gt;<span class="built_in">identity</span>()) &#123;</span><br><span class="line">    <span class="comment">// p1 和 p2 指向同一对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>identity()</code> 的返回值通常是内存地址，使用 <code>this</code> 指针实现。</li>
</ul>
<p><strong>总结</strong></p>
<ol>
<li><strong>自我赋值检查的重要性：</strong>
<ul>
<li>防止赋值操作中出现逻辑错误或未定义行为，尤其是涉及资源释放和重新分配的情况。</li>
</ul>
</li>
<li><strong>对象标识（Object Identity）的作用：</strong>
<ul>
<li>区分对象实例是否为同一对象，通常通过内存地址或唯一标识符实现。</li>
</ul>
</li>
<li><strong>最佳实践：</strong>
<ul>
<li>在赋值操作符中始终添加自我赋值检测。</li>
<li>为动态资源管理类实现 <code>identity()</code> 方法，以便识别和比较对象实例。</li>
</ul>
</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-3/image-20241221114135827.png" class="" title="image-20241221114135827">
<p><strong>代码解析</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p; <span class="comment">// 动态分配的字符串数据存储</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数：动态分配存储空间，并复制字符串数据</span></span><br><span class="line">    <span class="built_in">string</span>(<span class="type">char</span> *p1) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(p1) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(p, p1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 [] 操作符，适用于非常量对象，返回引用（可修改）</span></span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 [] 操作符，适用于常量对象，返回值（不可修改）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数：释放动态分配的内存</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">string</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>关键点解析</strong></p>
<ol>
<li>
<p><strong>为什么需要两个版本的 <code>[]</code> 操作符</strong>：</p>
<ul>
<li>
<p><strong>非常量版本（非 <code>const</code>）</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回一个引用，允许通过下标修改字符串内容。</li>
<li>适用于非常量对象（如 <code>string s(&quot;aacd&quot;);</code>）。</li>
<li>使用方式：<code>s[2] = 'b';</code>。</li>
</ul>
</li>
<li>
<p><strong>常量版本（<code>const</code>）</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回一个值，禁止修改。</li>
<li>适用于常量对象（如 <code>const string cs(&quot;const&quot;);</code>）。</li>
<li>使用方式：<code>cout &lt;&lt; cs[0];</code>。</li>
</ul>
</li>
<li>
<p>通过 <code>const</code> 区分两种场景，编译器会根据上下文选择正确的重载版本。</p>
</li>
</ul>
</li>
<li>
<p><strong>动态内存管理</strong>：</p>
<ul>
<li>构造函数中为字符串动态分配内存。</li>
<li>析构函数中释放动态分配的内存，防止内存泄漏。</li>
</ul>
</li>
</ol>
<p><strong>测试用例解析</strong></p>
<p><strong>测试 1：非常量对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;aacd&quot;</span>)</span></span>;</span><br><span class="line">s[<span class="number">2</span>] = <span class="string">&#x27;b&#x27;</span>; <span class="comment">// 调用非常量版本的 operator[]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>执行过程：
<ul>
<li>调用非常量版本的 <code>operator[]</code>，返回对 <code>p[2]</code> 的引用。</li>
<li>修改 <code>p[2]</code> 为 <code>'b'</code>。</li>
</ul>
</li>
<li>结果：
<ul>
<li><code>s</code> 的内容变为 <code>&quot;aabd&quot;</code>。</li>
</ul>
</li>
</ul>
<p><strong>测试 2：常量对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> string <span class="title">cs</span><span class="params">(<span class="string">&quot;const&quot;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; cs[<span class="number">0</span>];  <span class="comment">// 调用常量版本的 operator[]</span></span><br><span class="line">cs[<span class="number">0</span>] = <span class="string">&#x27;D&#x27;</span>;    <span class="comment">// 不允许，编译报错</span></span><br></pre></td></tr></table></figure>
<ul>
<li>执行过程：
<ul>
<li><code>cout &lt;&lt; cs[0];</code> 调用常量版本的 <code>operator[]</code>，返回 <code>p[0]</code> 的值（<code>'c'</code>）。</li>
<li><code>cs[0] = 'D';</code> 不允许修改，因为 <code>cs</code> 是常量对象，只能调用常量版本的 <code>operator[]</code>，而常量版本返回值不是引用，无法修改。</li>
</ul>
</li>
<li>结果：
<ul>
<li>输出为 <code>'c'</code>。</li>
<li><code>cs[0] = 'D';</code> 编译错误。</li>
</ul>
</li>
</ul>
<p><strong>注意事项</strong></p>
<ol>
<li><strong>重载时的<code>const</code>区分</strong>：
<ul>
<li>对于类的重载函数，<code>const</code> 修饰符用于区分常量对象和非常量对象的行为。</li>
<li>如果没有常量版本的重载，常量对象调用 <code>operator[]</code> 会报错。</li>
</ul>
</li>
<li><strong>安全性</strong>：
<ul>
<li>使用 <code>[]</code> 操作符访问字符串时，没有越界检查，可能导致未定义行为。</li>
<li>在实际开发中，可以添加越界检查逻辑。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<ol>
<li><strong>双版本 <code>[]</code> 操作符</strong>：
<ul>
<li>非常量对象使用的版本返回引用，可修改。</li>
<li>常量对象使用的版本返回值，不可修改。</li>
</ul>
</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-3/image-20241221114501328.png" class="" title="image-20241221114501328">
<p>这张PPT讨论了C++中通过操作符重载实现二维数组的模拟，主要内容涉及如何通过<code>operator[]</code>重载实现对二维数组的访问语法</p>
<p><strong>代码解析</strong></p>
<p><strong>class Array2D</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array2D</span> &#123;</span><br><span class="line">    <span class="type">int</span> n1, n2; <span class="comment">// 分别代表二维数组的行数和列数</span></span><br><span class="line">    <span class="type">int</span> *p;     <span class="comment">// 一维指针，用于存储二维数组的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Array2D</span>(<span class="type">int</span> l, <span class="type">int</span> c) : <span class="built_in">n1</span>(l), <span class="built_in">n2</span>(c) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="type">int</span>[n1 * n2]; <span class="comment">// 分配一维数组空间，用于存储 n1 行 n2 列的二维数组</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Array2D</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] p; <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现二维数组访问的第一层：返回指向第 i 行的指针</span></span><br><span class="line">    <span class="type">int</span> *<span class="keyword">operator</span>[](<span class="type">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">return</span> p + i * n2; <span class="comment">// 第 i 行的起始地址</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过方法实现数据访问</span></span><br><span class="line">    <span class="function"><span class="type">int</span> &amp;<span class="title">getElem</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p[i * n2 + j]; <span class="comment">// 返回二维数组中第 i 行第 j 列的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>如何使用？</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Array2D <span class="title">data</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>; <span class="comment">// 创建 2 行 3 列的二维数组</span></span><br><span class="line">data[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">0</span>;     <span class="comment">// 使用重载的 [] 访问二维数组第 1 行第 2 列</span></span><br><span class="line">data.<span class="built_in">getElem</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 通过 getElem 方法实现相同访问</span></span><br></pre></td></tr></table></figure>
<ul>
<li>访问过程：
<ul>
<li><code>data[1]</code> 调用 <code>Array2D</code> 中重载的 <code>operator[]</code>，返回指向第 1 行首元素的指针。</li>
<li><code>data[1][2]</code> 解引用得到第 1 行第 2 列的元素。</li>
</ul>
</li>
</ul>
<p><strong>PPT中关键点解析</strong></p>
<ol>
<li>
<p><strong>动态分配的内存结构</strong>：</p>
<ul>
<li>通过 <code>new int[n1 * n2]</code> 分配了连续的一维数组。</li>
<li>数组的布局是按行存储的，<code>p[i * n2 + j]</code> 表示第 i 行第 j 列的元素。</li>
</ul>
</li>
<li>
<p><strong>操作符重载的语义</strong>：</p>
<ul>
<li><strong>第一层 <code>operator[]</code></strong>： 返回指向第 <code>i</code> 行首元素的指针：<code>p + i * n2</code>。</li>
<li><strong>第二层 <code>operator[]</code>（隐含）</strong>： 对一维指针的下标操作，返回对应列的元素。</li>
</ul>
</li>
<li>
<p><strong>数据存储方式</strong>：</p>
<ul>
<li>
<p>数据在内存中是线性存储的，二维数组通过索引计算找到对应的元素地址。</p>
</li>
<li>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="number">1</span>][<span class="number">2</span>] =&gt; *(p + <span class="number">1</span> * n2 + <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>期望语法</strong>：</p>
<ul>
<li><code>data[1][2]</code> 是类似二维数组的访问方式。</li>
<li>实际等价于：<code>data.operator .operator </code>。</li>
</ul>
</li>
<li>
<p><strong>对比 <code>getElem</code> 方法</strong>：</p>
<ul>
<li><code>getElem(i, j)</code> 和 <code>data[i][j]</code> 实现了相同的功能。</li>
<li>使用重载的 <code>operator[]</code> 提供了更直观的数组访问方式。</li>
</ul>
</li>
</ol>
<p><strong>补充内容：实现多维数组的思路</strong></p>
<p>如果需要模拟更高维的数组（例如三维数组），可以扩展 <code>operator[]</code>，例如：</p>
<ul>
<li>将 <code>operator[]</code> 返回自定义类型（如二维数组的行）。</li>
<li>为返回的类型再实现 <code>operator[]</code>。</li>
</ul>
<p><strong>PPT中图解说明</strong></p>
<ol>
<li>
<p><strong>对象内存布局</strong>：</p>
<ul>
<li><code>p</code> 是一维指针，指向实际数据存储区域。</li>
<li>数据存储顺序按行展开，连续存储。</li>
</ul>
</li>
<li>
<p><strong>重载 <code>[]</code> 的访问逻辑</strong>：</p>
<ul>
<li>
<p><code>data[1]</code> 返回第 1 行的起始地址。</p>
</li>
<li>
<pre><code>data[1][2]
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      实现为：</span><br><span class="line"></span><br><span class="line">     - `data.operator ` 返回 `p + i * n2`。</span><br><span class="line">     - `p[i * n2 + j]` 是对应的二维数组元素。</span><br><span class="line"></span><br><span class="line">3. **通过重载实现类似多维数组的语法**：</span><br><span class="line"></span><br><span class="line">   - `data[i][j]` 提供了更加直观和简洁的使用方式，隐藏了数组存储的实现细节。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20241221114836998](CPP-2-3/image-20241221114836998.png)</span><br><span class="line"></span><br><span class="line">**背景与目的**</span><br><span class="line"></span><br><span class="line">- **目标**：实现对二维数组的仿真，通过重载`operator[]`，实现类似原生二维数组的访问方式。</span><br><span class="line">- **问题**：直接重载`operator[]`只能返回一维数组的首地址，不能实现链式调用（`data[i][j]`）。</span><br><span class="line">- **解决方法**：使用代理类（proxy class），间接处理多维数组的访问。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">**代码解析**</span><br><span class="line"></span><br><span class="line">**代理类：`Array1D`**</span><br><span class="line"></span><br><span class="line">`Array1D`是一个代理类，专门为`Array2D`提供一维数组的接口：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">class Array1D &#123;</span><br><span class="line">public:</span><br><span class="line">    // 构造函数：接受一个指向一维数组首地址的指针</span><br><span class="line">    Array1D(int *p) &#123; this-&gt;p = p; &#125;</span><br><span class="line"></span><br><span class="line">    // 重载 operator[]，实现一维数组访问</span><br><span class="line">    int &amp;operator[](int index) &#123; return p[index]; &#125;         // 可修改元素</span><br><span class="line">    const int operator[](int index) const &#123; return p[index]; &#125; // 只读元素</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int *p; // 指向一维数组的起始地址</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ol>
<p><strong>关键点</strong>：</p>
<ul>
<li>核心功能：
<ul>
<li><code>Array1D</code>接受一个指向数组的指针<code>p</code>。</li>
<li>通过重载<code>operator[]</code>，实现对一维数组中任意位置的访问。</li>
</ul>
</li>
<li>访问逻辑：
<ul>
<li>例如：<code>data[1]</code>返回的是一个<code>Array1D</code>对象。</li>
<li><code>data[1][2]</code>先调用<code>Array2D</code>的<code>operator[]</code>返回<code>Array1D</code>，然后调用<code>Array1D</code>的<code>operator[]</code>返回元素。</li>
</ul>
</li>
</ul>
<p><strong>二维数组类：<code>Array2D</code></strong></p>
<p><code>Array2D</code>实现了二维数组的存储和操作逻辑：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array2D</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数：分配内存</span></span><br><span class="line">    <span class="built_in">Array2D</span>(<span class="type">int</span> n1, <span class="type">int</span> n2) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="type">int</span>[n1 * n2]; <span class="comment">// 一维存储</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;num1 = n1;      <span class="comment">// 行数</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;num2 = n2;      <span class="comment">// 列数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数：释放内存</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Array2D</span>() &#123; <span class="keyword">delete</span>[] p; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 operator[]：返回代理类 Array1D</span></span><br><span class="line">    Array1D <span class="keyword">operator</span>[](<span class="type">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array1D</span>(p + index * num2); <span class="comment">// 第 index 行的首地址</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常量版本的 operator[]，用于只读</span></span><br><span class="line">    <span class="type">const</span> Array1D <span class="keyword">operator</span>[](<span class="type">int</span> index) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array1D</span>(p + index * num2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *p;     <span class="comment">// 一维指针，存储二维数组的数据</span></span><br><span class="line">    <span class="type">int</span> num1;   <span class="comment">// 行数</span></span><br><span class="line">    <span class="type">int</span> num2;   <span class="comment">// 列数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>关键点</strong>：</p>
<ol>
<li>
<p><strong>存储结构</strong>：</p>
<ul>
<li>数据存储在一维数组<code>p</code>中，按行优先顺序存储。</li>
<li>第<code>i</code>行的首地址是<code>p + i * num2</code>。</li>
</ul>
</li>
<li>
<p><strong>访问逻辑</strong>：</p>
<ul>
<li>
<p><code>data[i]</code>返回一个<code>Array1D</code>对象，代表第<code>i</code>行。</p>
</li>
<li>
<pre><code>data[i][j]
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     通过链式调用：</span><br><span class="line"></span><br><span class="line">     - `data[i]`调用`Array2D::operator[]`。</span><br><span class="line">     - `[j]`调用`Array1D::operator[]`。</span><br><span class="line"></span><br><span class="line">3. **内存管理**：</span><br><span class="line"></span><br><span class="line">   - 使用`new`动态分配内存，析构函数中使用`delete[]`释放。</span><br><span class="line"></span><br><span class="line">**调用示例**</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">Array2D data(2, 3);   // 创建 2x3 的二维数组</span><br><span class="line">data[0][0] = 1;       // 通过代理类设置第 0 行第 0 列元素</span><br><span class="line">data[1][2] = 5;       // 设置第 1 行第 2 列元素</span><br><span class="line">int x = data[1][2];   // 获取第 1 行第 2 列元素</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>调用过程</strong>：</p>
<ul>
<li><code>data[1]</code>调用<code>Array2D::operator[]</code>，返回第 1 行的代理类<code>Array1D</code>。</li>
<li><code>data[1][2]</code>调用<code>Array1D::operator[]</code>，访问第 1 行第 2 列的元素。</li>
</ul>
</li>
<li>
<p><strong>内存布局</strong>：</p>
<ul>
<li>
<p>数据在内存中是连续存储的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p[0], p[1], p[2], ..., p[n1*n2-1]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p><strong>PPT中的关键术语</strong></p>
<ol>
<li><strong><code>proxy class</code>（代理类）</strong>：
<ul>
<li><code>Array1D</code>作为代理类，为每一行提供访问接口。</li>
<li>将二维数组的复杂逻辑拆分为简单的一维数组操作。</li>
</ul>
</li>
<li><strong><code>Surrogate</code>（代理/替代）</strong>：
<ul>
<li><code>Array1D</code>替代了原生一维数组指针，简化了访问逻辑。</li>
</ul>
</li>
<li><strong>多维访问</strong>：
<ul>
<li>通过<code>Array1D</code>实现多维数组的访问，而无需直接操作底层数据。</li>
</ul>
</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-3/image-20241221184931276.png" class="" title="image-20241221184931276">
<p><strong>左侧代码解析：函数调用操作符 <code>()</code> 重载</strong></p>
<p><strong>代码概述</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Func</span> &#123;</span><br><span class="line">    <span class="type">double</span> para;</span><br><span class="line">    <span class="type">int</span> lowerBound, upperBound;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span>, <span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p><strong>函数调用操作符重载</strong>：</p>
<ul>
<li>通过重载 <code>operator()</code>，类对象可以像函数一样被调用。</li>
<li>定义：
<ul>
<li><code>double operator()(double, int, int)</code> 表示此操作符接受 3 个参数（<code>double</code>、<code>int</code>、<code>int</code>），返回一个 <code>double</code> 类型的值。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>调用方式</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Func f;         <span class="comment">// 定义一个函数对象</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">2.4</span>, <span class="number">0</span>, <span class="number">8</span>);   <span class="comment">// 通过函数调用操作符调用对象 f，传入 3 个参数</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>f</code> 是一个 <code>Func</code> 类型的对象。</li>
<li><code>f(2.4, 0, 8)</code> 实际上会调用 <code>f.operator()(2.4, 0, 8)</code>。</li>
</ul>
</li>
</ol>
<p><strong>用途</strong></p>
<ul>
<li><strong>函数对象</strong>：
<ul>
<li>可以将类对象作为函数使用，方便存储和调用复杂逻辑。</li>
<li>常见于标准库中的 STL 算法，例如自定义的比较器或筛选器。</li>
</ul>
</li>
<li><strong>封装逻辑</strong>：
<ul>
<li>操作符重载可以将复杂逻辑封装到类中，提高代码的复用性和可读性。</li>
</ul>
</li>
</ul>
<p><strong>右侧代码解析：二维数组访问</strong></p>
<p><strong>代码概述</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array2D</span> &#123;</span><br><span class="line">    <span class="type">int</span> n1, n2; <span class="comment">// n1: 行数，n2: 列数</span></span><br><span class="line">    <span class="type">int</span> *p;     <span class="comment">// 存储数据的一维数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array2D</span>(<span class="type">int</span> l, <span class="type">int</span> c): <span class="built_in">n1</span>(l), <span class="built_in">n2</span>(c) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="type">int</span>[n1 * n2]; <span class="comment">// 动态分配内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Array2D</span>() &#123; <span class="keyword">delete</span>[] p; &#125; <span class="comment">// 析构函数，释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span>&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (p + i * n2)[j]; <span class="comment">// 返回第 i 行第 j 列的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p><strong>内存布局</strong>：</p>
<ul>
<li>
<p>数组数据存储在一维数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p</span><br></pre></td></tr></table></figure>
<p>中，采用行优先存储的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p[0], p[1], ..., p[n2-1]     (第 0 行)</span><br><span class="line">p[n2], ..., p[2*n2-1]        (第 1 行)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对于第 <code>i</code> 行第 <code>j</code> 列的数据，其内存地址为 <code>p + i * n2 + j</code>。</p>
</li>
</ul>
</li>
<li>
<p><strong>操作符 <code>()</code> 重载</strong>：</p>
<ul>
<li>
<p>重载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operator()</span><br></pre></td></tr></table></figure>
<p>，实现类似二维数组的访问方式：</p>
<ul>
<li><code>data(i, j)</code> 会被翻译为 <code>data.operator()(i, j)</code>。</li>
</ul>
</li>
<li>
<p>返回值是二维数组中具体元素的引用。</p>
</li>
</ul>
</li>
<li>
<p><strong>析构函数</strong>：</p>
<ul>
<li>使用 <code>new</code> 动态分配内存后，需通过析构函数 <code>delete[] p</code> 释放内存，防止内存泄漏。</li>
</ul>
</li>
</ol>
<p><strong>调用方式</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Array2D <span class="title">data</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>; <span class="comment">// 创建 2 行 3 列的二维数组</span></span><br><span class="line"><span class="built_in">data</span>(<span class="number">0</span>, <span class="number">1</span>) = <span class="number">10</span>;    <span class="comment">// 设置第 0 行第 1 列的值为 10</span></span><br><span class="line"><span class="type">int</span> x = <span class="built_in">data</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 获取第 1 行第 2 列的值</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data(0, 1)</span><br></pre></td></tr></table></figure>
<p>时：</p>
<ul>
<li><code>operator()(0, 1)</code> 被调用，返回 <code>(p + 0 * n2)[1]</code> 的引用，即 <code>p[1]</code>。</li>
<li>因为返回的是引用，所以可以直接修改该元素。</li>
</ul>
</li>
</ul>
<p><strong>PPT中的要点总结</strong></p>
<ol>
<li><strong>左侧内容：函数调用操作符重载</strong>
<ul>
<li>通过重载 <code>operator()</code>，可以让类对象像函数一样被调用。</li>
<li>常用于实现函数对象（functor），在 STL 算法中应用广泛。</li>
</ul>
</li>
<li><strong>右侧内容：二维数组访问</strong>
<ul>
<li>重载 <code>operator()</code> 实现仿真二维数组。</li>
<li>类似原生二维数组访问方式，但底层使用一维数组存储。</li>
<li>提高代码可读性，方便操作和管理多维数据。</li>
</ul>
</li>
</ol>
<h3 id="类型转换运算符">类型转换运算符</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-3/image-20241221185151391.png" class="" title="image-20241221185151391">
<p><strong>类型转换操作符概述</strong></p>
<ul>
<li>
<p>类型转换操作符允许将自定义类对象转换为其他类型（通常是基本数据类型，如 <code>int</code>、<code>double</code> 等）。</p>
</li>
<li>
<p>语法格式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>type</code> 是目标类型，例如 <code>int</code> 或 <code>double</code>。</li>
<li>返回值是将对象转换为目标类型的结果。</li>
</ul>
</li>
</ul>
<p><strong>代码实现：Rational 类</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">int</span> n1, <span class="type">int</span> n2) &#123; n = n1; d = n2; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (<span class="type">double</span>)n / d; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, d; <span class="comment">// n: 分子, d: 分母</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>构造函数</strong>：
<ul>
<li><code>Rational(int n1, int n2)</code>：接受两个整数参数 <code>n1</code> 和 <code>n2</code>，分别表示分子和分母。</li>
</ul>
</li>
<li><strong>类型转换操作符</strong>：
<ul>
<li><code>operator double()</code>：将 <code>Rational</code> 对象转换为 <code>double</code> 类型。</li>
<li>返回值是 <code>n / d</code> 的浮点数值。</li>
</ul>
</li>
</ol>
<p><strong>调用示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">r</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;   <span class="comment">// 创建一个分数对象，分子为 1，分母为 2</span></span><br><span class="line"><span class="type">double</span> x = r;       <span class="comment">// 隐式调用 operator double，将 r 转换为 double</span></span><br><span class="line">x = x + r;          <span class="comment">// 在混合运算中再次调用 operator double</span></span><br></pre></td></tr></table></figure>
<ol>
<li><strong><code>double x = r;</code></strong>：
<ul>
<li>隐式调用 <code>operator double()</code>，将 <code>Rational</code> 对象 <code>r</code> 转换为 <code>double</code>。</li>
<li>结果是 <code>x = 0.5</code>。</li>
</ul>
</li>
<li><strong><code>x = x + r;</code></strong>：
<ul>
<li><code>x</code> 是 <code>double</code> 类型，<code>r</code> 是 <code>Rational</code> 类型。</li>
<li>在运算时，<code>r</code> 会隐式调用 <code>operator double()</code>，先转换为 <code>double</code> 类型，然后参与计算。</li>
</ul>
</li>
</ol>
<p><strong>代码的核心思想</strong></p>
<ol>
<li>
<p><strong>减少操作符重载的数量</strong>：</p>
<ul>
<li>
<p>PPT提到：<strong>“减少混合计算中需要定义的操作符重载函数的数量”</strong>。</p>
</li>
<li>
<p>通过类型转换操作符，将复杂的操作转化为简单的基本数据类型操作。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x = r + <span class="number">1.5</span>; <span class="comment">// 转换 r 为 double，简化计算</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果不使用类型转换操作符，则需要为 <code>Rational</code> 和 <code>double</code> 的每种运算符（如 <code>+</code>、<code>-</code>）都单独定义重载函数，导致代码复杂性增加。</p>
</li>
</ul>
</li>
<li>
<p><strong>适用于数值类型的类设计</strong>：</p>
<ul>
<li><code>operator double()</code> 的设计使得 <code>Rational</code> 类可以无缝参与数值计算。</li>
<li>可以通过定义多个类型转换操作符（如 <code>operator int()</code>），实现与不同类型的数据的兼容。</li>
</ul>
</li>
</ol>
<p><strong>PPT右侧的例子</strong></p>
<ol>
<li>
<p><strong><code>ostream</code> 和 <code>if</code> 判断</strong>：</p>
<ul>
<li>
<p>示例中提到了 <code>ostream</code> 和条件语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (f) ...</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>这是因为 C++ 标准库中的某些类（如 <code>std::ifstream</code> 或 <code>std::ofstream</code>）定义了类型转换操作符，将类对象转换为布尔值以支持条件判断。</p>
</li>
<li>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (file) &#123;  <span class="comment">// 隐式转换为布尔值，表示文件是否成功打开</span></span><br><span class="line">    <span class="comment">// 处理文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>自定义类型和基本数据类型的兼容性</strong>：</p>
<ul>
<li>
<p>通过定义类型转换操作符，允许自定义类型像基本类型一样被使用。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">r</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> x = r;   <span class="comment">// 隐式转换为 double</span></span><br><span class="line"><span class="keyword">if</span> (r &gt; <span class="number">0.5</span>) &#123;  <span class="comment">// 隐式转换后与 double 比较</span></span><br><span class="line">    <span class="comment">// 逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-3/image-20241221190209596.png" class="" title="image-20241221190209596">
<p><strong>核心内容与概念</strong></p>
<ol>
<li><strong><code>-&gt;</code> 是一个二元运算符（binary operator）</strong>
<ul>
<li>常用于指针访问对象的成员，例如：<code>ptr-&gt;member</code>。</li>
<li>在自定义类中，可以通过重载<code>operator-&gt;</code>来控制类的指针行为。</li>
<li>重载时返回值必须是<strong>指针类型</strong>，或能够递归调用返回指针的对象。</li>
</ul>
</li>
<li><strong>智能指针中的应用</strong>
<ul>
<li>智能指针（如<code>std::shared_ptr</code>、<code>std::unique_ptr</code>）通常通过重载<code>-&gt;</code>，让用户以普通指针的方式访问封装的对象。</li>
<li>例如：<code>smart_ptr-&gt;member</code>。</li>
</ul>
</li>
</ol>
<p><strong>代码分析</strong></p>
<p><strong><code>CPen</code>类</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPen</span> &#123;</span><br><span class="line">    <span class="type">int</span> m_color;</span><br><span class="line">    <span class="type">int</span> m_width;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setColor</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123; m_color = c; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_width; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>成员变量</strong>：
<ul>
<li><code>m_color</code>：记录颜色。</li>
<li><code>m_width</code>：记录宽度。</li>
</ul>
</li>
<li><strong>方法</strong>：
<ul>
<li><code>setColor(int c)</code>：设置颜色。</li>
<li><code>getWidth()</code>：获取宽度。</li>
</ul>
</li>
</ol>
<p><strong><code>CPanel</code>类</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPanel</span> &#123;</span><br><span class="line">    CPen m_pen;</span><br><span class="line">    <span class="type">int</span> m_bkColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CPen* <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> &amp;m_pen; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setBkColor</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123; m_bkColor = c; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p><strong>成员变量</strong>：</p>
<ul>
<li><code>m_pen</code>：一个<code>CPen</code>对象。</li>
<li><code>m_bkColor</code>：背景颜色。</li>
</ul>
</li>
<li>
<p><strong>方法</strong>：</p>
<ul>
<li>
<p>重载了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operator-&gt;</span><br></pre></td></tr></table></figure>
<p>：</p>
<ul>
<li>返回<code>m_pen</code>对象的地址（<code>CPen*</code>类型）。</li>
<li>让用户可以通过<code>CPanel</code>类直接访问<code>CPen</code>对象的成员。</li>
</ul>
</li>
<li>
<pre><code>setBkColor(int c)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     ：</span><br><span class="line"></span><br><span class="line">     - 设置背景颜色。</span><br><span class="line"></span><br><span class="line">**关键知识点**</span><br><span class="line"></span><br><span class="line">**1. 重载`operator-&gt;`**</span><br><span class="line"></span><br><span class="line">- 语法：</span><br><span class="line"></span><br><span class="line">  ```cpp</span><br><span class="line">  返回类型 operator-&gt;();</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ol>
<ul>
<li>
<p>必须返回指针类型，或者递归调用最终返回指针。</p>
</li>
<li>
<p>用法：</p>
<ul>
<li>允许用户通过重载的对象直接访问指针对象的成员，如<code>panel-&gt;getWidth()</code>。</li>
</ul>
</li>
<li>
<p>注意：</p>
<ul>
<li>递归调用时，如<code>a-&gt;b-&gt;c</code>，每一步都要求返回值能继续调用<code>-&gt;</code>。</li>
</ul>
</li>
</ul>
<p><strong>2. 调用流程</strong></p>
<p>通过以下代码演示调用流程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CPanel c;</span><br><span class="line">c-&gt;<span class="built_in">setColor</span>(<span class="number">16</span>); <span class="comment">// 等效于 c.operator-&gt;()-&gt;setColor(16);</span></span><br><span class="line">c-&gt;<span class="built_in">getWidth</span>();   <span class="comment">// 等效于 c.operator-&gt;()-&gt;getWidth();</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>c-&gt;setColor(16)</code>：
<ol>
<li><code>c</code>调用重载的<code>operator-&gt;</code>，返回<code>CPen*</code>类型指针。</li>
<li>然后通过返回的指针调用<code>CPen</code>类的<code>setColor</code>方法，设置颜色为<code>16</code>。</li>
</ol>
</li>
<li><code>c-&gt;getWidth()</code>：
<ol>
<li>类似调用，先返回<code>CPen*</code>指针。</li>
<li>再调用<code>CPen</code>的<code>getWidth</code>方法，返回宽度。</li>
</ol>
</li>
</ul>
<p><strong>3. 智能指针模拟</strong></p>
<p>智能指针的实现通常会用到<code>operator-&gt;</code>重载，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line">    Object* ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Object* <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> ptr; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这使得智能指针对象可以像普通指针一样操作其内部对象。</p>
<p><strong>代码示例中的重要细节</strong></p>
<p><strong>调用递归行为</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="keyword">operator</span>-&gt;()-&gt;<span class="keyword">operator</span>-&gt;()-&gt;<span class="built_in">f</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>每次调用<code>operator-&gt;</code>返回值都会再调用<code>operator-&gt;</code>，直到返回一个指针。</li>
<li>类似递归过程，最终访问目标成员。</li>
</ul>
<p><strong>返回值必须是指针类型</strong></p>
<ul>
<li>在C++标准中规定，<code>-&gt;</code>重载必须返回指针类型，否则会编译错误。</li>
<li>这是为了保证成员访问的连贯性。</li>
</ul>
<p><strong>右侧注释与提问</strong></p>
<ul>
<li>必须返回指针类型？
<ul>
<li>因为<code>-&gt;</code>运算符的语义要求返回一个可以直接解引用的对象地址。</li>
</ul>
</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-3/image-20241221190509006.png" class="" title="image-20241221190509006">
<p><strong>1. 背景问题</strong></p>
<p>在C++中，动态分配内存时，使用<code>new</code>创建对象后需要显式调用<code>delete</code>释放内存。若开发者忘记<code>delete</code>对象，或者程序中存在异常导致<code>delete</code>未被调用，就会引发<strong>内存泄漏（Memory Leak）</strong>。</p>
<p>示例中涉及的类<code>A</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">(<span class="type">char</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>A</code>是一个普通的类，包含一些成员函数，但如果动态分配<code>A</code>的对象（<code>new A</code>），需要手动释放。</p>
<p><strong>2. 动态内存分配的问题</strong></p>
<p>在<code>void test()</code>函数中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A* p = <span class="keyword">new</span> A;</span><br><span class="line">p-&gt;<span class="built_in">f</span>();</span><br><span class="line">p-&gt;<span class="built_in">g</span>(<span class="number">1.1</span>);</span><br><span class="line">p-&gt;<span class="built_in">h</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure>
<p>如果在执行<code>p-&gt;f()</code>、<code>p-&gt;g()</code>等操作期间，发生异常或者忘记写<code>delete p;</code>，会导致动态分配的<code>A</code>对象没有释放，从而造成内存泄漏。</p>
<p><strong>3. 解决方案：封装动态分配对象</strong></p>
<p>使用封装类<code>AWrapper</code>，将动态分配的对象封装起来，利用析构函数自动释放内存，从而避免泄漏。</p>
<p><strong>AWrapper类设计</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AWrapper</span> &#123;</span><br><span class="line">    A* p; <span class="comment">// 指向动态分配的A对象</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AWrapper</span>(A* p) &#123; <span class="keyword">this</span>-&gt;p = p; &#125; <span class="comment">// 构造函数，接受一个指针</span></span><br><span class="line">    ~<span class="built_in">AWrapper</span>() &#123; <span class="keyword">delete</span> p; &#125;      <span class="comment">// 析构函数，自动释放内存</span></span><br><span class="line">    A* <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> p; &#125;  <span class="comment">// 重载-&gt;，支持直接访问A的成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>成员变量：
<ul>
<li><code>A* p</code>：保存动态分配的<code>A</code>对象的指针。</li>
</ul>
</li>
<li>构造函数：
<ul>
<li><code>AWrapper(A* p)</code>：初始化封装类，保存动态分配的指针。</li>
</ul>
</li>
<li>析构函数：
<ul>
<li><code>~AWrapper()</code>：在<code>AWrapper</code>对象生命周期结束时自动调用<code>delete</code>释放内存。</li>
</ul>
</li>
<li>运算符重载：
<ul>
<li><code>A* operator-&gt;()</code>：重载<code>-&gt;</code>运算符，使得<code>AWrapper</code>类能够像指针一样访问<code>A</code>对象的成员。</li>
</ul>
</li>
</ul>
<p><strong>4. 使用封装类AWrapper</strong></p>
<p>修改后的<code>test()</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">AWrapper <span class="title">p</span><span class="params">(<span class="keyword">new</span> A)</span></span>; <span class="comment">// 使用AWrapper封装动态分配的A对象</span></span><br><span class="line">    p-&gt;<span class="built_in">f</span>();            <span class="comment">// 调用A的成员函数f()</span></span><br><span class="line">    p-&gt;<span class="built_in">g</span>(<span class="number">1.1</span>);         <span class="comment">// 调用A的成员函数g(double)</span></span><br><span class="line">    p-&gt;<span class="built_in">h</span>(<span class="string">&#x27;A&#x27;</span>);         <span class="comment">// 调用A的成员函数h(char)</span></span><br><span class="line">&#125; <span class="comment">// 自动调用~AWrapper()，释放动态分配的内存</span></span><br></pre></td></tr></table></figure>
<p><strong>优点</strong></p>
<ol>
<li>自动释放内存：
<ul>
<li><code>AWrapper</code>的析构函数负责释放<code>A</code>对象的内存。</li>
<li>避免了手动调用<code>delete</code>的错误，防止内存泄漏。</li>
</ul>
</li>
<li>兼容指针语法：
<ul>
<li>通过<code>operator-&gt;</code>的重载，用户仍然可以使用<code>p-&gt;f()</code>的形式调用<code>A</code>的成员函数。</li>
</ul>
</li>
<li>安全性增强：
<ul>
<li>即使在<code>test()</code>函数中抛出异常，<code>AWrapper</code>对象析构时也会自动释放内存。</li>
</ul>
</li>
</ol>
<p><strong>注意事项</strong></p>
<ul>
<li><code>AWrapper</code>类只能封装一个动态分配的<code>A</code>对象，如果需要管理多个对象或资源，建议使用<strong>标准智能指针</strong>。</li>
</ul>
<p><strong>5. 与智能指针的对比</strong></p>
<p>标准库中已有智能指针（如<code>std::unique_ptr</code>和<code>std::shared_ptr</code>），功能类似<code>AWrapper</code>，但更通用、更安全。</p>
<p><strong>改用<code>std::unique_ptr</code>的示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;A&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> A)</span></span>; <span class="comment">// 使用unique_ptr封装动态分配的A对象</span></span><br><span class="line">    p-&gt;<span class="built_in">f</span>();</span><br><span class="line">    p-&gt;<span class="built_in">g</span>(<span class="number">1.1</span>);</span><br><span class="line">    p-&gt;<span class="built_in">h</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">&#125; <span class="comment">// unique_ptr自动释放内存</span></span><br></pre></td></tr></table></figure>
<ul>
<li>优势：
<ul>
<li>标准实现，测试充分。</li>
<li>支持深拷贝、移动语义。</li>
<li>可用于复杂资源管理。</li>
</ul>
</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-3/image-20241221191041959.png" class="" title="image-20241221191041959">
<p><strong>1. 背景与问题</strong></p>
<ul>
<li>默认行为：
<ul>
<li>在C++中，<code>new</code> 和 <code>delete</code> 运算符会直接调用系统的内存管理函数（如 <code>malloc</code> 和 <code>free</code>），用于申请和释放内存。</li>
<li>问题：
<ul>
<li><strong>频繁调用系统内存管理函数</strong> 会增加开销，降低程序性能，尤其是在高频分配/释放内存的场景。</li>
</ul>
</li>
</ul>
</li>
<li>需求：
<ul>
<li>对内存管理进行优化，通过 <strong>自定义内存分配策略</strong> 来提升效率。</li>
<li>实现特定场景下更灵活的内存管理机制。</li>
</ul>
</li>
</ul>
<p><strong>2. 解决方案</strong></p>
<p>通过<strong>重载 <code>new</code> 和 <code>delete</code> 运算符</strong>实现自定义内存管理。包括：</p>
<ul>
<li>重载<code>new</code>：
<ul>
<li>控制内存分配过程。</li>
<li>可申请更大块的内存并复用，减少系统调用。</li>
</ul>
</li>
<li>重载<code>delete</code>：
<ul>
<li>控制内存释放过程。</li>
<li>确保资源的正确回收与管理。</li>
</ul>
</li>
</ul>
<p><strong>3. 重载的特性</strong></p>
<ol>
<li>静态成员函数：
<ul>
<li><code>new</code> 和 <code>delete</code> 被设计为<strong>静态成员函数</strong>，因此与类的具体对象无关。</li>
<li>可以<strong>直接通过类名调用</strong>。</li>
</ul>
</li>
<li>可继承性：
<ul>
<li>重载的 <code>new</code> 和 <code>delete</code> 运算符<strong>可以被子类继承</strong>，从而避免子类重复定义相同的内存管理逻辑。</li>
</ul>
</li>
<li>避免循环类的访问控制问题：
<ul>
<li>通过重载的形式，程序可以更灵活地控制访问权限与内存管理行为。</li>
</ul>
</li>
</ol>
<p><strong>4. 实现方法</strong></p>
<p><strong>步骤</strong></p>
<ol>
<li>调用系统的内存分配函数（如 <code>malloc</code>）申请较大的一块内存。</li>
<li>针对这块内存，自己管理分配和回收。</li>
<li>重载 <code>new</code> 和 <code>delete</code> 运算符实现上述逻辑。</li>
</ol>
<p><strong>5. 实际应用</strong></p>
<ol>
<li>提高内存分配效率：
<ul>
<li>在游戏开发、嵌入式开发等高频次内存操作场景中，通过重载<code>new</code> 和 <code>delete</code>可以实现高效内存池。</li>
</ul>
</li>
<li>内存对齐控制：
<ul>
<li>对硬件或性能要求较高的系统，可以通过自定义分配函数实现对内存对齐的严格控制。</li>
</ul>
</li>
<li>内存使用统计与调试：
<ul>
<li>自定义 <code>new</code> 和 <code>delete</code> 可以统计每次内存分配的大小和位置，便于调试和检测内存泄漏。</li>
</ul>
</li>
</ol>
<p><strong>6. 示例代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重载 new 运算符</span></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Custom new: Allocating &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes.\n&quot;</span>;</span><br><span class="line">        <span class="type">void</span>* p = std::<span class="built_in">malloc</span>(size); <span class="comment">// 使用 malloc 分配内存</span></span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 delete 运算符</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Custom delete: Releasing memory.\n&quot;</span>;</span><br><span class="line">        std::<span class="built_in">free</span>(p); <span class="comment">// 使用 free 释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass* obj = <span class="keyword">new</span> <span class="built_in">MyClass</span>(); <span class="comment">// 调用重载的 new</span></span><br><span class="line">    <span class="keyword">delete</span> obj;                  <span class="comment">// 调用重载的 delete</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Custom new: Allocating 1 bytes.</span><br><span class="line">Custom delete: Releasing memory.</span><br></pre></td></tr></table></figure>
<p><strong>7. 优点</strong></p>
<ol>
<li>提升效率：
<ul>
<li>减少系统函数调用频率，优化性能。</li>
</ul>
</li>
<li>定制化内存管理：
<ul>
<li>满足特定场景需求，例如内存池、内存对齐等。</li>
</ul>
</li>
<li>提高安全性：
<ul>
<li>通过控制内存分配与释放逻辑，可以减少内存泄漏等问题。</li>
</ul>
</li>
</ol>
<p><strong>8. 注意事项</strong></p>
<ol>
<li>继承与多态的注意点：
<ul>
<li>子类继承父类时，需确保重载的 <code>new</code> 和 <code>delete</code> 能正确处理父类和子类的内存分配需求。</li>
</ul>
</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-3/image-20241221191637190.png" class="" title="image-20241221191637190">
<p><strong>1. 重载<code>new</code>的定义</strong></p>
<ul>
<li>
<p><code>void *operator new(size_t size, ...)</code></p>
<ul>
<li>
<p><strong>函数名称</strong>：<code>operator new</code></p>
</li>
<li>
<p><strong>返回类型</strong>：<code>void *</code>，因为<code>new</code>操作符本质上是在分配内存，其返回的是内存的首地址（通用指针<code>void*</code>）。</p>
</li>
<li>
<p>第一个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_t size</span><br></pre></td></tr></table></figure>
<ul>
<li>这是分配内存时必需的参数，表示系统自动计算对象的大小。</li>
<li>编译器在调用<code>operator new</code>时，会自动计算传入<code>size</code>的值，即所需内存的字节大小。</li>
</ul>
</li>
<li>
<p>其他参数：可有可无</p>
<ul>
<li>允许开发者在重载<code>new</code>时传入额外的参数，从而实现更灵活的内存管理。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>2. 使用方式</strong></p>
<ul>
<li>
<p>基本形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A* p = <span class="built_in">new</span>(...) A;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>A</code> 是要分配的对象类型。</li>
<li><code>...</code> 表示可以为<code>new</code>操作符传递额外的参数，这些参数会传递给用户定义的<code>operator new</code>。</li>
</ul>
</li>
</ul>
<p><strong>3. 重载<code>new</code>的特性</strong></p>
<ul>
<li>可以有多个重载：
<ul>
<li>允许根据不同的参数列表（如<code>operator new(size_t)</code>或<code>operator new(size_t, const std::nothrow_t&amp;)</code>）定义多个<code>operator new</code>，以便满足不同场景下的需求。</li>
</ul>
</li>
<li>替代默认行为：
<ul>
<li>如果重载了<code>new</code>，那么通过<code>new</code>动态创建对象时，将调用用户定义的<code>operator new</code>，而不会调用默认的内置实现。</li>
</ul>
</li>
</ul>
<p><strong>4. 默认<code>new</code>的行为</strong></p>
<ul>
<li>
<p>默认情况下，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new</span><br></pre></td></tr></table></figure>
<p>操作符会执行以下两步操作：</p>
<ol>
<li>分配内存：
<ul>
<li>调用全局或类的<code>operator new</code>来申请内存。</li>
</ul>
</li>
<li>调用构造函数：
<ul>
<li>在分配的内存上调用对象的构造函数。</li>
</ul>
</li>
</ol>
</li>
<li>
<p>重载<code>new</code>时，用户可以替代默认的<strong>内存分配行为</strong>，但构造函数的调用顺序不会改变。</p>
</li>
</ul>
<p><strong>5. 示例代码</strong></p>
<p>假如需要重载<code>new</code>以追踪内存分配，可以这样实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载 operator new</span></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Custom operator new called. Allocating &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes.\n&quot;</span>;</span><br><span class="line">        <span class="type">void</span>* p = std::<span class="built_in">malloc</span>(size); <span class="comment">// 使用 malloc 分配内存</span></span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>(); <span class="comment">// 如果内存分配失败，抛出异常</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 operator delete</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Custom operator delete called. Freeing memory.\n&quot;</span>;</span><br><span class="line">        std::<span class="built_in">free</span>(p); <span class="comment">// 使用 free 释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* obj = <span class="keyword">new</span> A; <span class="comment">// 调用重载的 operator new</span></span><br><span class="line">    <span class="keyword">delete</span> obj;     <span class="comment">// 调用重载的 operator delete</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Custom operator new called. Allocating 4 bytes.</span><br><span class="line">Custom operator delete called. Freeing memory.</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-3/image-20241221191800380.png" class="" title="image-20241221191800380">
<p><strong>1. 重载<code>delete</code>的定义</strong></p>
<ul>
<li>
<p>函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>函数名称</strong>：<code>operator delete</code>。</p>
</li>
<li>
<p><strong>返回类型</strong>：<code>void</code>，因为<code>delete</code>操作本质上是释放内存，不需要返回值。</p>
</li>
<li>
<p>参数：</p>
<ol>
<li>
<p><code>void *p</code>：</p>
<ul>
<li>要删除对象的指针。</li>
<li>表示需要释放的内存地址。</li>
</ul>
</li>
<li>
<p><code>size_t size</code></p>
<p>（可选参数）：</p>
<ul>
<li>要删除对象的大小。</li>
<li>如果指定了该参数，必须是<code>size_t</code>类型。</li>
<li>通常，编译器会自动传递对象的大小。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>2. 使用场景</strong></p>
<ul>
<li>释放动态内存：
<ul>
<li><code>delete</code>操作符用于释放<code>new</code>分配的内存。</li>
<li>重载<code>delete</code>可以实现自定义的内存释放逻辑。</li>
</ul>
</li>
<li>配合重载<code>new</code>：
<ul>
<li>如果对类重载了<code>new</code>，通常也需要重载<code>delete</code>，以确保配对使用。</li>
</ul>
</li>
</ul>
<p><strong>3. 重载的限制</strong></p>
<ol>
<li><strong><code>delete</code>的重载只能有一个</strong>：
<ul>
<li>每个类只能定义一个<code>operator delete</code>版本。</li>
<li>这是因为<code>delete</code>的行为与内存释放的本质相关，不允许过多重载。</li>
</ul>
</li>
<li><strong>覆盖默认行为</strong>：
<ul>
<li>如果重载了<code>delete</code>，那么使用<code>delete</code>释放对象时将调用用户自定义的<code>operator delete</code>。</li>
<li>不会再调用系统提供的默认<code>delete</code>。</li>
</ul>
</li>
</ol>
<p><strong>4. 默认<code>delete</code>的行为</strong></p>
<ul>
<li>
<p>默认</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete</span><br></pre></td></tr></table></figure>
<p>操作符会：</p>
<ol>
<li>调用析构函数：
<ul>
<li>先销毁对象。</li>
</ul>
</li>
<li>释放内存：
<ul>
<li>调用全局或类的<code>operator delete</code>释放内存。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><strong>5. 示例代码</strong></p>
<p>下面是一个重载<code>delete</code>操作符的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 operator new</span></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Custom operator new called. Allocating &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes.\n&quot;</span>;</span><br><span class="line">        <span class="type">void</span>* p = std::<span class="built_in">malloc</span>(size);</span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 operator delete</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Custom operator delete called. Freeing memory.\n&quot;</span>;</span><br><span class="line">        std::<span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* obj = <span class="keyword">new</span> A; <span class="comment">// 调用重载的 operator new</span></span><br><span class="line">    <span class="keyword">delete</span> obj;     <span class="comment">// 调用重载的 operator delete</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Custom operator new called. Allocating 4 bytes.</span><br><span class="line">Custom operator delete called. Freeing memory.</span><br></pre></td></tr></table></figure>
<p><strong>6. 带<code>size</code>参数的重载<code>delete</code></strong></p>
<p>在C++17中，引入了可以带<code>size</code>参数的<code>operator delete</code>，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Deleting object of size &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes.\n&quot;</span>;</span><br><span class="line">    std::<span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编译器支持的场景</strong>：</p>
<ul>
<li>当删除对象时，编译器会自动将对象大小传递给<code>size</code>参数。</li>
</ul>
<p><strong>7. 注意事项</strong></p>
<ol>
<li>与<code>new</code>配套使用：
<ul>
<li>如果对类定义了自定义<code>operator new</code>，建议同时定义对应的<code>operator delete</code>，以确保内存分配和释放的逻辑一致。</li>
</ul>
</li>
<li>析构函数调用：
<ul>
<li>无论是否重载<code>delete</code>，析构函数的调用顺序不会受到影响。</li>
</ul>
</li>
<li>内存泄漏：
<ul>
<li>重载<code>delete</code>时需要确保所有分配的内存都被正确释放，否则可能导致内存泄漏。</li>
</ul>
</li>
<li>性能问题：
<ul>
<li>频繁的内存分配和释放会影响性能，自定义的<code>delete</code>可以优化释放逻辑。</li>
</ul>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Liu Kai-Qi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/01/25/CPP-2-3/">http://example.com/2025/01/25/CPP-2-3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">ChocStar🍫</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">C++高级程序设计</a></div><div class="post-share"><div class="social-share" data-image="/img/C++.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="prev-post pull-left" href="/2025/01/25/CPP-2-2/" title="C++高级程序设计笔记（C2-2）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++高级程序设计笔记（C2-2）</div></div></a><a class="next-post pull-right" href="/2024/10/20/Pytorch%20%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/" title="深度学习Pytorch/Pycharm等 踩坑记录"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/ubuntu.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">深度学习Pytorch/Pycharm等 踩坑记录</div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a href="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" title="C++高级程序设计笔记（C1-C4）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-25</div><div class="title">C++高级程序设计笔记（C1-C4）</div></div></a><a href="/2025/01/25/C7/" title="C++高级程序设计笔记（C7）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-25</div><div class="title">C++高级程序设计笔记（C7）</div></div></a><a href="/2025/01/25/C8/" title="C++高级程序设计笔记（C8）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-25</div><div class="title">C++高级程序设计笔记（C8）</div></div></a><a href="/2025/01/25/C5/" title="C++高级程序设计笔记（C5）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-25</div><div class="title">C++高级程序设计笔记（C5）</div></div></a><a href="/2025/01/25/C6/" title="C++高级程序设计笔记（C6）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-25</div><div class="title">C++高级程序设计笔记（C6）</div></div></a><a href="/2025/01/25/CPP-2-1/" title="C++高级程序设计笔记（C2-1）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-25</div><div class="title">C++高级程序设计笔记（C2-1）</div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Liu Kai-Qi</div><div class="author-info-description">Sometimes you have to go for it</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/liukqchoco"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/liukqchoco" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">CPP-2-3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">1.1.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.2.</span> <span class="toc-text">操作符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E7%9B%AE%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.2.1.</span> <span class="toc-text">双目操作符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%9B%AE%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.2.2.</span> <span class="toc-text">单目操作符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.2.3.</span> <span class="toc-text">特殊操作符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.2.4.</span> <span class="toc-text">类型转换运算符</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" title="C++高级程序设计笔记（C1-C4）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++高级程序设计笔记（C1-C4）"/></a><div class="content"><a class="title" href="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" title="C++高级程序设计笔记（C1-C4）">C++高级程序设计笔记（C1-C4）</a><time datetime="2025-01-25T14:10:32.000Z" title="发表于 2025-01-25 22:10:32">2025-01-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/25/C7/" title="C++高级程序设计笔记（C7）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++高级程序设计笔记（C7）"/></a><div class="content"><a class="title" href="/2025/01/25/C7/" title="C++高级程序设计笔记（C7）">C++高级程序设计笔记（C7）</a><time datetime="2025-01-25T14:10:32.000Z" title="发表于 2025-01-25 22:10:32">2025-01-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/25/C8/" title="C++高级程序设计笔记（C8）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++高级程序设计笔记（C8）"/></a><div class="content"><a class="title" href="/2025/01/25/C8/" title="C++高级程序设计笔记（C8）">C++高级程序设计笔记（C8）</a><time datetime="2025-01-25T14:10:32.000Z" title="发表于 2025-01-25 22:10:32">2025-01-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/25/C5/" title="C++高级程序设计笔记（C5）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++高级程序设计笔记（C5）"/></a><div class="content"><a class="title" href="/2025/01/25/C5/" title="C++高级程序设计笔记（C5）">C++高级程序设计笔记（C5）</a><time datetime="2025-01-25T14:10:32.000Z" title="发表于 2025-01-25 22:10:32">2025-01-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/25/C6/" title="C++高级程序设计笔记（C6）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++高级程序设计笔记（C6）"/></a><div class="content"><a class="title" href="/2025/01/25/C6/" title="C++高级程序设计笔记（C6）">C++高级程序设计笔记（C6）</a><time datetime="2025-01-25T14:10:32.000Z" title="发表于 2025-01-25 22:10:32">2025-01-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Liu Kai-Qi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>(() => {
  const panguFn = () => {
    if (typeof pangu === 'object') pangu.autoSpacingPage()
    else {
      btf.getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
        .then(() => {
          pangu.autoSpacingPage()
        })
    }
  }

  const panguInit = () => {
    if (false){
      GLOBAL_CONFIG_SITE.isPost && panguFn()
    } else {
      panguFn()
    }
  }

  btf.addGlobalFn('pjaxComplete', panguInit, 'pangu')
  document.addEventListener('DOMContentLoaded', panguInit)
})()</script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="你要找什么呀" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>