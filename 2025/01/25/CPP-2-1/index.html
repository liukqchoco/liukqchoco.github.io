<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++高级程序设计笔记（C2-1） | ChocStar🍫</title><meta name="author" content="Liu Kai-Qi"><meta name="copyright" content="Liu Kai-Qi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="CPP-2-1 面向对象 示例  封装    构造函数  public与private访问控制 （1）默认构造函数的访问权限  构造函数通常是 public 的，以便类的对象可以在外部被创建。 但是，可以将构造函数设置为 private，以禁止类外部创建对象。这种方式通常用于单例模式。  示例：将构造函数定义为 private 123456789101112131415161718192021#i">
<meta property="og:type" content="article">
<meta property="og:title" content="C++高级程序设计笔记（C2-1）">
<meta property="og:url" content="http://example.com/2025/01/25/CPP-2-1/index.html">
<meta property="og:site_name" content="ChocStar🍫">
<meta property="og:description" content="CPP-2-1 面向对象 示例  封装    构造函数  public与private访问控制 （1）默认构造函数的访问权限  构造函数通常是 public 的，以便类的对象可以在外部被创建。 但是，可以将构造函数设置为 private，以禁止类外部创建对象。这种方式通常用于单例模式。  示例：将构造函数定义为 private 123456789101112131415161718192021#i">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/C++.jpg">
<meta property="article:published_time" content="2025-01-25T14:10:32.000Z">
<meta property="article:modified_time" content="2025-02-05T09:29:42.284Z">
<meta property="article:author" content="Liu Kai-Qi">
<meta property="article:tag" content="C++高级程序设计">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/C++.jpg"><link rel="shortcut icon" href="/img/web_label.png"><link rel="canonical" href="http://example.com/2025/01/25/CPP-2-1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: Liu Kai-Qi","link":"链接: ","source":"来源: ChocStar🍫","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++高级程序设计笔记（C2-1）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-02-05 17:29:42'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/background.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post type-C++高级程序设计" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/C++.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">ChocStar🍫</span></a><a class="nav-page-title" href="/"><span class="site-name">C++高级程序设计笔记（C2-1）</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">C++高级程序设计笔记（C2-1）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-25T14:10:32.000Z" title="发表于 2025-01-25 22:10:32">2025-01-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-05T09:29:42.284Z" title="更新于 2025-02-05 17:29:42">2025-02-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">C++高级程序设计</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">15.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>56分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>CPP-2-1</h1>
<h2 id="面向对象">面向对象</h2>
<h3 id="示例">示例</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241128195449916.png" class="" title="image-20241128195449916">
<h2 id="封装">封装</h2>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241218201740547.png" class="" title="image-20241218201740547">
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241218201754849.png" class="" title="image-20241218201754849">
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241218201846172.png" class="" title="image-20241218201846172">
<h2 id="构造函数">构造函数</h2>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241218202223114.png" class="" title="image-20241218202223114">
<p><strong>public与private访问控制</strong></p>
<p><strong>（1）默认构造函数的访问权限</strong></p>
<ul>
<li>构造函数通常是 <code>public</code> 的，以便类的对象可以在外部被创建。</li>
<li>但是，可以将构造函数设置为 <code>private</code>，以<strong>禁止类外部创建对象</strong>。这种方式通常用于<strong>单例模式</strong>。</li>
</ul>
<p><strong>示例：将构造函数定义为 <code>private</code></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Example</span>() &#123;  <span class="comment">// 私有构造函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Constructor is called!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 通过静态方法提供对象创建的途径</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Example <span class="title">createObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Example</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Example obj; // 错误！无法直接调用私有构造函数</span></span><br><span class="line">    Example obj = Example::<span class="built_in">createObject</span>(); <span class="comment">// 通过静态方法创建对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor is called!</span><br></pre></td></tr></table></figure>
<p><strong>解析</strong>：</p>
<ul>
<li>将构造函数设置为 <code>private</code> 后，外部无法直接创建对象。</li>
<li>可以通过类内部的静态方法间接创建对象，这种机制在<strong>单例模式</strong>中常用。</li>
</ul>
<p><strong>5. <code>=default</code> 关键字</strong></p>
<ul>
<li><code>=default</code> 是C++11引入的新特性，用于显式要求编译器生成默认构造函数或其他默认函数。</li>
<li>使用 <code>=default</code> 可以让代码更清晰，显式地表示构造函数是默认实现。</li>
</ul>
<p><strong>示例：使用 <code>=default</code> 声明默认构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>() = <span class="keyword">default</span>; <span class="comment">// 显式要求编译器提供默认构造函数</span></span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">int</span> x) &#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Parameterized Constructor: x = &quot;</span> &lt;&lt; x &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Example obj1;    <span class="comment">// 调用默认构造函数</span></span><br><span class="line">    <span class="function">Example <span class="title">obj2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 调用带参数的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Parameterized Constructor: x = 10</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241218202635663.png" class="" title="image-20241218202635663">
<h2 id="成员初始化表">成员初始化表</h2>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241218202729014.png" class="" title="image-20241218202729014">
<p><strong>1. 什么是成员初始化表？</strong></p>
<p><strong>成员初始化表</strong>（Member Initialization List）是<strong>构造函数</strong>中的一种特殊机制，它用于在构造函数的<strong>函数体执行之前</strong>初始化类中的<strong>数据成员</strong>。</p>
<p><strong>语法格式</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ClassName</span>(参数列表) : 成员<span class="number">1</span>(值), 成员<span class="number">2</span>(值), ... &#123;</span><br><span class="line">    <span class="comment">// 构造函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>成员名(值)</code> 的部分就是<strong>成员初始化表</strong>。</li>
<li>在构造函数体执行之前，类的成员会按照初始化表中的顺序进行初始化。</li>
</ul>
<p>-<strong>2. 成员初始化表的执行顺序</strong></p>
<ul>
<li><strong>先执行成员初始化表中的初始化操作</strong>。</li>
<li>然后执行构造函数体中的代码。</li>
<li><strong>成员的初始化顺序</strong>是按照<strong>类中数据成员的声明顺序</strong>决定的，而不是初始化表中出现的顺序。</li>
</ul>
<p><strong>3. 成员初始化表的优势</strong></p>
<ol>
<li><strong>高效</strong>：直接初始化成员，而不是先默认初始化再赋值，避免了多余的操作，<strong>提高性能</strong>。</li>
<li><strong>必须使用</strong>：对于某些特殊类型的成员（如 <code>const</code> 成员、引用成员、没有默认构造函数的类类型成员），只能通过初始化表进行初始化。</li>
<li><strong>减少编译器负担</strong>：编译器直接进行初始化，减少编译器的生成代码量。</li>
</ol>
<p><strong>4. 重要使用场景</strong></p>
<p><strong>（1）初始化 <code>const</code> 成员</strong></p>
<p><code>const</code> 成员在类对象创建时必须初始化，且只能通过<strong>初始化表</strong>进行初始化。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> val;  <span class="comment">// const成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x) &#123;  <span class="comment">// 使用初始化表初始化const成员</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Const value initialized to &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Example <span class="title">obj</span><span class="params">(<span class="number">100</span>)</span></span>;  <span class="comment">// 初始化const成员为100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Const value initialized to 100</span><br></pre></td></tr></table></figure>
<p><strong>解析</strong>：</p>
<ul>
<li><code>const</code> 成员 <code>val</code> 不能在构造函数体中赋值，只能通过<strong>初始化表</strong>完成初始化。</li>
</ul>
<p><strong>（2）初始化引用成员</strong></p>
<p>引用类型的成员（<code>int&amp;</code>）必须在定义时初始化，且不能被重新赋值，因此只能通过<strong>初始化表</strong>来初始化。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>&amp; ref;  <span class="comment">// 引用成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">int</span>&amp; x) : <span class="built_in">ref</span>(x) &#123;  <span class="comment">// 使用初始化表初始化引用成员</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Reference initialized to &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">42</span>;</span><br><span class="line">    <span class="function">Example <span class="title">obj</span><span class="params">(value)</span></span>;  <span class="comment">// 引用成员指向value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reference initialized to 42</span><br></pre></td></tr></table></figure>
<p><strong>解析</strong>：</p>
<ul>
<li>引用成员 <code>ref</code> 通过成员初始化表被初始化为 <code>value</code>，不能在构造函数体中赋值。</li>
</ul>
<p><strong>（3）初始化没有默认构造函数的类对象</strong></p>
<p>如果类成员是另一个没有默认构造函数的类对象，必须在初始化表中显式调用其构造函数。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> x) : <span class="built_in">data</span>(x) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B initialized with data = &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    B b;  <span class="comment">// 成员对象</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> val) : <span class="built_in">b</span>(val) &#123;  <span class="comment">// 使用初始化表显式调用B的构造函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A&#x27;s constructor called&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B initialized with data = 10</span><br><span class="line">A&#x27;s constructor called</span><br></pre></td></tr></table></figure>
<p><strong>解析</strong>：</p>
<ul>
<li>类 <code>B</code> 没有默认构造函数，所以必须通过初始化表显式调用 <code>B(int x)</code>。</li>
<li>在类 <code>A</code> 的构造函数中，成员对象 <code>b</code> 使用初始化表初始化为 <code>val</code>。</li>
</ul>
<p><strong>（4）初始化基本数据类型与默认值</strong></p>
<p>在PPT中的 <code>class A</code> 示例中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="type">int</span>&amp; z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">y</span>(<span class="number">1</span>), <span class="built_in">z</span>(x), <span class="built_in">x</span>(<span class="number">0</span>) &#123;  <span class="comment">// 成员初始化表</span></span><br><span class="line">        x = <span class="number">100</span>;  <span class="comment">// 构造函数体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>：</p>
<ol>
<li><strong><code>y(1)</code></strong>：<code>y</code> 是 <code>const</code> 成员，必须在初始化表中初始化。</li>
<li><strong><code>z(x)</code></strong>：<code>z</code> 是引用类型，必须在初始化表中初始化，<code>z</code> 引用了 <code>x</code>。</li>
<li><strong><code>x(0)</code></strong>：直接通过初始化表将 <code>x</code> 初始化为 0，然后在构造函数体中将 <code>x</code> 赋值为 100。</li>
</ol>
<p><strong>5. 代码示例：成员初始化表的顺序</strong></p>
<p>成员初始化的顺序是按照<strong>成员声明的顺序</strong>，而不是初始化表中的顺序。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>() : <span class="built_in">b</span>(<span class="number">2</span>), <span class="built_in">a</span>(b + <span class="number">3</span>) &#123;  <span class="comment">// 初始化顺序是a -&gt; b（按声明顺序）</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Example obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>（可能有意外）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 3, b = 2</span><br></pre></td></tr></table></figure>
<p><strong>解析</strong>：</p>
<ul>
<li>虽然在初始化表中 <code>b</code> 被初始化在前面，但实际上 <code>a</code> 会先被初始化，因为类中数据成员的声明顺序是 <code>a</code> 在 <code>b</code> 之前。</li>
<li>因此，<code>a</code> 初始化时 <code>b</code> 还未被赋值，导致 <code>a = 3</code>（未使用 <code>b</code> 的最新值）。</li>
</ul>
<p><strong>图片右侧的 <code>class CString</code> 表达的含义</strong></p>
<p>右侧的 <code>class CString</code> 主要是想说明<strong>成员初始化表</strong>的使用方法，尤其是当类包含<strong>动态内存分配</strong>时，如何在构造函数中正确初始化成员变量。</p>
<p><strong>代码分析</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CString</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p;   <span class="comment">// 指向动态分配的字符数组</span></span><br><span class="line">    <span class="type">int</span> size;  <span class="comment">// 字符数组的大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CString</span>(<span class="type">int</span> x) : <span class="built_in">size</span>(x), <span class="built_in">p</span>(<span class="keyword">new</span> <span class="type">char</span>[size]) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>代码解释</strong></p>
<ol>
<li><strong>成员变量 <code>p</code> 和 <code>size</code></strong>：
<ul>
<li><code>size</code> 是一个整数变量，用于保存字符数组的大小。</li>
<li><code>p</code> 是一个指针，指向动态分配的字符数组。</li>
</ul>
</li>
<li><strong>构造函数 <code>CString(int x)</code></strong>：
<ul>
<li><strong><code>: size(x)</code></strong>：使用<strong>成员初始化表</strong>将 <code>size</code> 初始化为构造函数参数 <code>x</code>。</li>
<li><strong><code>p(new char[size])</code></strong>：动态分配一个字符数组，大小为 <code>size</code>，并将其地址赋给 <code>p</code>。</li>
</ul>
</li>
<li><strong>构造函数体为空</strong>：
<ul>
<li>成员变量的初始化完全通过<strong>成员初始化表</strong>完成。</li>
<li>这样避免了在构造函数体内先默认初始化 <code>p</code> 和 <code>size</code>，然后再进行赋值，提升了效率。</li>
</ul>
</li>
</ol>
<p><strong><code>CString</code> 的要点</strong></p>
<ul>
<li><strong>动态内存管理</strong>：通过 <code>new</code> 在堆上动态分配内存。</li>
<li>成员初始化表的必要性：
<ul>
<li>如果直接在构造函数体内给 <code>p</code> 赋值，<code>p</code> 会被默认初始化为 <code>nullptr</code>，然后再赋值，这样会增加不必要的操作。</li>
<li>使用初始化表可以直接初始化 <code>p</code> 和 <code>size</code>，更加高效。</li>
</ul>
</li>
<li>总结：
<ul>
<li><code>size</code> 通过成员初始化表被赋值为 <code>x</code>。</li>
<li><code>p</code> 通过成员初始化表直接初始化为 <code>new char[size]</code>，避免了冗余操作。</li>
</ul>
</li>
</ul>
<p><strong>2. <code>class A</code> 中的 <code>int x&#123;0&#125;</code> 的含义</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>解释</strong></p>
<ul>
<li><strong><code>int x&#123;0&#125;;</code></strong> 是 C++11 引入的<strong>统一初始化语法</strong>（也称为<strong>列表初始化</strong>）。</li>
<li>它的作用是将变量 <code>x</code> 初始化为 <code>0</code>。</li>
<li>相比传统的 <code>int x = 0;</code>，<code>int x&#123;0&#125;;</code> 更加安全，因为它可以避免<strong>窄化转换</strong>（narrowing conversion）。</li>
</ul>
<p><strong><code>int x&#123;0&#125;</code> 的特点</strong></p>
<ol>
<li>安全性更高：
<ul>
<li>统一初始化 <code>&#123;&#125;</code> 会进行严格的类型检查，防止不安全的隐式类型转换。</li>
</ul>
</li>
</ol>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a&#123;<span class="number">3.5</span>&#125;;  <span class="comment">// 错误！编译时会报错，3.5不能隐式转换为int</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">3.5</span>; <span class="comment">// 正确！但会丢失小数部分</span></span><br></pre></td></tr></table></figure>
<ol>
<li>初始化的类型统一：
<ul>
<li>这种 <code>&#123;&#125;</code> 语法适用于类成员、局部变量、数组等场景，统一了 C++ 中的初始化方式。</li>
</ul>
</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241218203416391.png" class="" title="image-20241218203416391">
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241218203448033.png" class="" title="image-20241218203448033">
<h2 id="析构函数">析构函数</h2>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241218203504595.png" class="" title="image-20241218203504595">
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241218205120098.png" class="" title="image-20241218205120098">
<p><strong>1. 析构函数的概念</strong></p>
<p><strong>析构函数</strong>（Destructor）是一个特殊的成员函数，当对象的生命周期结束时（例如离开作用域或被 <code>delete</code> 删除），<strong>系统会自动调用析构函数</strong>，用于清理对象占用的资源。</p>
<p><strong>析构函数的特点</strong></p>
<ol>
<li>名称与类名相同，但前面加 <code>~</code>：
<ul>
<li>例如：<code>~ClassName();</code></li>
</ul>
</li>
<li><strong>没有返回值</strong>，也没有参数。</li>
<li><strong>系统自动调用</strong>：当对象消亡时，析构函数会被自动调用。</li>
<li><strong>释放非内存资源</strong>：如关闭文件、释放动态内存、释放网络连接等。</li>
</ol>
<p><strong>代码示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Constructor called&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Example</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destructor called&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Example obj;  <span class="comment">// 创建对象</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Inside main()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  <span class="comment">// 对象生命周期结束，自动调用析构函数</span></span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor called</span><br><span class="line">Inside main()</span><br><span class="line">Destructor called</span><br></pre></td></tr></table></figure>
<p><strong>解析</strong>：</p>
<ul>
<li>构造函数 <code>Example()</code> 在对象创建时被调用。</li>
<li>析构函数 <code>~Example()</code> 在对象消亡时被调用，完成资源清理。</li>
</ul>
<p><strong>2. 析构函数的作用</strong></p>
<ul>
<li><strong>自动释放资源</strong>：对象消亡时，自动释放对象所占的资源。</li>
<li><strong>非内存资源管理</strong>：如关闭文件、释放数据库连接等。</li>
<li><strong>手动释放内存</strong>：如释放 <code>new</code> 分配的动态内存，防止内存泄漏。</li>
</ul>
<p><strong>3. PPT中的代码分析</strong></p>
<p><strong>代码片段：class A</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123; <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ~<span class="built_in">A</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>代码解释</strong></p>
<ol>
<li><strong><code>A()</code></strong>：
<ul>
<li>公有的构造函数，允许创建对象。</li>
</ul>
</li>
<li><strong><code>~A()</code></strong>：
<ul>
<li>私有的析构函数，<strong>禁止外部代码直接删除对象</strong>，以确保对象生命周期由类本身控制。</li>
</ul>
</li>
<li><strong><code>destroy()</code> 方法</strong>：
<ul>
<li>通过 <code>delete this;</code> 来手动销毁对象。</li>
<li><code>delete this;</code> 的使用要<strong>非常小心</strong>，确保对象是在堆上分配的，否则会引发未定义行为。</li>
</ul>
</li>
</ol>
<p><strong><code>delete this;</code> 的问题与用法</strong></p>
<p><strong>问题</strong>：</p>
<ul>
<li>如果对象不是在堆上创建的，<code>delete this;</code> 会导致未定义行为。</li>
<li>因此，必须保证对象是通过 <code>new</code> 分配在堆上的。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A *p = <span class="keyword">new</span> <span class="built_in">A</span>();  <span class="comment">// 堆上创建对象</span></span><br><span class="line">p-&gt;<span class="built_in">destroy</span>();    <span class="comment">// 调用destroy()方法，delete this删除对象</span></span><br></pre></td></tr></table></figure>
<p><strong>错误用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A obj;  <span class="comment">// 栈上创建对象</span></span><br><span class="line">obj.<span class="built_in">destroy</span>();  <span class="comment">// 错误！delete this 会导致未定义行为</span></span><br></pre></td></tr></table></figure>
<p><strong>4. RAII vs GC</strong></p>
<p><strong>RAII（Resource Acquisition Is Initialization）</strong></p>
<p>RAII 是C++中资源管理的重要原则：</p>
<ul>
<li><strong>资源获取即初始化</strong>：在构造函数中获取资源（如动态内存、文件句柄），在析构函数中释放资源。</li>
<li><strong>自动管理资源</strong>：通过对象的生命周期自动释放资源，避免内存泄漏。</li>
</ul>
<p><strong>示例：RAII 原则</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileHandler</span> &#123;</span><br><span class="line">    fstream file;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FileHandler</span>(<span class="type">const</span> string&amp; filename) &#123;</span><br><span class="line">        file.<span class="built_in">open</span>(filename, ios::out);</span><br><span class="line">        <span class="keyword">if</span> (file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;File opened successfully!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">FileHandler</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            file.<span class="built_in">close</span>();</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;File closed in destructor.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">FileHandler <span class="title">fh</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>;  <span class="comment">// 构造函数打开文件，析构函数关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File opened successfully!</span><br><span class="line">File closed in destructor.</span><br></pre></td></tr></table></figure>
<p><strong>解析</strong>：</p>
<ul>
<li>构造函数中打开文件，析构函数中自动关闭文件。</li>
<li>RAII 避免了手动释放资源的复杂性，提高了代码的安全性。</li>
</ul>
<p><strong>GC（垃圾回收）</strong></p>
<p><strong>GC（Garbage Collection）</strong> 是 Java 等语言中自动内存管理的一种机制：</p>
<ul>
<li>通过自动检测不再使用的对象来释放内存。</li>
<li><strong>优点</strong>：程序员无需手动管理内存。</li>
<li>缺点：
<ul>
<li>效率较低。</li>
<li>不适用于需要精确控制资源释放的场景。</li>
</ul>
</li>
</ul>
<p><strong>PPT中的对比</strong>：</p>
<ul>
<li><strong>C++：RAII</strong>，程序员可以手动控制资源的获取与释放。</li>
<li><strong>Java：GC</strong>，通过 <code>finalize()</code> 等机制自动进行垃圾回收。</li>
</ul>
<hr>
<p><strong>5. Better Solution：避免 <code>delete this</code> 带来的风险</strong></p>
<p>PPT 提供了一种更好的解决方案：通过<strong>静态方法</strong>来释放堆上分配的对象。</p>
<p><strong>代码示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">free</span><span class="params">(A *p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> p;  <span class="comment">// 释放对象</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;&#125;  <span class="comment">// 私有析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A *p = <span class="keyword">new</span> <span class="built_in">A</span>();    <span class="comment">// 在堆上创建对象</span></span><br><span class="line">    A::<span class="built_in">free</span>(p);        <span class="comment">// 使用静态方法释放对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解析</strong>：</p>
<ul>
<li>析构函数是私有的，禁止外部直接使用 <code>delete</code>。</li>
<li>提供了一个 <code>free()</code> 静态方法来释放对象，确保对象的释放安全可控。</li>
<li>避免了 <code>delete this;</code> 可能导致的未定义行为。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241218204406784.png" class="" title="image-20241218204406784">
<h2 id="拷贝构造函数">拷贝构造函数</h2>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241218204525826.png" class="" title="image-20241218204525826">
<p><strong>1. 拷贝构造函数的定义</strong></p>
<p><strong>拷贝构造函数</strong>（Copy Constructor）用于<strong>创建新对象</strong>时，用<strong>同一类的另一个对象</strong>来对新对象进行初始化。</p>
<p><strong>基本语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ClassName</span>(<span class="type">const</span> ClassName&amp; other);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>const ClassName&amp;</code></strong>：参数必须是引用类型，通常加 <code>const</code>，以避免不必要的修改和无限递归调用。</li>
<li><strong>自动调用</strong>：在某些情况下系统会自动调用拷贝构造函数。</li>
</ul>
<p><strong>2. 拷贝构造函数的调用时机</strong></p>
<p>拷贝构造函数会在以下几种情况下自动调用：</p>
<ol>
<li>
<p><strong>用一个对象初始化另一个对象时</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a;          <span class="comment">// 调用默认构造函数</span></span><br><span class="line">A b = a;      <span class="comment">// 调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>对象作为函数参数传递时（值传递）</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(A a)</span></span>;  <span class="comment">// 形参是A类型对象，会调用拷贝构造函数</span></span><br><span class="line">A obj;</span><br><span class="line"><span class="built_in">f</span>(obj);       <span class="comment">// 传递对象时调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>对象作为函数返回值时（值返回）</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">return</span> a;  <span class="comment">// 返回局部对象时调用拷贝构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A obj = <span class="built_in">f</span>();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>对象被显式拷贝时</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A obj1;</span><br><span class="line"><span class="function">A <span class="title">obj2</span><span class="params">(obj1)</span></span>;  <span class="comment">// 调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>3. 拷贝构造函数的默认实现</strong></p>
<p>如果用户<strong>没有显式定义</strong>拷贝构造函数，编译器会提供一个<strong>默认拷贝构造函数</strong>。</p>
<p><strong>默认拷贝构造函数的行为</strong></p>
<ul>
<li><strong>逐个成员拷贝</strong>：默认拷贝构造函数会对对象的每个成员执行<strong>逐个拷贝</strong>（Member-wise Initialization）。</li>
<li><strong>浅拷贝</strong>：对于指针成员，默认拷贝构造函数只会拷贝指针的地址，而不会分配新的内存空间。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *p) &#123;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(p) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认拷贝构造函数（浅拷贝）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">String</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] str;  <span class="comment">// 释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    String s2 = s1;  <span class="comment">// 调用默认拷贝构造函数（浅拷贝）</span></span><br><span class="line"></span><br><span class="line">    s<span class="number">1.</span><span class="built_in">display</span>();</span><br><span class="line">    s<span class="number">2.</span><span class="built_in">display</span>();  <span class="comment">// 问题：s1 和 s2 指向同一块内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出（可能导致问题）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure>
<p><strong>问题分析</strong></p>
<ul>
<li>默认拷贝构造函数进行的是<strong>浅拷贝</strong>，导致两个对象的 <code>str</code> 指针指向同一块内存。</li>
<li>当 <code>s1</code> 和 <code>s2</code> 析构时，会释放同一块内存，造成<strong>重复释放</strong>（Undefined Behavior）。</li>
</ul>
<p><strong>4. 深拷贝的解决方案</strong></p>
<p>为了解决浅拷贝问题，我们需要<strong>自定义拷贝构造函数</strong>，实现<strong>深拷贝</strong>。</p>
<p><strong>示例：实现深拷贝</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 带参数的构造函数</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *p) &#123;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(p) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义拷贝构造函数：实现深拷贝</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String &amp;other) &#123;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.str) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str, other.str);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copy Constructor Called&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">String</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] str;  <span class="comment">// 释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    String s2 = s1;  <span class="comment">// 调用自定义拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">    s<span class="number">1.</span><span class="built_in">display</span>();</span><br><span class="line">    s<span class="number">2.</span><span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copy Constructor Called</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure>
<p><strong>解释</strong></p>
<ul>
<li>自定义拷贝构造函数分配新的内存空间，确保 <code>s1</code> 和 <code>s2</code> 拥有独立的内存。</li>
<li>避免了浅拷贝导致的重复释放问题。</li>
</ul>
<p><strong>5. 拷贝构造函数 = <code>delete</code></strong></p>
<p>PPT中的 <code>A(const A&amp; a) = delete;</code> 是C++11引入的新特性，表示<strong>禁止使用拷贝构造函数</strong>。</p>
<p><strong>用途</strong></p>
<ul>
<li>禁止对象被拷贝，防止不期望的拷贝操作。</li>
<li>常用于管理资源的类，如单例模式。</li>
</ul>
<p><strong>示例：禁止拷贝构造</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; a) = <span class="keyword">delete</span>;  <span class="comment">// 禁止拷贝构造</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Object A&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="comment">// A b = a;  // 错误！拷贝构造被删除</span></span><br><span class="line">    a.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出：编译错误</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: use of deleted function ‘A::A(const A&amp;)’</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241218205133125.png" class="" title="image-20241218205133125">
<ul>
<li>左边是浅拷贝，容易出现悬挂指针</li>
<li>右边则是重写了拷贝构造，是深拷贝</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241218205457637.png" class="" title="image-20241218205457637">
<p><strong>1. 默认拷贝构造函数</strong></p>
<p><strong>默认拷贝构造函数</strong>是由编译器自动生成的拷贝构造函数，其行为是<strong>逐个成员拷贝</strong>（<strong>Member-wise Initialization</strong>）。</p>
<p><strong>代码示例：包含成员对象的类</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; x = y = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123; x++; y++; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">    A a;  <span class="comment">// 成员对象</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123; z = <span class="number">0</span>; &#125;  <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">B</span>(<span class="type">const</span> B&amp; b) : <span class="built_in">a</span>(b.a) &#123; z = b.z; &#125;  <span class="comment">// 自定义拷贝构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123; z++; a.<span class="built_in">inc</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>：</p>
<ol>
<li>
<p><strong><code>class A</code></strong>：</p>
<ul>
<li>拥有默认构造函数 <code>A()</code> 和成员函数 <code>inc()</code>。</li>
</ul>
</li>
<li>
<p><strong><code>class B</code></strong>：</p>
<ul>
<li>
<p>包含 <code>A</code> 类型的成员对象 <code>a</code> 和整型变量 <code>z</code>。</p>
</li>
<li>
<p>自定义拷贝构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">B</span>(<span class="type">const</span> B&amp; b) : <span class="built_in">a</span>(b.a) &#123; z = b.z; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>: a(b.a)</code> 调用了 <code>A</code> 类的<strong>拷贝构造函数</strong>来初始化成员对象 <code>a</code>。</li>
<li>逐个拷贝成员变量 <code>z</code>。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>默认拷贝构造函数的行为</strong>：</p>
<ul>
<li>如果未提供自定义拷贝构造函数，编译器会提供一个<strong>默认拷贝构造函数</strong>，对每个成员执行逐个拷贝。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>执行示例与结果</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B b1;     <span class="comment">// 调用默认构造函数</span></span><br><span class="line">b<span class="number">1.</span><span class="built_in">inc</span>(); <span class="comment">// 修改 b1 的成员值</span></span><br><span class="line"></span><br><span class="line"><span class="function">B <span class="title">b2</span><span class="params">(b1)</span></span>; <span class="comment">// 调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>
<p><strong>内存状态变化</strong>：</p>
<ul>
<li>b1 初始状态：
<ul>
<li><code>b1.z = 0, b1.a.x = 0, b1.a.y = 0</code></li>
</ul>
</li>
<li>b1 调用 <code>inc()</code> 后：
<ul>
<li><code>b1.z = 1, b1.a.x = 1, b1.a.y = 1</code></li>
</ul>
</li>
<li>b2 通过拷贝构造函数初始化：
<ul>
<li><code>b2.z = 1</code>（拷贝 <code>b1.z</code>）</li>
<li><code>b2.a</code>使用 <code>A</code>的默认拷贝构造函数，拷贝 <code>b1.a</code>的成员值：
<ul>
<li><code>b2.a.x = 1, b2.a.y = 1</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>输出注释</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b1.z = b1.a.x = b1.a.y = 1</span></span><br><span class="line"><span class="comment">// b2.z = 1, b2.a.x = 1, b2.a.y = 1</span></span><br></pre></td></tr></table></figure>
<p><strong>2. 自定义拷贝构造函数</strong></p>
<p>当类中包含成员对象时，拷贝构造函数需要显式调用成员对象的拷贝构造函数，否则会使用默认拷贝行为。</p>
<p><strong>关键语法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">B</span>(<span class="type">const</span> B&amp; b) : <span class="built_in">a</span>(b.a) &#123; z = b.z; &#125;</span><br></pre></td></tr></table></figure>
<p><strong>含义</strong>：</p>
<ul>
<li><code>: a(b.a)</code>：
<ul>
<li>显式调用 <code>A</code> 类的拷贝构造函数来初始化成员对象 <code>a</code>。</li>
</ul>
</li>
<li><code>z = b.z;</code>：
<ul>
<li>拷贝整型成员 <code>z</code> 的值。</li>
</ul>
</li>
</ul>
<h2 id="移动构造函数">移动构造函数</h2>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241219112842361.png" class="" title="image-20241219112842361">
<p><strong>1. 什么是移动构造函数？</strong></p>
<p><strong>移动构造函数</strong>是C++11引入的一种特殊构造函数，用于通过**“转移资源”<strong>而不是</strong>拷贝资源<strong>来初始化对象，从而提升效率。移动构造函数主要用于</strong>右值对象**的处理。</p>
<p><strong>定义形式</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ClassName</span>(ClassName&amp;&amp; other);</span><br></pre></td></tr></table></figure>
<ul>
<li>参数为<strong>右值引用</strong>（<code>ClassName&amp;&amp;</code>）。</li>
<li>用于接收临时对象或右值，并通过“转移”资源的所有权而非拷贝资源来初始化新对象。</li>
</ul>
<p><strong>2. 移动构造函数的实现</strong></p>
<p><strong>代码示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="type">char</span>* p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* str) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(p, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">String</span>(String&amp;&amp; s) : <span class="built_in">p</span>(s.p) &#123;</span><br><span class="line">        s.p = <span class="literal">nullptr</span>;  <span class="comment">// 使源对象指针置为空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">String</span>() &#123; <span class="keyword">delete</span>[] p; &#125;  <span class="comment">// 析构函数释放资源</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p)</span><br><span class="line">            std::cout &lt;&lt; p &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Empty string&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">s1</span><span class="params">(<span class="string">&quot;test&quot;</span>)</span></span>;         <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    String s2 = std::<span class="built_in">move</span>(s1); <span class="comment">// 调用移动构造函数</span></span><br><span class="line"></span><br><span class="line">    s<span class="number">1.</span><span class="built_in">display</span>();  <span class="comment">// 输出：Empty string</span></span><br><span class="line">    s<span class="number">2.</span><span class="built_in">display</span>();  <span class="comment">// 输出：test</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Empty string</span><br><span class="line">test</span><br></pre></td></tr></table></figure>
<p><strong>执行流程</strong></p>
<ol>
<li>普通构造函数：
<ul>
<li><code>s1</code> 的构造函数动态分配内存并初始化为 <code>&quot;test&quot;</code>。</li>
</ul>
</li>
<li>移动构造函数：
<ul>
<li><code>s2</code> 调用移动构造函数，直接转移了 <code>s1</code> 的内存地址 <code>p</code>。</li>
<li>将 <code>s1.p</code> 置为 <code>nullptr</code>，避免重复释放资源。</li>
</ul>
</li>
<li>析构函数：
<ul>
<li><code>s1</code> 的析构函数释放 <code>nullptr</code>（无操作）。</li>
<li><code>s2</code> 的析构函数释放动态分配的内存 <code>&quot;test&quot;</code>。</li>
</ul>
</li>
</ol>
<p><strong>3. 为什么需要移动构造函数？</strong></p>
<ol>
<li><strong>避免不必要的深拷贝</strong>：
<ul>
<li>普通拷贝构造函数需要分配新的内存，并拷贝原对象的数据。</li>
<li>移动构造函数直接转移资源，避免了内存分配和拷贝操作。</li>
</ul>
</li>
<li><strong>处理右值对象</strong>：
<ul>
<li>临时对象（右值）本身没有持久化需求，可以直接转移其资源。</li>
</ul>
</li>
<li><strong>提升性能</strong>：
<ul>
<li>移动构造函数避免了深拷贝操作，大幅提升性能，特别是在处理<strong>动态内存分配</strong>和<strong>容器扩容</strong>时。</li>
</ul>
</li>
</ol>
<p><strong>4. PPT中涉及的知识点</strong></p>
<p><strong>（1）右值与右值引用</strong></p>
<ul>
<li>右值：表达式的临时值，没有明确的变量名。
<ul>
<li>例如：<code>5</code>、<code>x + 2</code>、<code>string(&quot;test&quot;)</code>。</li>
</ul>
</li>
<li><strong>右值引用</strong>：<code>T&amp;&amp;</code> 用于绑定右值，用于区分<strong>左值</strong>和<strong>右值</strong>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;       <span class="comment">// x 是左值</span></span><br><span class="line"><span class="type">int</span>&amp; y = x;      <span class="comment">// 左值引用</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; z = <span class="number">5</span>;     <span class="comment">// 右值引用，只能绑定右值</span></span><br></pre></td></tr></table></figure>
<p><strong>（2）移动构造函数的调用场景</strong></p>
<p>==<strong>返回值优化</strong>==？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">generate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;test&quot;</span>);  <span class="comment">// 返回临时对象（右值）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string s = <span class="built_in">generate</span>();  <span class="comment">// 调用移动构造函数</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>generate()</code> 返回临时对象 <code>string(&quot;test&quot;)</code>，是右值。</li>
<li>移动构造函数通过“转移资源”而不是“深拷贝”来初始化对象 <code>s</code>。</li>
</ul>
<p><strong>容器扩容</strong></p>
<p>在标准容器（如 <code>std::vector</code>）中，元素的移动构造可以大幅提升扩容性能。</p>
<p><strong>（3）std::move</strong></p>
<p><strong>std::move 的作用</strong></p>
<ul>
<li>将左值<strong>显式转换为右值</strong>，以触发移动构造函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">s1</span><span class="params">(<span class="string">&quot;test&quot;</span>)</span></span>;</span><br><span class="line">String s2 = std::<span class="built_in">move</span>(s1);  <span class="comment">// 调用移动构造函数</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>std::move(s1)</code> 将 <code>s1</code> 转换为右值，使 <code>s2</code> 调用移动构造函数。</li>
</ul>
<p><strong>（4）const 引用绑定右值</strong></p>
<p>PPT中提到：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> string&amp; name = <span class="built_in">generate</span>(); <span class="comment">// OK</span></span><br><span class="line">string&amp;&amp; name = <span class="built_in">generate</span>();      <span class="comment">// Also OK</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>const string&amp;</code></strong>：
<ul>
<li>可以绑定右值和左值，常用于只读操作。</li>
<li><code>generate()</code> 返回右值，<code>const string&amp;</code> 绑定右值是合法的。</li>
</ul>
</li>
<li><strong><code>string&amp;&amp;</code></strong>：
<ul>
<li>专门绑定右值。</li>
<li>适合需要修改右值或通过移动构造函数优化性能的场景。</li>
</ul>
</li>
</ul>
<p><strong>（5）函数的右值引用参数</strong></p>
<p>PPT中涉及到的函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; r)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>右值引用参数的意义</strong></p>
<ul>
<li>接收右值，避免不必要的拷贝。</li>
<li>结合 <code>std::move</code>，可以将左值转为右值，触发移动构造函数或移动赋值操作。</li>
</ul>
<p><strong><code>const string&amp;</code> 和 <code>string&amp;</code> 是否可以绑定右值？</strong></p>
<p><strong>1. 左值、右值与引用的基础概念</strong></p>
<ul>
<li><strong>左值（Lvalue）</strong>：有名字的、可以取地址的对象。
<ul>
<li>例如：<code>int x = 5;</code> 中的 <code>x</code> 是左值。</li>
</ul>
</li>
<li><strong>右值（Rvalue）</strong>：没有名字、不能直接取地址的临时值。
<ul>
<li>例如：<code>5</code>、<code>x + 1</code> 是右值。</li>
</ul>
</li>
<li><strong>左值引用（<code>T&amp;</code>）</strong>：只能绑定到左值。</li>
<li><strong>右值引用（<code>T&amp;&amp;</code>）</strong>：只能绑定到右值。</li>
</ul>
<p><strong>2. <code>const string&amp;</code> 可以绑定右值</strong></p>
<p>是的，<code>const string&amp;</code> <strong>可以绑定右值</strong>。</p>
<p><strong>原因</strong></p>
<p><code>const</code> 修饰的左值引用可以绑定到<strong>临时对象（右值）</strong>，以延长临时对象的生命周期，直到引用离开作用域。</p>
<p><strong>示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> string&amp; ref = <span class="built_in">string</span>(<span class="string">&quot;Hello, World!&quot;</span>);  <span class="comment">// 右值绑定到 const 左值引用</span></span><br><span class="line">    cout &lt;&lt; ref &lt;&lt; endl;  <span class="comment">// 输出：Hello, World!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行过程</strong></p>
<ol>
<li><code>string(&quot;Hello, World!&quot;)</code> 是一个临时对象（右值）。</li>
<li>使用 <code>const string&amp;</code> 引用绑定该右值。</li>
<li>临时对象的生命周期被延长，直到引用 <code>ref</code> 离开作用域。</li>
</ol>
<p><strong>限制：为什么需要 <code>const</code>？</strong></p>
<p>如果不加 <code>const</code>，编译器不允许绑定右值，因为右值表示的是临时对象，可能会被销毁。而非 <code>const</code> 引用允许修改被引用的对象，无法保证临时对象的安全。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string&amp; ref = <span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>);  <span class="comment">// 错误：非 const 左值引用不能绑定右值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>错误信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: invalid initialization of non-const reference of type &#x27;string&amp;&#x27; from an rvalue of type &#x27;string&#x27;</span><br></pre></td></tr></table></figure>
<p><strong>3. <code>string&amp;</code> 不能绑定右值</strong></p>
<p>非 <code>const</code> 左值引用（<code>string&amp;</code>）只能绑定到左值，不能绑定右值。</p>
<p><strong>原因</strong></p>
<ul>
<li>右值是一个临时对象，可能会被销毁。</li>
<li>非 <code>const</code> 引用允许修改被引用的对象，但修改右值是无意义的（因为右值即将被销毁）。</li>
</ul>
<p><strong>4. 右值引用（<code>string&amp;&amp;</code>）可以绑定右值</strong></p>
<p>为了解决右值绑定的问题，C++11 引入了<strong>右值引用（<code>T&amp;&amp;</code>）</strong>，它专门用于绑定右值。</p>
<p><strong>示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string&amp;&amp; rref = <span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>);  <span class="comment">// 右值引用绑定右值</span></span><br><span class="line">    rref += <span class="string">&quot;, World!&quot;</span>;               <span class="comment">// 允许修改右值</span></span><br><span class="line">    cout &lt;&lt; rref &lt;&lt; endl;             <span class="comment">// 输出：Hello, World!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行过程</strong></p>
<ol>
<li>临时对象 <code>string(&quot;Hello&quot;)</code> 是右值，可以绑定到右值引用 <code>string&amp;&amp; rref</code>。</li>
<li><strong>可以对右值引用 <code>rref</code> 进行修改，因为右值引用拥有右值的所有权</strong>。</li>
<li>临时对象的生命周期被延长，直到引用离开作用域。</li>
</ol>
<p><strong>5. 总结</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>是否可以绑定左值</th>
<th>是否可以绑定右值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>T&amp;</code>（左值引用）</td>
<td>✅ 可以</td>
<td>❌ 不可以</td>
</tr>
<tr>
<td><code>const T&amp;</code>（常量左值引用）</td>
<td>✅ 可以</td>
<td>✅ 可以</td>
</tr>
<tr>
<td><code>T&amp;&amp;</code>（右值引用）</td>
<td>❌ 不可以</td>
<td>✅ 可以</td>
</tr>
</tbody>
</table>
<p><strong>总结规则</strong></p>
<ol>
<li><strong><code>const T&amp;</code> 可以绑定右值</strong>，临时对象的生命周期会被延长到引用的作用域结束。</li>
<li><strong><code>T&amp;</code> 不能绑定右值</strong>，只能绑定左值。</li>
<li><strong><code>T&amp;&amp;</code> 专门用于绑定右值</strong>，适用于移动语义和右值优化。</li>
</ol>
<h2 id="动态内存">动态内存</h2>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241219113715537.png" class="" title="image-20241219113715537">
<p><strong>1. 操作系统中的内存分区</strong></p>
<p>操作系统提供两种主要的内存分配区域：<strong>栈（Stack）</strong> 和 <strong>堆（Heap）</strong>，它们用于不同类型的内存管理。</p>
<p><strong>栈（Stack）</strong></p>
<ul>
<li>
<p><strong>特点</strong>：</p>
<ul>
<li>栈内存用于存储<strong>局部变量</strong>和<strong>按值传递的函数参数</strong>。</li>
<li>分配和释放由编译器自动完成。</li>
<li>内存分配速度快，但容量有限。</li>
</ul>
</li>
<li>
<p><strong>应用</strong>：</p>
<ul>
<li>
<p>局部变量，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;  <span class="comment">// 存储在栈中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>函数参数（按值传递时）。</p>
</li>
</ul>
</li>
<li>
<p><strong>栈的特性</strong>：</p>
<ul>
<li><strong>后进先出（LIFO）</strong>：内存分配按调用顺序进行，函数结束时自动回收。</li>
</ul>
</li>
</ul>
<p><strong>堆（Heap）</strong></p>
<ul>
<li>
<p>特点：</p>
<ul>
<li>堆内存用于动态分配内存。</li>
<li>开发者通过<strong>显式操作</strong>分配和释放内存。</li>
<li>容量大，但分配速度相对较慢。</li>
</ul>
</li>
<li>
<p>应用：</p>
<ul>
<li>
<p>动态分配的大对象或数据结构，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>];  <span class="comment">// 在堆中分配100个整数的数组</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>堆内存需要开发者<strong>手动释放</strong>，否则会导致<strong>内存泄漏</strong>。</p>
</li>
</ul>
</li>
</ul>
<p><strong>2. C语言中的动态内存</strong></p>
<p>C语言通过以下函数实现动态内存管理：</p>
<p><strong>malloc()</strong></p>
<ul>
<li>
<p><strong>用途</strong>：从堆中分配指定大小的内存，返回一块未初始化的内存地址。</p>
</li>
<li>
<p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 分配5个整数的空间</span></span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>free()</strong></p>
<ul>
<li>
<p><strong>用途</strong>：释放由 <code>malloc()</code> 分配的内存。</p>
</li>
<li>
<p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span>* ptr)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(ptr);  <span class="comment">// 释放动态分配的内存</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>注意事项</strong></p>
<ol>
<li>必须匹配 <code>malloc()</code> 和 <code>free()</code>，否则会导致<strong>内存泄漏</strong>。</li>
<li>释放后，不要再使用该指针（悬挂指针问题）。</li>
</ol>
<p><strong>3. C++中的动态内存</strong></p>
<p>C++ 提供了更高级的动态内存管理方式：<strong><code>new</code></strong> 和 <strong><code>delete</code></strong>。</p>
<p><strong>new</strong></p>
<ul>
<li>
<p><strong>用途</strong>：从堆中分配内存，并初始化对象。</p>
</li>
<li>
<p>语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T* ptr = <span class="keyword">new</span> T;            <span class="comment">// 为单个对象分配内存</span></span><br><span class="line">T* ptr = <span class="keyword">new</span> T[size];      <span class="comment">// 为数组分配内存</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>;          <span class="comment">// 分配一个整数</span></span><br><span class="line">*p = <span class="number">10</span>;                   <span class="comment">// 初始化为10</span></span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];     <span class="comment">// 分配一个整数数组</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>delete</strong></p>
<ul>
<li>
<p><strong>用途</strong>：释放由 <code>new</code> 分配的内存。</p>
</li>
<li>
<p>语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> ptr;                <span class="comment">// 释放单个对象</span></span><br><span class="line"><span class="keyword">delete</span>[] ptr;              <span class="comment">// 释放数组</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p;                  <span class="comment">// 释放单个整数</span></span><br><span class="line"><span class="keyword">delete</span>[] arr;              <span class="comment">// 释放整数数组</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>注意事项</strong></p>
<ol>
<li>必须匹配 <code>new</code> 和 <code>delete</code>。</li>
<li>使用 <code>delete</code> 释放动态分配的对象后，最好将指针置为 <code>nullptr</code>，避免悬挂指针问题。</li>
</ol>
<p><strong>C++中的动态内存 vs C语言</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>C语言</th>
<th>C++</th>
</tr>
</thead>
<tbody>
<tr>
<td>分配函数</td>
<td><code>malloc()</code></td>
<td><code>new</code></td>
</tr>
<tr>
<td>释放函数</td>
<td><code>free()</code></td>
<td><code>delete</code> / <code>delete[]</code></td>
</tr>
<tr>
<td>是否需要强制转换</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否支持对象构造与析构</td>
<td>否</td>
<td>是</td>
</tr>
</tbody>
</table>
<p><strong>4. 示例代码：C++动态内存管理</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 动态分配一个整数</span></span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    *p = <span class="number">42</span>;  <span class="comment">// 初始化</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态分配一个数组</span></span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        arr[i] = i * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;arr[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放动态内存</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Value: 42</span><br><span class="line">arr[0] = 0</span><br><span class="line">arr[1] = 10</span><br><span class="line">arr[2] = 20</span><br><span class="line">arr[3] = 30</span><br><span class="line">arr[4] = 40</span><br></pre></td></tr></table></figure>
<p><strong>5. 常见问题</strong></p>
<p><strong>（1）内存泄漏</strong></p>
<ul>
<li>
<p>动态分配的内存如果未被释放，会造成<strong>内存泄漏</strong>。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">p = <span class="literal">nullptr</span>;  <span class="comment">// 原来的内存未释放，泄漏</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>（2）悬挂指针</strong></p>
<ul>
<li>
<p>动态分配的内存被释放后，指针仍然指向该内存，称为<strong>悬挂指针</strong>。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">*p = <span class="number">42</span>;  <span class="comment">// 悬挂指针，未定义行为</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>6. 总结</strong></p>
<p><strong>操作系统的内存分区</strong></p>
<ol>
<li><strong>栈（Stack）</strong>：用于局部变量和函数参数，自动管理。</li>
<li><strong>堆（Heap）</strong>：用于动态分配内存，开发者手动管理。</li>
</ol>
<p><strong>C语言动态内存</strong></p>
<ul>
<li><code>malloc()</code>：分配动态内存。</li>
<li><code>free()</code>：释放动态内存。</li>
</ul>
<p><strong>C++动态内存</strong></p>
<ul>
<li><code>new</code>：分配动态内存，并自动调用构造函数。</li>
<li><code>delete</code>：释放动态内存，并自动调用析构函数。</li>
</ul>
<h2 id="动态对象">动态对象</h2>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241219114254387.png" class="" title="image-20241219114254387">
<p><strong>1. 动态对象是什么？</strong></p>
<p>动态对象是通过<strong>动态内存分配</strong>在**堆（Heap）**中创建的对象。与局部变量或静态对象不同，动态对象的生命周期完全由开发者控制，需要显式分配和释放内存。</p>
<p><strong>动态对象的特点</strong></p>
<ol>
<li><strong>在堆中分配</strong>：
<ul>
<li>使用 <code>new</code> 操作符为对象分配内存。</li>
<li>与栈上对象相比，动态对象的生命周期不会随函数退出而自动销毁。</li>
</ul>
</li>
<li><strong>显式释放内存</strong>：
<ul>
<li>使用 <code>delete</code> 操作符释放动态分配的内存。</li>
<li>如果不释放，会导致内存泄漏。</li>
</ul>
</li>
</ol>
<p><strong>2. 为什么需要 <code>new</code> 和 <code>delete</code> 操作符？</strong></p>
<p>在 C++ 中，<code>new</code> 和 <code>delete</code> 的引入是为了解决以下问题：</p>
<p><strong>（1）动态分配内存，构造和析构自动调用</strong></p>
<ul>
<li>C++ 中的类通常需要构造函数和析构函数来完成对象的初始化和销毁。</li>
<li><strong><code>new</code> 和 <code>delete</code></strong> 不仅用于动态分配和释放内存，还会自动调用类的构造函数和析构函数。</li>
</ul>
<p><strong>示例：动态对象的构造与析构</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>() &#123; cout &lt;&lt; <span class="string">&quot;Constructor called!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">Example</span>() &#123; cout &lt;&lt; <span class="string">&quot;Destructor called!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Example* obj = <span class="keyword">new</span> Example;  <span class="comment">// 动态分配对象，并调用构造函数</span></span><br><span class="line">    <span class="keyword">delete</span> obj;                  <span class="comment">// 释放对象，并调用析构函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor called!</span><br><span class="line">Destructor called!</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong></p>
<ol>
<li>
<pre><code>new Example
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   ：</span><br><span class="line"></span><br><span class="line">   - 在堆上分配内存，并调用 `Example` 的构造函数。</span><br><span class="line"></span><br><span class="line">2. ```</span><br><span class="line">   delete obj</span><br></pre></td></tr></table></figure>

：

- 调用对象的析构函数，然后释放内存。

</code></pre>
</li>
</ol>
<p><strong>（2）与 C 的 <code>malloc()</code> 和 <code>free()</code> 的区别</strong></p>
<p>在 C 中，<code>malloc()</code> 和 <code>free()</code> 只能分配和释放内存，但无法调用构造函数和析构函数。C++ 的 <code>new</code> 和 <code>delete</code> 是 <code>malloc()</code> 和 <code>free()</code> 的改进版本，适用于面向对象的内存管理。</p>
<p><strong>对比表</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>malloc()</code> / <code>free()</code></th>
<th><code>new</code> / <code>delete</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>内存分配</td>
<td>手动分配，返回 <code>void*</code></td>
<td>自动分配，返回正确类型</td>
</tr>
<tr>
<td>类型安全</td>
<td>❌ 需要强制转换</td>
<td>✅ 不需要强制转换</td>
</tr>
<tr>
<td>构造函数/析构函数调用</td>
<td>❌ 不支持</td>
<td>✅ 自动调用</td>
</tr>
</tbody>
</table>
<p><strong>（3）管理动态内存的灵活性</strong></p>
<ol>
<li>堆上的对象可以在函数结束后继续存在，适用于需要跨函数使用的对象。</li>
<li>在运行时动态创建对象，适合处理未知大小的数据结构，例如链表、树等。</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241219114637371.png" class="" title="image-20241219114637371">
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241219114732640.png" class="" title="image-20241219114732640">
<p><strong>1. <code>new</code> 操作符的基本概念</strong></p>
<p><strong><code>new</code> 的作用</strong></p>
<ul>
<li><code>new</code> 是 C++ 中用于动态分配内存的操作符。</li>
<li>可以用于创建<strong>基本类型</strong>（如 <code>int</code>、<code>float</code> 等）和<strong>类对象</strong>。</li>
<li>动态分配的内存位于堆（heap）中，而不是栈（stack）。</li>
</ul>
<p><strong>2. <code>new</code> 的用法</strong></p>
<p><strong>语法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type* ptrName = <span class="keyword">new</span> type;                <span class="comment">// 调用默认构造函数</span></span><br><span class="line">type* ptrName = <span class="keyword">new</span> <span class="built_in">type</span>(params);       <span class="comment">// 调用带参数构造函数</span></span><br></pre></td></tr></table></figure>
<p><strong>解析</strong></p>
<ol>
<li><code>type*</code>：
<ul>
<li>表示返回的指针类型。</li>
<li>动态分配的内存地址会存储在 <code>ptrName</code> 中。</li>
</ul>
</li>
<li><code>new type</code>：
<ul>
<li>在堆中分配 <code>sizeof(type)</code> 大小的内存，并调用 <code>type</code> 的默认构造函数。</li>
</ul>
</li>
<li><code>new type(params)</code>：
<ul>
<li>调用 <code>type</code> 的带参数构造函数进行初始化。</li>
</ul>
</li>
</ol>
<p><strong>3. 使用 <code>new</code> 创建对象</strong></p>
<p><strong>（1）创建基本类型的动态对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>;         <span class="comment">// 动态分配内存，未初始化</span></span><br><span class="line">    *p = <span class="number">42</span>;                  <span class="comment">// 手动初始化</span></span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;       <span class="comment">// 输出：42</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> p;                 <span class="comment">// 释放动态内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">42</span><br></pre></td></tr></table></figure>
<p><strong>（2）创建类对象的动态对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>() &#123; cout &lt;&lt; <span class="string">&quot;Default Constructor Called&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">int</span> x) &#123; cout &lt;&lt; <span class="string">&quot;Parameterized Constructor Called with &quot;</span> &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">Example</span>() &#123; cout &lt;&lt; <span class="string">&quot;Destructor Called&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Example* obj1 = <span class="keyword">new</span> Example;        <span class="comment">// 调用默认构造函数</span></span><br><span class="line">    Example* obj2 = <span class="keyword">new</span> <span class="built_in">Example</span>(<span class="number">10</span>);    <span class="comment">// 调用带参数构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> obj1;  <span class="comment">// 调用析构函数并释放内存</span></span><br><span class="line">    <span class="keyword">delete</span> obj2;  <span class="comment">// 调用析构函数并释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Default Constructor Called</span><br><span class="line">Parameterized Constructor Called with 10</span><br><span class="line">Destructor Called</span><br><span class="line">Destructor Called</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<p><strong><code>new</code> 的特点</strong></p>
<ol>
<li>用于动态分配内存，支持基本类型和类对象。</li>
<li>对于类对象，会自动调用构造函数完成初始化。</li>
</ol>
<p><strong><code>delete</code> 的特点</strong></p>
<ol>
<li>用于释放动态分配的内存。</li>
<li>对于类对象，会自动调用析构函数完成清理。</li>
</ol>
<p><strong>语法对比</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建单个对象</td>
<td><code>int* p = new int(42);</code></td>
<td>动态分配一个整数，初始化为 42</td>
</tr>
<tr>
<td>创建类对象</td>
<td><code>Example* obj = new Example(10);</code></td>
<td>动态分配类对象，调用构造函数</td>
</tr>
<tr>
<td>释放单个对象</td>
<td><code>delete p;</code></td>
<td>调用析构函数并释放内存</td>
</tr>
</tbody>
</table>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241219184925693.png" class="" title="image-20241219184925693">
<p><strong>1. 动态分配的关键点</strong></p>
<p><strong>动态对象是匿名的</strong></p>
<ul>
<li>使用 <code>new</code> 操作符动态分配的对象<strong>没有名字</strong>，只能通过指针访问。</li>
<li>指针保存的是动态分配对象的地址，指针本身有名字（例如：<code>intPtr</code>、<code>carPtr</code>），但动态分配的内存没有直接的标识符。</li>
</ul>
<p><strong>指针大小与数据大小无关</strong></p>
<ul>
<li>无论动态分配的对象有多大，指针的大小在同一系统中是固定的（通常是 4 字节或 8 字节，取决于系统的架构）。</li>
</ul>
<p><strong>2. PPT中的注意事项</strong></p>
<p><strong>（1）动态分配对象是匿名的</strong></p>
<ul>
<li>
<p>动态分配的对象没有名字，只能通过指针访问。</p>
</li>
<li>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Car* carPtr = <span class="keyword">new</span> <span class="built_in">Car</span>(<span class="string">&quot;Nissan&quot;</span>, <span class="string">&quot;Pulsar&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>carPtr</code> 是指针变量的名字。</li>
<li>动态分配的 <code>Car</code> 对象在堆中，没有直接的名字。</li>
</ul>
</li>
</ul>
<p><strong>（2）指针大小与对象大小无关</strong></p>
<ul>
<li>在 32 位系统中，所有指针占用 4 字节。</li>
<li>在 64 位系统中，所有指针占用 8 字节。</li>
<li>动态分配的对象大小与指针大小无关：
<ul>
<li>例如，<code>int</code> 占用 4 字节，<code>Car</code> 类可能占用几十字节，但指向它们的指针大小固定。</li>
</ul>
</li>
</ul>
<p><strong>3. 动态分配的生命周期</strong></p>
<ol>
<li>
<p>动态分配的对象存在于堆中：</p>
<ul>
<li>由 <code>new</code> 分配的内存不受作用域限制，必须显式释放。</li>
</ul>
</li>
<li>
<p>销毁时调用析构函数：</p>
<ul>
<li>
<p>使用 <code>delete</code> 释放动态对象时，会自动调用析构函数。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> carPtr;  <span class="comment">// 调用 carPtr 指向对象的析构函数</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<p><strong>动态分配的核心特点</strong></p>
<ol>
<li>使用 <code>new</code> 动态分配内存，并返回对象地址。</li>
<li>动态对象是匿名的，只能通过指针访问。</li>
<li>指针大小固定，与动态分配对象的大小无关。</li>
<li>必须使用 <code>delete</code> 显式释放动态分配的内存。</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241219185630315.png" class="" title="image-20241219185630315">
<ul>
<li>
<p><code>malloc</code> 仅分配原始的内存空间，但不会初始化对象。</p>
</li>
<li>
<p><code>free</code> 只释放内存，但不会调用析构函数。</p>
</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241219193944689.png" class="" title="image-20241219193944689">
<p><code>delete</code> 是 C++ 中用于释放动态分配的内存的操作符。它既可以用于<strong>基本数据类型</strong>的动态内存，也可以用于<strong>类对象</strong>的动态内存。</p>
<p><strong>特点</strong></p>
<ol>
<li><strong>调用析构函数</strong>（如果是类对象）。</li>
<li>释放内存：
<ul>
<li>释放动态分配的堆内存，使得这块内存可以被重新分配。</li>
</ul>
</li>
<li>防止内存泄漏：
<ul>
<li>通过释放不再使用的内存，避免程序长期运行时耗尽内存。</li>
</ul>
</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241219194159145.png" class="" title="image-20241219194159145">
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241219195349924.png" class="" title="image-20241219195349924">
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241219195417202.png" class="" title="image-20241219195417202">
<h2 id="const成员">const成员</h2>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241219195517779.png" class="" title="image-20241219195517779">
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241219195533209.png" class="" title="image-20241219195533209">
<p><strong>1. <code>const</code> 成员的核心概念</strong></p>
<p><strong>（1）什么是 <code>const</code> 成员？</strong></p>
<ol>
<li><code>const</code> 数据成员：
<ul>
<li>用 <code>const</code> 修饰的类成员变量，在初始化后不能被修改。</li>
<li>必须通过构造函数初始化。</li>
</ul>
</li>
<li><code>const</code> 成员函数：
<ul>
<li>在函数声明和定义时以 <code>const</code> 关键字结尾的成员函数。</li>
<li>特点：
<ul>
<li>保证不会修改类的成员变量（除 <code>mutable</code> 修饰的变量外）。</li>
<li>只能被 <code>const</code> 对象调用。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>（2）示例代码</strong></p>
<p><strong>类成员的定义</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x1, <span class="type">int</span> y1) : <span class="built_in">x</span>(x1), <span class="built_in">y</span>(y1) &#123;&#125;  <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;                            <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>;                   <span class="comment">// const 成员函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>void f()</code> 是一个普通成员函数，可以修改 <code>x</code> 和 <code>y</code>。</li>
<li><code>void show() const</code> 是一个 <code>const</code> 成员函数，不能修改类的任何数据成员。</li>
</ul>
<p><strong>2. <code>const</code> 成员函数的行为</strong></p>
<p><strong>（1）普通成员函数</strong></p>
<ul>
<li>
<p>普通成员函数可以修改类的成员变量。</p>
</li>
<li>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x = <span class="number">1</span>;  <span class="comment">// 修改类的成员变量</span></span><br><span class="line">    y = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>（2）<code>const</code> 成员函数</strong></p>
<ul>
<li>
<p><code>const</code> 成员函数不能修改类的成员变量。</p>
</li>
<li>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y;  <span class="comment">// 只能读取成员变量，不能修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>3. <code>const</code> 对象与成员函数</strong></p>
<p><strong>（1）<code>const</code> 对象的特点</strong></p>
<ul>
<li><code>const</code> 对象是被声明为 <code>const</code> 的类对象。</li>
<li>限制：
<ul>
<li>只能调用 <code>const</code> 成员函数。</li>
<li><strong>不能调用普通成员函数</strong>，因为普通成员函数可能会修改对象的状态。</li>
</ul>
</li>
</ul>
<p><strong>示例代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> A <span class="title">a</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;  <span class="comment">// 定义一个 const 对象</span></span><br><span class="line">a.<span class="built_in">f</span>();            <span class="comment">// 错误，不能调用普通成员函数</span></span><br><span class="line">a.<span class="built_in">show</span>();         <span class="comment">// 正确，可以调用 const 成员函数</span></span><br></pre></td></tr></table></figure>
<ul>
<li>解释：
<ul>
<li><code>a.f()</code> 会被编译器拒绝，因为 <code>f()</code> 不是 <code>const</code> 成员函数，可能会修改 <code>a</code> 的成员变量。</li>
<li><code>a.show()</code> 是合法的，因为 <code>show()</code> 是 <code>const</code> 成员函数，保证不会修改 <code>a</code>。</li>
</ul>
</li>
</ul>
<p><strong>（2）<code>const</code> 成员函数的隐式 <code>this</code> 指针</strong></p>
<ul>
<li>普通成员函数的 <code>this</code> 指针类型是 <code>A*</code>。</li>
<li><code>const</code> 成员函数的 <code>this</code> 指针类型是 <code>const A*</code>。</li>
<li>因此，<code>const</code> 成员函数只能访问 <code>const</code> 成员，不能修改成员变量。</li>
</ul>
<p><strong>函数声明示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(A* <span class="type">const</span> <span class="keyword">this</span>)</span></span>;          <span class="comment">// 普通成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> A* <span class="type">const</span> <span class="keyword">this</span>)</span></span>; <span class="comment">// const 成员函数</span></span><br></pre></td></tr></table></figure>
<p><strong>4. <code>mutable</code> 关键字的作用</strong></p>
<p><strong>（1）<code>mutable</code> 修饰的成员变量</strong></p>
<ul>
<li>即使在 <code>const</code> 对象中，<code>mutable</code> 修饰的成员变量也可以被修改。</li>
<li>用途：
<ul>
<li>用于需要在逻辑上保持 <code>const</code>，但某些成员变量需要修改的场景。</li>
</ul>
</li>
</ul>
<p><strong>（2）示例代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> count;  <span class="comment">// 使用 mutable 修饰</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        count++;  <span class="comment">// 修改 mutable 成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> A a;</span><br><span class="line">    a.<span class="built_in">show</span>();  <span class="comment">// 修改了 count，合法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解释</strong></p>
<ul>
<li><code>count</code> 是一个 <code>mutable</code> 成员变量，可以在 <code>const</code> 对象中被修改。</li>
<li><code>show()</code> 是一个 <code>const</code> 成员函数，但可以合法地修改 <code>mutable</code> 成员变量。</li>
</ul>
<p><strong>5. 编译器的角色</strong></p>
<p>PPT 中提到 <code>compiler</code>：</p>
<ul>
<li>作用：
<ul>
<li>编译器会检查 <code>const</code> 规则，确保：
<ol>
<li><code>const</code> 成员函数不会修改成员变量。</li>
<li><code>const</code> 对象只能调用 <code>const</code> 成员函数。</li>
</ol>
</li>
<li>如果违反规则，编译器会报错。</li>
</ul>
</li>
</ul>
<p><strong>6. 右侧代码的解析</strong></p>
<p><strong>代码部分</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span>&amp; indirect_int;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">indirect_int</span>(*<span class="keyword">new</span> <span class="type">int</span>)&#123; ... &#125;  <span class="comment">// 构造函数，动态分配 int</span></span><br><span class="line">    ~<span class="built_in">A</span>() &#123; <span class="keyword">delete</span> &amp;indirect_int; &#125;       <span class="comment">// 析构函数，释放内存</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span> </span>&#123; indirect_int++; &#125;   <span class="comment">// const 成员函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>解析</strong></p>
<ol>
<li>动态分配内存：
<ul>
<li><code>A()</code> 构造函数使用 <code>new</code> 动态分配内存，并初始化 <code>indirect_int</code>（引用类型）。</li>
</ul>
</li>
<li>析构函数：
<ul>
<li><code>~A()</code> 析构函数释放动态分配的内存，避免内存泄漏。</li>
</ul>
</li>
<li><code>f()</code> 是一个 const 成员函数：
<ul>
<li>虽然是 <code>const</code> 成员函数，但它<strong>通过引用 <code>indirect_int</code> 修改了动态分配的内存。</strong></li>
<li>因为 <code>indirect_int</code> 是一个引用，而<strong>引用所指向的值可以修改，因此不会违反 <code>const</code> 规则</strong>。</li>
</ul>
</li>
</ol>
<p><strong>7. 总结</strong></p>
<p><strong><code>const</code> 成员函数的特点</strong></p>
<ol>
<li>保证成员函数不会修改成员变量（除 <code>mutable</code> 成员外），引用变量的引用值也可以被修改。</li>
<li>可以被 <code>const</code> 对象调用。</li>
<li>隐式 <code>this</code> 指针为 <code>const A*</code>。</li>
</ol>
<p><strong><code>const</code> 对象的限制</strong></p>
<ol>
<li>只能调用 <code>const</code> 成员函数。</li>
<li>保证对象的状态在生命周期内不会改变。</li>
</ol>
<p><strong>注意点</strong></p>
<ul>
<li><code>mutable</code> 关键字允许在 <code>const</code> 对象中修改成员变量。</li>
<li>编译器会严格检查 <code>const</code> 规则，确保代码安全性和逻辑正确性。</li>
</ul>
<p><strong>为什么 <code>void f() const &#123; indirect_int++; &#125;</code> 是合法的？</strong></p>
<p><strong>1. 引用（<code>int&amp;</code>）成员变量的本质</strong></p>
<p>引用（<code>int&amp;</code>）是一个别名，它本质上是对另一块内存的间接访问。一个引用成员变量（例如 <code>int&amp; indirect_int</code>）有以下特点：</p>
<ol>
<li>引用本身不可变：
<ul>
<li>一旦一个引用被初始化，它就永久绑定到所引用的对象。</li>
<li>引用的绑定不能被改变，也就是说，你不能让 <code>indirect_int</code> 引用一个新的整数。</li>
</ul>
</li>
<li>引用指向的值可以修改：
<ul>
<li><strong>引用的指向不可以改变，但它所绑定的内存内容是可以被修改的。</strong></li>
</ul>
</li>
</ol>
<p>因此，<code>indirect_int++</code> 并不是在改变引用的绑定，而是在改变引用所指向的对象的值。</p>
<p><strong>2. <code>const</code> 成员函数的限制</strong></p>
<p>在 C++ 中，<code>const</code> 成员函数的作用是：</p>
<ul>
<li>保证不会修改当前对象的<strong>成员变量</strong>，除非这些成员变量被 <code>mutable</code> 修饰。</li>
</ul>
<p>当你将成员函数声明为 <code>const</code> 时，编译器会隐式地将 <code>this</code> 指针视为 <code>const</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>隐式等价于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> A* <span class="type">const</span> <span class="keyword">this</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>如何影响成员变量？</strong></p>
<ol>
<li>普通成员变量：
<ul>
<li>普通的非引用成员变量在 <code>const</code> 成员函数中是不可修改的，因为 <code>this</code> 被视为 <code>const</code>。</li>
</ul>
</li>
<li>引用成员变量：
<ul>
<li>引用成员变量本质上是对其他内存的别名。在 <code>const</code> 成员函数中，你不能修改引用的绑定（即让它指向别的对象），但你可以修改它所引用的内容。</li>
<li>换句话说，<strong><code>const</code> 限制的是引用本身的绑定，而不是它所指向的值。</strong></li>
</ul>
</li>
</ol>
<p>因此，在 <code>void f() const</code> 中，修改 <code>indirect_int</code> 所引用的值是合法的，因为没有违反 <code>const</code> 的规则。</p>
<p><strong>3. 为什么编译器允许这种操作？</strong></p>
<p>在代码中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    indirect_int++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>const</code> 的行为限制</strong></p>
<ul>
<li>编译器只会限制对<strong>成员变量本身</strong>的直接修改，而不会限制通过引用或指针间接修改它们所指向的值。</li>
<li><code>indirect_int</code> 是一个引用，因此修改它指向的值<strong>并不是直接修改成员变量本身</strong>，而是<strong>通过引用间接修改了另一块内存</strong>。</li>
</ul>
<p><strong>示例</strong></p>
<p>等价于以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>&amp; indirect_int = value;</span><br><span class="line">indirect_int++;  <span class="comment">// 这是合法的，因为引用的值可以修改</span></span><br></pre></td></tr></table></figure>
<p>在这里，<code>value</code> 是引用绑定的真实对象，而 <code>indirect_int</code> 只是 <code>value</code> 的别名。</p>
<p><strong>总结</strong></p>
<p><strong>为什么合法？</strong></p>
<ol>
<li><code>indirect_int</code> 是一个引用，<code>const</code> 成员函数只限制引用本身的绑定（即 <code>indirect_int</code> 必须一直绑定到同一对象），但不限制引用所指向的对象的修改。</li>
<li>因此，<code>indirect_int++</code> 实际上是通过引用间接修改了引用所指向的值，这符合 <code>const</code> 成员函数的规则。</li>
</ol>
<p><strong>关键点</strong></p>
<ol>
<li><code>const</code> 成员函数中的限制作用于成员变量本身，而不作用于通过指针或引用间接访问的内容。</li>
<li>引用的行为类似于指针，<code>const</code> 不限制对引用所指向值的修改。</li>
</ol>
<h3 id="const-A-const-this">const A* const this</h3>
<p>在 <code>const A* const this</code> 中，两个 <code>const</code> 分别修饰了不同的内容，具有不同的意义。</p>
<p><strong>1. <code>const A*</code> 的含义</strong></p>
<ul>
<li><strong><code>const A*</code> 表示 <code>this</code> 指针指向的是一个 <code>const A</code> 类型的对象</strong>。</li>
<li>换句话说，<strong><code>this</code> 指针指向的对象是常量，不能通过 <code>this</code> 修改对象的成员变量</strong>（除非成员变量是 <code>mutable</code>）。</li>
</ul>
<p>在成员函数中，<code>this</code> 指针是隐式传递的。对于 <code>const</code> 成员函数，<code>this</code> 的类型被隐式转换为 <code>const A*</code>，表示当前对象是只读的，成员函数不能修改这个对象的非 <code>mutable</code> 成员变量。</p>
<p><strong>示例代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">        x = <span class="number">42</span>;  <span class="comment">// 错误：不能修改 `const` 对象的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 <code>f()</code> 中，<code>this</code> 是 <code>const A*</code> 类型，因此成员变量 <code>x</code> 被视为只读。</li>
</ul>
<p><strong>2. 第二个 <code>const</code> 的含义</strong></p>
<ul>
<li><strong><code>const this</code> 表示 <code>this</code> 指针本身是常量</strong>。</li>
<li>换句话说，<code>this</code> 指针的地址不能被修改。</li>
</ul>
<p>在 C++ 中，<code>this</code> 指针默认是一个普通的指针，可以被用来表示当前对象的地址。但在 <code>const</code> 成员函数中，<code>this</code> 指针本身是只读的，不能被重新赋值。</p>
<p><strong>完整解释 <code>const A* const this</code></strong></p>
<ol>
<li>第一个 <code>const</code>：
<ul>
<li>修饰 <code>A</code>，表示 <code>this</code> 指针指向的对象是 <code>const</code>，对象的非 <code>mutable</code> 成员变量不能被修改。</li>
</ul>
</li>
<li>第二个 <code>const</code>：
<ul>
<li>修饰 <code>this</code> 指针本身，表示 <code>this</code> 指针的地址是 <code>const</code>，不能被修改。</li>
</ul>
</li>
</ol>
<p><strong>3. 举例说明</strong></p>
<p><strong>非 <code>const</code> 成员函数的 <code>this</code> 指针</strong></p>
<p>对于普通成员函数，<code>this</code> 是一个非 <code>const</code> 指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="comment">/* `this` 的类型是 A* */</span> &#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>const</code> 成员函数的 <code>this</code> 指针</strong></p>
<p>对于 <code>const</code> 成员函数，<code>this</code> 是一个指向 <code>const</code> 对象的常量指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">/* `this` 的类型是 const A* const */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>这意味着：</p>
<ol>
<li>不能通过 <code>this</code> 修改当前对象的非 <code>mutable</code> 成员变量。</li>
<li>不能修改 <code>this</code> 指针本身（即不能改变它指向的地址）。</li>
</ol>
<p><strong>4. 示例：两个 <code>const</code> 的作用</strong></p>
<p>以下代码展示了两个 <code>const</code> 的实际作用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> y;  <span class="comment">// `mutable` 成员可以在 `const` 对象中修改</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val), <span class="built_in">y</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modifyX</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// x = 10;  // 错误：`x` 是非 `mutable` 成员，不能在 `const` 成员函数中修改</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modifyY</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        y = <span class="number">10</span>;  <span class="comment">// 正确：`y` 是 `mutable` 成员，可以修改</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changeThisPointer</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this = nullptr;  // 错误：`this` 是 `const` 指针，不能修改指针本身的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> A <span class="title">obj</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    obj.<span class="built_in">modifyY</span>();  <span class="comment">// 修改 `mutable` 成员变量</span></span><br><span class="line">    obj.<span class="built_in">print</span>();    <span class="comment">// 输出：x = 5, y = 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = 5, y = 10</span><br></pre></td></tr></table></figure>
<p><strong>解释</strong></p>
<ol>
<li><code>modifyX()</code> 试图修改非 <code>mutable</code> 成员变量 <code>x</code>，被编译器拒绝。</li>
<li><code>modifyY()</code> 修改了 <code>mutable</code> 成员变量 <code>y</code>，是合法的。</li>
<li><code>changeThisPointer()</code> 试图修改 <code>this</code> 指针本身的地址，编译器拒绝。</li>
</ol>
<p><strong>5. 总结</strong></p>
<ul>
<li><code>const A*</code>：
<ul>
<li>限制 <code>this</code> 指针指向的对象是 <code>const</code>，不能修改对象的非 <code>mutable</code> 成员变量。</li>
</ul>
</li>
<li><code>const this</code>：
<ul>
<li>限制 <code>this</code> 指针本身是只读的，不能重新赋值 <code>this</code>。</li>
</ul>
</li>
</ul>
<p><code>const A* const this</code> 是 <code>const</code> 成员函数中 <code>this</code> 指针的默认类型，确保：</p>
<ol>
<li>对象的状态在函数执行期间不会被修改。</li>
<li><code>this</code> 指针不会被改变。</li>
</ol>
<h2 id="静态成员">静态成员</h2>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241219201748108.png" class="" title="image-20241219201748108">
<p><strong>1. 什么是静态成员？</strong></p>
<p><strong>静态成员变量</strong></p>
<ul>
<li>定义： 静态成员变量是用 <code>static</code> 修饰的类成员变量。
<ul>
<li>它<strong>属于类本身</strong>，而不是属于某个特定的对象。</li>
<li>无论创建了多少个类的对象，静态成员变量只会有一份共享的存储空间。</li>
</ul>
</li>
<li>特点：
<ol>
<li>静态成员变量是类的全局属性，不属于具体的某个对象。</li>
<li>静态成员变量在所有类对象间共享（<strong>对一个对象修改，其他对象看到的值也会改变</strong>）。</li>
<li>静态成员变量在程序运行时分配内存，只有一份实例。</li>
</ol>
</li>
</ul>
<p><strong>静态成员函数</strong></p>
<ul>
<li><strong>定义</strong>： 静态成员函数是用 <code>static</code> 修饰的类成员函数。
<ul>
<li>它<strong>只能访问静态成员变量</strong>，不能访问非静态成员变量。</li>
<li>它不依赖于类的对象，<strong>可以通过类名直接调用</strong>。</li>
</ul>
</li>
<li><strong>特点</strong>：
<ol>
<li>静态成员函数<strong>属于类本身</strong>，而不是类的某个对象。</li>
<li>静态成员函数没有 <code>this</code> 指针。</li>
<li>它<strong>只能访问类的静态成员</strong>（包括静态成员变量和其他静态成员函数）。</li>
</ol>
</li>
</ul>
<p><strong>2. 为什么需要静态成员？</strong></p>
<p>PPT 中提出的问题：</p>
<ul>
<li>“同一个类的不同对象如何共享变量？”
<ul>
<li>静态成员提供了一种机制，允许同一个类的不同对象共享一份数据，而无需将这些变量定义为全局变量。</li>
</ul>
</li>
</ul>
<p><strong>问题分析</strong></p>
<ol>
<li><strong>为什么不能用全局变量？</strong>
<ul>
<li>全局变量对于整个程序是可见的，可能会被其他不相关的代码误修改，从而导致数据污染（缺乏数据保护）。</li>
<li>名字可能冲突，容易引起命名污染。</li>
</ul>
</li>
<li><strong>静态成员的优势</strong>
<ul>
<li>静态成员属于类，而不是全局空间，具有更好的封装性。</li>
<li>静态成员可以通过类名访问，具有清晰的语义。</li>
</ul>
</li>
</ol>
<p><strong>3. 静态成员变量的声明与定义</strong></p>
<p><strong>声明</strong></p>
<p>静态成员变量需要在<strong>类内声明</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;  <span class="comment">// 声明静态成员变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>定义</strong></p>
<p>静态成员变量需要在<strong>类外定义</strong>（并初始化）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A::count = <span class="number">0</span>;  <span class="comment">// 定义并初始化</span></span><br></pre></td></tr></table></figure>
<p><strong>调用</strong></p>
<ol>
<li>
<p>静态成员函数可以通过类名直接调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A::<span class="built_in">display</span>();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>也可以通过对象调用，但不推荐：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">a.<span class="built_in">display</span>();  <span class="comment">// 不推荐</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>4. 静态成员的特点</strong></p>
<p><strong>静态成员变量</strong></p>
<ol>
<li>共享性：
<ul>
<li>静态成员变量只有一份拷贝，所有对象共享。</li>
</ul>
</li>
<li>作用域：
<ul>
<li>在<strong>类的作用域内声明，在类外定义和初始化</strong>。</li>
</ul>
</li>
<li>生命周期：
<ul>
<li>静态成员变量的生命周期贯穿整个程序运行。</li>
</ul>
</li>
</ol>
<p><strong>静态成员函数</strong></p>
<ol>
<li>独立性：
<ul>
<li>静态成员函数与对象无关，可以通过类名调用。</li>
</ul>
</li>
<li>限制性：
<ul>
<li>静态成员函数<strong>无法访问非静态成员变量和函数</strong>。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<p><strong>静态成员的用途</strong></p>
<ol>
<li>跨对象共享数据：
<ul>
<li>静态成员变量提供了一种机制，让同一个类的不同对象可以共享数据。</li>
</ul>
</li>
<li>与类相关的操作：
<ul>
<li>静态成员函数用于执行与整个类相关的操作（例如计数、管理共享资源）。</li>
</ul>
</li>
</ol>
<p><strong>注意事项</strong></p>
<ul>
<li><strong>静态成员变量在类外定义时，不能使用 <code>static</code> 关键字</strong>。</li>
<li>静态成员函数不能访问非静态成员。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241219203834940.png" class="" title="image-20241219203834940">
<hr>
<p><strong>特点</strong></p>
<ol>
<li><strong>类对象共享</strong>：
<ul>
<li>静态成员变量是类的全局属性，所有对象共享同一份数据。</li>
<li>无论创建多少个对象，静态成员变量在内存中只存储一次。</li>
</ul>
</li>
<li><strong>唯一拷贝</strong>：
<ul>
<li>静态成员变量属于类，而不是属于类的某个对象。</li>
<li>所有对象都可以访问和修改它，但它只存在一份。</li>
</ul>
</li>
<li><strong>生命周期长</strong>：
<ul>
<li>静态成员变量的生命周期从程序开始到结束。</li>
<li>在整个程序运行期间，静态成员变量始终保存在内存中。</li>
</ul>
</li>
<li><strong>作用域受控（遵循类访问控制）</strong>：
<ul>
<li>静态成员变量的访问权限受类的访问控制符（如 <code>public</code>、<code>protected</code>、<code>private</code>）的限制。</li>
<li>这种机制避免了直接暴露全局变量所带来的安全问题。</li>
</ul>
</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241219204200675.png" class="" title="image-20241219204200675">
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241219204340241.png" class="" title="image-20241219204340241">
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241219204401833.png" class="" title="image-20241219204401833">
<h3 id="单例模式">单例模式</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241219204739421.png" class="" title="image-20241219204739421">
<h2 id="友元">友元</h2>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241219205101183.png" class="" title="image-20241219205101183">
<p><strong>1. 什么是友元？</strong></p>
<p>在 C++ 中，类的 <strong><code>private</code></strong> 和 <strong><code>protected</code></strong> 成员默认只能被该类的成员函数（包括构造函数、析构函数）和其派生类的成员函数访问。<strong>友元</strong> 的引入打破了这个限制，使得其他函数或类可以访问指定类的 <code>private</code> 和 <code>protected</code> 成员。</p>
<ul>
<li><strong>友元是类的特殊成员</strong>，允许外部函数或其他类访问它的私有成员。</li>
<li>友元关系不是对等的：
<ul>
<li>如果 <code>ClassA</code> 是 <code>ClassB</code> 的友元，<code>ClassB</code> 不能自动成为 <code>ClassA</code> 的友元。</li>
</ul>
</li>
</ul>
<p><strong>为什么需要友元？</strong></p>
<ul>
<li>默认情况下，类的私有成员只能通过该类的公共方法访问。</li>
<li>在某些情况下，这种封装限制可能会降低程序的效率或灵活性。
<ul>
<li>例如，两个类需要共享内部信息协作，或者外部函数需要操作类的私有数据。</li>
</ul>
</li>
<li>使用友元可以提高访问效率，简化代码。</li>
</ul>
<p><strong>2. 友元的定义与声明</strong></p>
<p>在 C++ 中，可以通过 <strong><code>friend</code></strong> 关键字声明友元。友元可以是：</p>
<ol>
<li><strong>普通函数</strong>（全局函数或类外的独立函数）。</li>
<li><strong>另一个类</strong>（使该类的所有成员函数成为当前类的友元）。</li>
<li><strong>类的成员函数</strong>（使另一个类的某个成员函数成为当前类的友元）。</li>
</ol>
<p><strong>友元函数的声明</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> ReturnType <span class="title">FunctionName</span><span class="params">(Parameters)</span></span>; <span class="comment">// 声明友元函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>友元类的声明</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">FriendClass</span>; <span class="comment">// 声明友元类</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>友元成员函数的声明</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> ReturnType <span class="title">FriendClass::MemberFunctionName</span><span class="params">(Parameters)</span></span>; <span class="comment">// 声明友元成员函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>3. PPT 示例解析</strong></p>
<p>PPT 上提到以下几个关键点：</p>
<ul>
<li><strong>普通访问限制</strong>：
<ul>
<li>类的外部函数不能直接访问类的 <code>private</code> 成员变量。</li>
<li>必须通过类的 <code>public</code> 方法访问。</li>
<li>这种方式可能会增加额外的访问开销，缺乏灵活性。</li>
</ul>
</li>
<li><strong>解决方案</strong>：通过友元机制，可以让外部函数或类直接访问类的 <code>private</code> 成员。</li>
</ul>
<p><strong>矩阵和向量的示例</strong></p>
<p>PPT 中提到：</p>
<blockquote>
<p><strong>例：矩阵类（Matrix）、向量类（Vector）和全局函数（<code>multiply</code>）实现矩阵和向量相乘。</strong></p>
</blockquote>
<hr>
<p><strong>代码示例</strong></p>
<p>假设我们要实现矩阵和向量相乘，矩阵类和向量类中的数据存储在 <code>private</code> 成员中。如果不使用友元，外部函数 <code>multiply</code> 无法直接访问矩阵和向量的私有数据。</p>
<p>通过友元机制，可以解决这一问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向量类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩阵类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; mat; <span class="comment">// 矩阵数据</span></span><br><span class="line">    <span class="type">int</span> rows, cols;          <span class="comment">// 行数和列数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Matrix</span>(<span class="type">int</span> r, <span class="type">int</span> c) : <span class="built_in">rows</span>(r), <span class="built_in">cols</span>(c), <span class="built_in">mat</span>(r, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c, <span class="number">0</span>)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setElement</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        mat[r][c] = value; <span class="comment">// 设置矩阵元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; row : mat) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> val : row) &#123;</span><br><span class="line">                cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> vector&lt;<span class="type">int</span>&gt; <span class="title">multiply</span><span class="params">(<span class="type">const</span> Matrix&amp; m, <span class="type">const</span> Vector&amp; v)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向量类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec; <span class="comment">// 向量数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>(<span class="type">int</span> size) : <span class="built_in">vec</span>(size, <span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setElement</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        vec[index] = value; <span class="comment">// 设置向量元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : vec) &#123;</span><br><span class="line">            cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> vector&lt;<span class="type">int</span>&gt; <span class="title">multiply</span><span class="params">(<span class="type">const</span> Matrix&amp; m, <span class="type">const</span> Vector&amp; v)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局友元函数：矩阵和向量相乘</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">multiply</span><span class="params">(<span class="type">const</span> Matrix&amp; m, <span class="type">const</span> Vector&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m.cols != v.vec.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;Matrix columns must match Vector size&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(m.rows, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 矩阵乘以向量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m.rows; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m.cols; ++j) &#123;</span><br><span class="line">            result[i] += m.mat[i][j] * v.vec[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 2x3 矩阵</span></span><br><span class="line">    <span class="function">Matrix <span class="title">mat</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    mat.<span class="built_in">setElement</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    mat.<span class="built_in">setElement</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    mat.<span class="built_in">setElement</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    mat.<span class="built_in">setElement</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    mat.<span class="built_in">setElement</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">    mat.<span class="built_in">setElement</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Matrix:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    mat.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个大小为 3 的向量</span></span><br><span class="line">    <span class="function">Vector <span class="title">vec</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    vec.<span class="built_in">setElement</span>(<span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line">    vec.<span class="built_in">setElement</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">    vec.<span class="built_in">setElement</span>(<span class="number">2</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Vector:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    vec.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 矩阵和向量相乘</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result = <span class="built_in">multiply</span>(mat, vec);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Result:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : result) &#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码解析</strong></p>
<ol>
<li><strong>类的封装性</strong>：
<ul>
<li>矩阵类的 <code>mat</code> 和向量类的 <code>vec</code> 都是私有成员，外部函数无法直接访问。</li>
<li>保持了数据的封装性。</li>
</ul>
</li>
<li><strong>友元函数 <code>multiply</code></strong>：
<ul>
<li><code>multiply</code> 是矩阵类和向量类的友元。</li>
<li>它可以直接访问 <code>Matrix::mat</code> 和 <code>Vector::vec</code>，高效完成矩阵和向量相乘。</li>
</ul>
</li>
<li><strong>友元的必要性</strong>：
<ul>
<li>如果没有友元，必须为 <code>mat</code> 和 <code>vec</code> 提供 <code>getter</code> 方法，增加了代码复杂性和运行时开销。</li>
</ul>
</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241220081700368.png" class="" title="image-20241220081700368">
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241220081754872.png" class="" title="image-20241220081754872">
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241220081825639.png" class="" title="image-20241220081825639">
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241220081838974.png" class="">
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241220081908036.png" class="" title="image-20241220081908036">
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241220081919781.png" class="" title="image-20241220081919781">
<ul>
<li><strong>友元不是传递性的</strong>：
<ul>
<li>必须明确声明谁是友元，友元关系不会自动传播到其他类或函数。</li>
</ul>
</li>
<li><strong>是的，可以编译</strong>，前提是 <code>multiply</code> 函数的定义与声明匹配，并且 <code>Matrix</code> 和 <code>Vector</code> 都正确声明了它为友元函数。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/CPP-2-1/image-20241220082131830.png" class="" title="image-20241220082131830">
<p><strong>1. Law of Demeter（迪米特法则）简介</strong></p>
<p><strong>核心理念</strong></p>
<ul>
<li>避免暴露内部数据成员（data member）：
<ul>
<li>在类的公共接口中，尽量不要直接暴露内部数据成员（即不应将成员变量设为 <code>public</code>）。</li>
<li>强调通过函数（方法）间接访问数据，以提高封装性和安全性。</li>
</ul>
</li>
</ul>
<p><strong>为什么要遵循这个原则？</strong></p>
<ol>
<li>保护数据完整性：
<ul>
<li>避免外部直接修改类的私有数据。</li>
<li>通过 getter 和 setter 方法，可以添加额外的逻辑进行检查或转换。</li>
</ul>
</li>
<li>增强代码的可维护性：
<ul>
<li>如果数据成员需要重构或改变，只需修改类内部实现，调用方无需感知。</li>
</ul>
</li>
<li>减少依赖耦合：
<ul>
<li>外部代码无需了解类的具体实现细节，从而降低耦合性。</li>
</ul>
</li>
</ol>
<p><strong>2. 避免将数据成员暴露在公共接口</strong></p>
<p>PPT 提到：</p>
<blockquote>
<p><strong>“避免将 data member 放在公共接口中”</strong></p>
</blockquote>
<ul>
<li>这是对类的 <strong>封装性（Encapsulation）</strong> 的要求。</li>
<li>数据成员应始终声明为 <code>private</code> 或 <code>protected</code>。</li>
<li>外部代码访问类的数据成员时，必须通过公共接口（<code>public</code> 方法）实现，而不是直接访问。</li>
</ul>
<p><strong>3. 类设计示例</strong></p>
<p>PPT 中的示例代码展示了一个名为 <code>AccessLevels</code> 的类，包含几个私有数据成员和相应的访问方法。</p>
<p><strong>代码解析</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccessLevels</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 只读属性的访问器</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getReadOnly</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> readOnly; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可读写属性的访问器和修改器</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setReadWrite</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123; readWrite = value; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getReadWrite</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> readWrite; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只写属性的修改器</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setWriteOnly</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123; writeOnly = value; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> noAccess;     <span class="comment">// 无访问权限（仅限类内部使用）</span></span><br><span class="line">    <span class="type">int</span> readOnly;     <span class="comment">// 只读属性</span></span><br><span class="line">    <span class="type">int</span> readWrite;    <span class="comment">// 可读写属性</span></span><br><span class="line">    <span class="type">int</span> writeOnly;    <span class="comment">// 只写属性</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>关键点解析</strong></p>
<ol>
<li><strong><code>noAccess</code></strong>:
<ul>
<li>该变量完全对外部不可见。</li>
<li>没有提供任何 getter 或 setter 方法，只能由类内部的方法操作。</li>
<li>这是最严格的封装，适用于纯粹的内部实现细节。</li>
</ul>
</li>
<li><strong><code>readOnly</code></strong>:
<ul>
<li>提供了 <code>getReadOnly()</code> 方法，但没有对应的 setter 方法。</li>
<li>这是一个只读属性，外部只能读取，不能修改。</li>
</ul>
</li>
<li><strong><code>readWrite</code></strong>:
<ul>
<li>提供了 <code>getReadWrite()</code> 和 <code>setReadWrite()</code> 方法。</li>
<li>这是一个可读写属性，外部可以通过 getter 方法读取值，通过 setter 方法修改值。</li>
</ul>
</li>
<li><strong><code>writeOnly</code></strong>:
<ul>
<li>提供了 <code>setWriteOnly()</code> 方法，但没有对应的 getter 方法。</li>
<li>这是一个只写属性，外部只能写入值，不能读取。</li>
</ul>
</li>
</ol>
<p><strong>优点</strong></p>
<ul>
<li>
<p>通过 getter 和 setter 控制数据访问，可以对数据的读取和修改添加额外的逻辑。</p>
<ul>
<li>
<p>例如，在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setReadWrite()</span><br></pre></td></tr></table></figure>
<p>方法中，可以添加范围检查：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setReadWrite</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value &gt;= <span class="number">0</span> &amp;&amp; value &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">        readWrite = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Value out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>避免直接暴露数据成员，提高了类的安全性和灵活性。</p>
</li>
<li>
<p>不同的访问级别（如只读、只写、可读写）可以根据需求灵活实现。</p>
</li>
</ul>
<p><strong>4. 访问控制的矩阵</strong></p>
<p>PPT 提供了一个访问控制矩阵，总结了不同访问权限的用法：</p>
<table>
<thead>
<tr>
<th>访问级别</th>
<th><code>Get</code></th>
<th><code>Set</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>R</code>（只读）</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td><code>W</code>（只写）</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td><code>RW</code>（可读写）</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td><code>NONE</code>（无访问权限）</td>
<td>❌</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p><strong>具体对应</strong></p>
<ul>
<li><code>readOnly</code> 对应 <code>R</code>：提供 getter 方法，但没有 setter 方法。</li>
<li><code>writeOnly</code> 对应 <code>W</code>：提供 setter 方法，但没有 getter 方法。</li>
<li><code>readWrite</code> 对应 <code>RW</code>：同时提供 getter 和 setter 方法。</li>
<li><code>noAccess</code> 对应 <code>NONE</code>：既没有 getter 方法，也没有 setter 方法。</li>
</ul>
<p><strong>5. 努力让接口完整（complete）且最小化（minimal）</strong></p>
<p>PPT 提到：</p>
<blockquote>
<p><strong>“努力让接口完整且最小化”</strong></p>
</blockquote>
<ul>
<li>完整性（complete）：
<ul>
<li>确保类的接口能够满足用户的需求。</li>
<li>例如，如果用户需要读取和修改某个属性，就应该同时提供 getter 和 setter 方法。</li>
</ul>
</li>
<li>最小化（minimal）：
<ul>
<li>避免暴露不必要的接口，保持接口的简洁性。</li>
<li>例如，<strong>如果某个属性只需要提供读取功能，就不必为其提供 setter 方法。</strong></li>
</ul>
</li>
</ul>
<p><strong>原则</strong>：只暴露必要的接口，隐藏实现细节。</p>
<p><strong>6. 总结</strong></p>
<p><strong>PPT 的核心内容</strong></p>
<ol>
<li>数据成员应设置为 <code>private</code>，通过公共方法（getter 和 setter）访问。</li>
<li>根据需要，灵活设计访问方法（只读、只写、可读写）。</li>
<li>遵循封装性原则，避免直接暴露内部数据成员。</li>
</ol>
<p><strong>封装的优点</strong></p>
<ul>
<li>提高代码的安全性和可维护性。</li>
<li>避免数据污染，确保数据的一致性。</li>
<li>降低耦合性，使类的实现可以自由修改而不影响调用者。</li>
</ul>
<p><strong>Demeter 法则的应用</strong></p>
<ul>
<li><strong>避免过度暴露数据成员</strong>，通过方法访问。</li>
<li><strong>减少对象间的直接依赖</strong>，提高代码的模块化程度。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Liu Kai-Qi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/01/25/CPP-2-1/">http://example.com/2025/01/25/CPP-2-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">ChocStar🍫</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">C++高级程序设计</a></div><div class="post-share"><div class="social-share" data-image="/img/C++.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="prev-post pull-left" href="/2025/01/25/C6/" title="C++高级程序设计笔记（C6）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++高级程序设计笔记（C6）</div></div></a><a class="next-post pull-right" href="/2025/01/25/CPP-2-4/" title="C++高级程序设计笔记（C2-4）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++高级程序设计笔记（C2-4）</div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a href="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" title="C++高级程序设计笔记（C1-C4）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-25</div><div class="title">C++高级程序设计笔记（C1-C4）</div></div></a><a href="/2025/01/25/C7/" title="C++高级程序设计笔记（C7）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-25</div><div class="title">C++高级程序设计笔记（C7）</div></div></a><a href="/2025/01/25/C8/" title="C++高级程序设计笔记（C8）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-25</div><div class="title">C++高级程序设计笔记（C8）</div></div></a><a href="/2025/01/25/C5/" title="C++高级程序设计笔记（C5）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-25</div><div class="title">C++高级程序设计笔记（C5）</div></div></a><a href="/2025/01/25/C6/" title="C++高级程序设计笔记（C6）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-25</div><div class="title">C++高级程序设计笔记（C6）</div></div></a><a href="/2025/01/25/CPP-2-4/" title="C++高级程序设计笔记（C2-4）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-25</div><div class="title">C++高级程序设计笔记（C2-4）</div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Liu Kai-Qi</div><div class="author-info-description">Sometimes you have to go for it</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/liukqchoco"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/liukqchoco" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">CPP-2-1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">1.2.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A1%A8"><span class="toc-number">1.4.</span> <span class="toc-text">成员初始化表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.</span> <span class="toc-text">拷贝构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.</span> <span class="toc-text">移动构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98"><span class="toc-number">1.8.</span> <span class="toc-text">动态内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.9.</span> <span class="toc-text">动态对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const%E6%88%90%E5%91%98"><span class="toc-number">1.10.</span> <span class="toc-text">const成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#const-A-const-this"><span class="toc-number">1.10.1.</span> <span class="toc-text">const A* const this</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">1.11.</span> <span class="toc-text">静态成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.11.1.</span> <span class="toc-text">单例模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-number">1.12.</span> <span class="toc-text">友元</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" title="C++高级程序设计笔记（C1-C4）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++高级程序设计笔记（C1-C4）"/></a><div class="content"><a class="title" href="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" title="C++高级程序设计笔记（C1-C4）">C++高级程序设计笔记（C1-C4）</a><time datetime="2025-01-25T14:10:32.000Z" title="发表于 2025-01-25 22:10:32">2025-01-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/25/C7/" title="C++高级程序设计笔记（C7）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++高级程序设计笔记（C7）"/></a><div class="content"><a class="title" href="/2025/01/25/C7/" title="C++高级程序设计笔记（C7）">C++高级程序设计笔记（C7）</a><time datetime="2025-01-25T14:10:32.000Z" title="发表于 2025-01-25 22:10:32">2025-01-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/25/C8/" title="C++高级程序设计笔记（C8）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++高级程序设计笔记（C8）"/></a><div class="content"><a class="title" href="/2025/01/25/C8/" title="C++高级程序设计笔记（C8）">C++高级程序设计笔记（C8）</a><time datetime="2025-01-25T14:10:32.000Z" title="发表于 2025-01-25 22:10:32">2025-01-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/25/C5/" title="C++高级程序设计笔记（C5）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++高级程序设计笔记（C5）"/></a><div class="content"><a class="title" href="/2025/01/25/C5/" title="C++高级程序设计笔记（C5）">C++高级程序设计笔记（C5）</a><time datetime="2025-01-25T14:10:32.000Z" title="发表于 2025-01-25 22:10:32">2025-01-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/25/C6/" title="C++高级程序设计笔记（C6）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++高级程序设计笔记（C6）"/></a><div class="content"><a class="title" href="/2025/01/25/C6/" title="C++高级程序设计笔记（C6）">C++高级程序设计笔记（C6）</a><time datetime="2025-01-25T14:10:32.000Z" title="发表于 2025-01-25 22:10:32">2025-01-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Liu Kai-Qi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>(() => {
  const panguFn = () => {
    if (typeof pangu === 'object') pangu.autoSpacingPage()
    else {
      btf.getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
        .then(() => {
          pangu.autoSpacingPage()
        })
    }
  }

  const panguInit = () => {
    if (false){
      GLOBAL_CONFIG_SITE.isPost && panguFn()
    } else {
      panguFn()
    }
  }

  btf.addGlobalFn('pjaxComplete', panguInit, 'pangu')
  document.addEventListener('DOMContentLoaded', panguInit)
})()</script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="你要找什么呀" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>