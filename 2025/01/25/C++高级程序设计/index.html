<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++高级程序设计笔记（C1-C4） | ChocStar🍫</title><meta name="author" content="Liu Kai-Qi"><meta name="copyright" content="Liu Kai-Qi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++高级程序设计（C1-C4) C1 introduction C2 static_cast  基本类型之间的转换  static_cast&lt;&gt; 通常用于转换基本数据类型（如 int、float、double、char 等）之间的转换。在这种情况下，它的行为与 C 语言的强制类型转换很相似。 注意： 当不同基本类型之间的转换可能会导致信息丢失或精度损失时，static_cast&amp;lt">
<meta property="og:type" content="article">
<meta property="og:title" content="C++高级程序设计笔记（C1-C4）">
<meta property="og:url" content="http://example.com/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/index.html">
<meta property="og:site_name" content="ChocStar🍫">
<meta property="og:description" content="C++高级程序设计（C1-C4) C1 introduction C2 static_cast  基本类型之间的转换  static_cast&lt;&gt; 通常用于转换基本数据类型（如 int、float、double、char 等）之间的转换。在这种情况下，它的行为与 C 语言的强制类型转换很相似。 注意： 当不同基本类型之间的转换可能会导致信息丢失或精度损失时，static_cast&amp;lt">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/C++.jpg">
<meta property="article:published_time" content="2025-01-25T14:10:32.000Z">
<meta property="article:modified_time" content="2025-02-05T09:29:42.304Z">
<meta property="article:author" content="Liu Kai-Qi">
<meta property="article:tag" content="C++高级程序设计">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/C++.jpg"><link rel="shortcut icon" href="/img/web_label.png"><link rel="canonical" href="http://example.com/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: Liu Kai-Qi","link":"链接: ","source":"来源: ChocStar🍫","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++高级程序设计笔记（C1-C4）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-02-05 17:29:42'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/background.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post type-C++高级程序设计" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/C++.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">ChocStar🍫</span></a><a class="nav-page-title" href="/"><span class="site-name">C++高级程序设计笔记（C1-C4）</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">C++高级程序设计笔记（C1-C4）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-25T14:10:32.000Z" title="发表于 2025-01-25 22:10:32">2025-01-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-05T09:29:42.304Z" title="更新于 2025-02-05 17:29:42">2025-02-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">C++高级程序设计</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">24.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>89分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>C++高级程序设计（C1-C4)</h1>
<h1>C1</h1>
<h2 id="introduction">introduction</h2>
<h1>C2</h1>
<h2 id="static-cast">static_cast</h2>
<ol>
<li><strong>基本类型之间的转换</strong></li>
</ol>
<p><code>static_cast&lt;&gt;</code> 通常用于转换基本数据类型（如 <code>int</code>、<code>float</code>、<code>double</code>、<code>char</code> 等）之间的转换。在这种情况下，<strong>它的行为与 C 语言的强制类型转换很相似。</strong></p>
<p><strong>注意：</strong> 当不同基本类型之间的转换可能会导致信息丢失或精度损失时，<code>static_cast&lt;&gt;</code> 并不会发出警告。例如，将一个 <code>double</code> 转换为 <code>int</code> 时，小数部分会被截断。</p>
<ol start="2">
<li><strong>指针类型的转换</strong></li>
</ol>
<p><code>static_cast&lt;&gt;</code> 也可以用来在不同类型的指针之间进行转换，但只允许类型之间存在合法转换关系（例如，父类与子类之间的转换）。它不能用于将完全不相关的指针类型相互转换（如 <code>int*</code> 转换为 <code>char*</code> ）。如果你需要进行这种不安全的转换，应该使用 <code>reinterpret_cast&lt;&gt;</code>。</p>
<ol start="3">
<li><strong>类层次之间的转换</strong></li>
</ol>
<p><code>static_cast&lt;&gt;</code> 可以在类的继承层次结构中进行上下转换（即子类指针和父类指针之间的转换）。</p>
<ul>
<li><strong>从子类到父类的转换</strong> 是安全的，因为每个子类对象也都是父类对象，这种转换不需要特别的检查。</li>
<li><strong>从父类到子类的转换</strong> 可能存在危险，因为父类对象不一定包含子类的部分。为了保证程序的正确性，开发者在使用这种转换时应确保父类对象实际上是子类对象。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Animal* a = <span class="keyword">new</span> <span class="built_in">Dog</span>();           <span class="comment">// 安全的向上转换</span></span><br><span class="line">Dog* d = <span class="built_in">static_cast</span>&lt;Dog*&gt;(a);   <span class="comment">// 可能不安全的向下转换</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，向上转换（从子类 <code>Dog</code> 到父类 <code>Animal</code>）总是安全的；向下转换（从 <code>Animal*</code> 到 <code>Dog*</code>）只有在 <strong><code>a</code> 实际上指向 <code>Dog</code> 对象时才安全。</strong></p>
<ol start="4">
<li><strong>避免隐式类型转换</strong></li>
</ol>
<p>有时候我们想要避免隐式类型转换所带来的困扰，例如当我们从 <code>int</code> 转换到 <code>float</code> 时，程序会自动完成转换。但如果你希望明确控制类型转换，可以使用 <code>static_cast&lt;&gt;</code> 来提高代码的可读性，并表明你有意识地进行类型转换。</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> y = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(x); <span class="comment">// 比直接写为 float y = x; 更加显式和清晰</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li><strong>禁止不安全的转换</strong></li>
</ol>
<p>虽然 <code>static_cast&lt;&gt;</code> 能够进行一些比较灵活的转换，但它是有一些限制的，它不能做完全不安全的类型转换。例如，将两个完全不相关的类型（比如 <code>int*</code> 和 <code>float*</code>）之间相互转换是非法的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int* pInt = nullptr;</span><br><span class="line">float* pFloat = static_cast&lt;float*&gt;(pInt); // 错误：编译器会报错</span><br></pre></td></tr></table></figure>
<p>如果你需要进行这样不安全的转换，你应该使用 <code>reinterpret_cast&lt;&gt;</code>，不过通常这类转换可能隐藏较大的风险。</p>
<ol start="6">
<li><strong>转换常量</strong></li>
</ol>
<p><code>static_cast&lt;&gt;</code> 不能移除对象的常量性（即不能去掉 <code>const</code> 限定符）。如果需要进行这种操作，需要使用 <code>const_cast&lt;&gt;</code>。<code>static_cast&lt;&gt;</code> 是一个更“安全”的转换，它只进行类型之间的转换，而不涉及对象的权限或常量性修改。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int a = 10;</span><br><span class="line">// int* p = static_cast&lt;int*&gt;(&amp;a); // 错误：不能通过static_cast移除const</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<ul>
<li><code>static_cast&lt;&gt;</code> 是一种编译时的类型转换方式。</li>
<li>它用于基本类型之间的转换、类继承体系中的上下转换、指针类型之间的转换等。</li>
<li>它在类型检查上比传统的强制类型转换更严格，但它<strong>并不进行运行时的类型安全检查，所以错误的转换在编译时不一定会被捕获。</strong></li>
<li><code>static_cast&lt;&gt;</code> 强调明确性和可读性，在进行数据类型转换时，能够减少潜在的隐式错误。</li>
</ul>
<p>你可以把 <code>static_cast&lt;&gt;</code> 理解为一种更安全、可控的类型转换工具，比传统的C风格转换更容易读懂，也更不容易出错。</p>
<h3 id="案例">案例</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241009093102614.png" class="" title="image-20241009093102614">
<p>这张PPT展示的是关于C++中使用 <code>static_cast&lt;&gt;</code> 进行类型转换的实验和结果。我们一步步详细解析里面的内容：</p>
<p><strong>左上角部分：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">123456789</span>;</span><br><span class="line"><span class="type">short</span> s = <span class="built_in">static_cast</span>&lt;<span class="type">short</span>&gt;(i);</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">int2B</span>(i) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">short2B</span>(s) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>int i = 123456789;</code>：这是一个32位整数，其二进制形式如下：
<ul>
<li>二进制: <code>000001110110111101111001101000101</code></li>
</ul>
</li>
<li><code>short s = static_cast&lt;short&gt;(i);</code>：将 <code>int</code> 类型的 <code>i</code> 转换成 <code>short</code> 类型。由于 <code>short</code> 是16位的，它无法容纳32位的整数。这个操作会丢弃高位，保留低16位，得到一个 <code>short</code> 类型的值：
<ul>
<li>高位丢失后: <code>110011010010101</code></li>
<li>这实际上是 <code>-13035</code>，因为最左边是1，表示负数（采用二进制补码形式）。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：从32位到16位的强制类型转换会导致数据截断（高位数据丢失），可能导致数值变化很大，如从正数变成负数。</p>
<p><strong>左中间部分：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;testing from int to float:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span> y = ~(<span class="number">1</span> &lt;&lt; <span class="number">23</span>);</span><br><span class="line"><span class="type">float</span> y1 = <span class="built_in">float</span>(y);</span><br></pre></td></tr></table></figure>
<p>这段代码测试从一个特殊的整数转换为浮点数的过程：</p>
<ol>
<li>
<p><strong><code>int y = ~(1 &lt;&lt; 23);</code></strong>:</p>
<ul>
<li>这段代码通过位运算生成了一个较大的负数。</li>
<li><code>1 &lt;&lt; 23</code> 表示将1左移23位，结果是：<code>100000000000000000000000</code>，即2的23次方。</li>
<li><code>~</code> 是按位取反操作，将这个数的所有位取反，即把高位1变成0，低位0变成1，得到的结果为：<code>-8388609</code>。</li>
</ul>
</li>
<li>
<p><strong>将 <code>y</code> 转换为 <code>float</code></strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> y1 = <span class="built_in">float</span>(y);</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 <code>float(y)</code> 将 <code>int</code> 类型的 <code>y</code> 转换为 <code>float</code> 类型。</li>
<li>因为浮点数和整数的表示方式不同，特别是在处理较大数值时，可能会出现精度损失。这里 <code>-8388609</code> 转换为 <code>float</code> 后，它的精度可能会有所变化。</li>
</ul>
</li>
<li>
<p><strong>输出结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">testing from int to float:</span><br><span class="line">before : -8388609 11111111111111111111111111111111</span><br><span class="line">after  : -8388609 11001011010000000000000000000001</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<ul>
<li><strong>整数表示</strong>：<code>-8388609</code> 的二进制表示为 <code>11111111111111111111111111111111</code>，是32位补码形式，表示负数。</li>
<li><strong>浮点数表示</strong>：<code>-8388609</code> 被转换为浮点数时，**虽然输出的值没有变化，但其二进制形式发生了变化。**浮点数的二进制形式遵循 IEEE 754 标准，由符号位、指数位和尾数位组成。由于浮点数存储精度的原因，特别是当整数的绝对值较大时，可能会发生精度损失。</li>
</ul>
</li>
<li>
<p><strong>总结：</strong></p>
<ol>
<li>整数转换为浮点数时，<strong>即使数值保持不变，其底层存储结构会发生较大的变化</strong>（从补码形式转变为浮点数的表示方式）。</li>
<li>此外，浮点数的存储可能会因精度问题丢失部分细节，尤其是在处理较大或较小的数字时。</li>
</ol>
</li>
</ol>
<p><strong>左下角部分：</strong></p>
<p>类似的测试再次执行，不过这次的整数 <code>y</code> 是 <code>~(1 &lt;&lt; 24)</code>，它会生成一个更大的负数 <code>-16777217</code>，再次验证了整数到浮点数转换时的精度损失。</p>
<p><strong>总结：</strong></p>
<ol>
<li>float尾数只有23位，他只能精确存储23位有效的二进制位。当一个数超出这个范围（如1&lt;&lt;24的24位）</li>
</ol>
<p><strong>右上角部分：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> f = <span class="number">1.25</span>;</span><br><span class="line"><span class="type">short</span> s = <span class="built_in">static_cast</span>&lt;<span class="type">short</span>&gt;(f);</span><br><span class="line">cout &lt;&lt; f &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">float2B</span>(f) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">short2B</span>(s) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>这段代码演示了将浮点数 <code>float</code> 转换为 <code>short</code> 类型：</p>
<ol>
<li><code>float f = 1.25;</code>：1.25 作为浮点数存储在内存中，浮点数的二进制表示较为复杂，这里使用IEEE 754标准来表示它。
<ul>
<li><code>float</code> 的二进制形式: <code>00111111101000000000000000000000</code></li>
</ul>
</li>
<li><code>short s = static_cast&lt;short&gt;(f);</code>这里<code>float</code>转换为<code>short</code>，即将小数部分去除，只保留整数部分 1
<ul>
<li><code>short</code> 的二进制形式: <code>0000000000000001</code></li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：将 <code>float</code> 转换为 <code>short</code> 时，浮点数的小数部分被丢弃，只保留整数部分。</p>
<p><strong>右中间部分：</strong></p>
<p><strong>总结：</strong></p>
<ol>
<li>
<p><strong>浮点数 <code>7.25</code> 的二进制表示</strong>：浮点数在内存中是按照 IEEE 754 标准存储的，它的二进制形式相当复杂，包括符号位、指数位和尾数位。<code>7.25</code> 的二进制形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01000000111010000000000000000000</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>float</code> 转换为 <code>short</code> 时的截断</strong>：当将浮点数 <code>7.25</code> 转换为 <code>short</code> 时，小数部分被截断，留下整数部分 <code>7</code>。<code>7</code> 的二进制表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000000000000111</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>类型转换中的截断</strong>：<code>static_cast&lt;short&gt;(f)</code> 将浮点数的精度降低，只保留整数部分，展示了数值类型之间的转换如何影响数据的表示方式。</p>
</li>
</ol>
<p><strong>右下角部分：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> s = <span class="number">45</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(s);</span><br></pre></td></tr></table></figure>
<p>这里测试了从 <code>short</code> 类型转换为 <code>float</code>：</p>
<ol>
<li><code>short s = 45;</code>：一个16位的短整型数 <code>45</code>。</li>
<li><code>float f = static_cast&lt;float&gt;(s);</code>：将 <code>short</code> 转换为 <code>float</code>，结果依然是45，因为45可以准确地表示为浮点数，不会有精度损失。</li>
</ol>
<p><strong>总结</strong>：对于较小的整数，转换为浮点数不会有精度问题。</p>
<p><strong>总结：</strong></p>
<p>PPT中的内容展示了 <code>static_cast</code> 类型转换在不同类型数据之间的效果，尤其是在 <code>int</code> 和 <code>float</code>，以及 <code>int</code> 和 <code>short</code> 之间的转换。需要注意的是：</p>
<ul>
<li><code>int</code> 转换为 <code>short</code> 可能会丢失高位数据，导致数值变化。</li>
<li><code>int</code> 转换为 <code>float</code> 时可能会因浮点数的精度（23位，十进制7位左右）限制导致精度损失。</li>
<li>小的整数转换为 <code>float</code> 不会出现问题，但较大的整数可能会受到浮点数精度的影响。</li>
</ul>
<h2 id="const-cast">const_cast</h2>
<p><code>const_cast&lt;&gt;</code> 专门用于<strong>移除或者添加对象的 <code>const</code> 或者 <code>volatile</code> 属性</strong>。<code>const_cast</code> 只能用于调整 <code>const</code> 和 <code>volatile</code> 属性，<strong>不能改变对象的实际类型。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">const_cast</span>&lt;new_type&gt;(expression)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>new_type</code></strong>：表示要转换成的新类型。通常是移除了 <code>const</code> 或者 <code>volatile</code> 限定符的类型。</li>
<li><strong><code>expression</code></strong>：表示要进行转换的表达式。</li>
</ul>
<p><strong>使用场景</strong>：</p>
<ol>
<li><strong>移除 <code>const</code> 限定符</strong>：<code>const_cast&lt;&gt;</code> 常用于将一个常量指针或引用转换为非常量（非 <code>const</code>）的类型，这样我们就可以修改本来是 <code>const</code> 的对象了。</li>
<li><strong>添加 <code>const</code> 限定符</strong>：虽然较少见，但 <code>const_cast&lt;&gt;</code> 也可以用来为非 <code>const</code> 的对象添加 <code>const</code> 限定符。</li>
</ol>
<p><strong>示例 1：移除 <code>const</code> 限定符</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span>* p)</span> </span>&#123;</span><br><span class="line">    *p = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">modify</span>(<span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;x));  <span class="comment">// 移除 const 限定符，使其可以被修改</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在这个例子中，<code>x</code> 被声明为 <code>const int</code>，表示 <code>x</code> 是一个常量，不能被修改。</li>
<li>使用 <code>const_cast&lt;int*&gt;</code> 移除了 <code>const</code> 限定符后，我们将 <code>x</code> 传递给 <code>modify</code> 函数，在该函数中可以对 <code>x</code> 进行修改。</li>
</ul>
<p><strong>注意</strong>：修改一个 <code>const</code> 对象可能导致未定义行为。如果对象本来是 <code>const</code>，修改它的行为在标准中没有定义，通常是不可预测的。这个例子仅仅说明 <code>const_cast</code> 的工作原理。</p>
<p><strong>示例 2：添加 <code>const</code> 限定符</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* p)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">const_cast</span>&lt;<span class="type">const</span> <span class="type">int</span>*&gt;(&amp;y));  <span class="comment">// 将非const的指针转换为const指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在这个例子中，<code>y</code> 是一个非常量整数，但我们使用 <code>const_cast</code> 将它转换为一个 <code>const int*</code>，这样就可以将其传递给接受 <code>const</code> 参数的 <code>print</code> 函数。</li>
</ul>
<p><strong>关键点：</strong></p>
<ol>
<li><strong>只能用于 <code>const</code> 和 <code>volatile</code> 的转换</strong>：<code>const_cast&lt;&gt;</code> 只能用于添加或移除 <code>const</code> 或 <code>volatile</code> 限定符，不能用于其他类型的转换。它不会影响对象的底层类型，也不会改变对象的值。</li>
<li><strong>避免未定义行为</strong>：尽管你可以通过 <code>const_cast</code> 移除 <code>const</code>，但如果你修改的是一个本来声明为 <code>const</code> 的对象，这种行为是 <strong>未定义行为</strong>，尽量避免这种操作。</li>
<li><strong>不进行其他类型的转换</strong>：<code>const_cast&lt;&gt;</code> 不能用于将 <code>int</code> 类型转换为 <code>float</code> 或者进行指针的重新解释（这是 <code>reinterpret_cast&lt;&gt;</code> 的作用）。它只能处理与 <code>const</code> 或 <code>volatile</code> 有关的限定符。</li>
</ol>
<p><strong>示例 3：移除 <code>volatile</code> 限定符</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>* p)</span> </span>&#123;</span><br><span class="line">    *p = <span class="number">100</span>;  <span class="comment">// 修改变量的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> z = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">func</span>(<span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;z));  <span class="comment">// 移除 volatile 限定符后对 z 进行修改</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>z</code> 被声明为 <code>volatile</code>，表示编译器不能对其进行优化，但通过 <code>const_cast</code>，我们可以移除 <code>volatile</code> 限定符并修改它。</li>
</ul>
<p><strong>常见的应用场景：</strong></p>
<ol>
<li><strong>接口设计</strong>：有时候你可能拥有一个只能返回 <code>const</code> 类型指针的接口，但实际使用中你希望能够修改它。这时可以使用 <code>const_cast</code> 来移除 <code>const</code> 限定符，达到修改的目的。</li>
<li><strong>遗留代码兼容</strong>：在需要兼容一些旧代码时，你可能遇到非 <code>const</code> 的 API，但你需要强制转换成 <code>const</code> 类型，这时也可以使用 <code>const_cast</code>。</li>
</ol>
<p><strong>总结：</strong></p>
<ul>
<li><strong><code>const_cast&lt;&gt;</code> 主要用于移除或者添加 <code>const</code> 和 <code>volatile</code> 限定符</strong>，不能用于其他类型的转换。</li>
<li><strong>使用 <code>const_cast&lt;&gt;</code> 修改常量对象可能会导致未定义行为</strong>，要谨慎使用。</li>
<li>它是 C++ 类型转换家族中一种非常有针对性的转换操作符，只处理类型的 <code>const</code> 和 <code>volatile</code> 限定符。</li>
</ul>
<h2 id="reinterpret-cast">reinterpret_cast</h2>
<p><code>reinterpret_cast&lt;&gt;</code> 是 C++ 中的一种类型转换操作符，它用于 <strong>强制重新解释</strong> 一个指针、引用或类型的位模式，而不改变位模式本身的内容。<code>reinterpret_cast&lt;&gt;</code> 是 C++ 中<strong>最危险的类型转换操作符之一</strong>，因为它允许几乎任意类型之间的转换，因此需要格外小心使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reinterpret_cast</span>&lt;new_type&gt;(expression)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>new_type</code></strong>：转换后的新类型，可以是指针、引用或其他类型。</li>
<li><strong><code>expression</code></strong>：要转换的对象，它的类型将被强制重新解释为 <code>new_type</code>。</li>
</ul>
<p><strong>使用场景</strong>：</p>
<p><code>reinterpret_cast&lt;&gt;</code> 通常用于两种情况下：</p>
<ol>
<li><strong>指针类型之间的转换</strong>：它可以将一个指针转换为其他不相关类型的指针（例如，将 <code>int*</code> 转换为 <code>float*</code>），即使这两个类型在内存中的位模式不同。它不会对数据进行任何修改，只是简单地重新解释内存中的位模式。</li>
<li><strong>整数和指针之间的转换</strong>：它可以在整数类型和指针类型之间进行转换。</li>
</ol>
<p><strong>行为</strong>：</p>
<ul>
<li>它不会改变数据本身的内容，只是将它的类型信息进行了强制转换。你可以将一块内存从一种类型转换成另一种类型进行访问。</li>
<li>它可以用于指针之间的转换，也可以用于整数与指针之间的转换。</li>
<li><code>reinterpret_cast&lt;&gt;</code> <strong>不会</strong>执行任何类型检查或者类型安全性验证，因此需要非常小心使用，错误的使用可能导致运行时错误或者未定义行为。</li>
</ul>
<p><strong>示例 1：指针类型之间的转换</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">float</span> *f = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">float</span>*&gt;(&amp;i);</span><br><span class="line">std::cout &lt;&lt; *f &lt;&lt; std::endl; <span class="comment">// 输出的是reinterpret后的浮点数解释，而不是42</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中：</p>
<ul>
<li><code>int</code> 类型的变量 <code>i</code> 被转换为指向 <code>float</code> 的指针 <code>f</code>。</li>
<li>当我们通过 <code>*f</code> 访问内存时，内存中的位模式被重新解释为浮点数，这样就输出了一个与 <code>42</code> 无关的浮点数值。</li>
</ul>
<p><strong>注意</strong>：这个操作很危险，因为 <code>int</code> 和 <code>float</code> 在内存中的表示方式是不同的。这种转换是低级的强制解释内存的操作，可能导致不可预见的结果。</p>
<p><strong>示例 2：整数和指针之间的转换</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span>* ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;x); <span class="comment">// 将int指针转换为void指针</span></span><br><span class="line"><span class="type">int</span>* p = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(ptr);    <span class="comment">// 将void指针再转换为int指针</span></span><br><span class="line">std::cout &lt;&lt; *p &lt;&lt; std::endl;            <span class="comment">// 输出 10</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在这个例子中，<code>reinterpret_cast&lt;&gt;</code> 被用来将一个 <code>int*</code> 转换为 <code>void*</code>，然后再将 <code>void*</code> 转换回 <code>int*</code>。</li>
<li>这是一种常见的用法，尤其是在需要进行低级别的内存操作时。</li>
</ul>
<p><strong>示例 3：类指针之间的转换</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Base* b = <span class="keyword">new</span> Base;</span><br><span class="line">Derived* d = <span class="built_in">reinterpret_cast</span>&lt;Derived*&gt;(b);</span><br></pre></td></tr></table></figure>
<ul>
<li>在这个例子中，<code>Base*</code> 类型的指针 <code>b</code> 被强制转换为 <code>Derived*</code> 类型的指针 <code>d</code>。这种转换没有检查 <code>b</code> 是否实际上指向一个 <code>Derived</code> 类型的对象，这可能导致后续的运行时错误。</li>
<li>如果 <code>d</code> 被用于访问 <code>Derived</code> 的特定成员，结果可能是未定义行为。</li>
</ul>
<p><strong>示例 4：与 <code>const_cast&lt;&gt;</code> 和 <code>static_cast&lt;&gt;</code> 的对比</strong></p>
<ul>
<li>
<p><strong><code>static_cast&lt;&gt;</code></strong>：用于安全的、编译时检查的类型转换，例如父类与子类之间的转换。它会确保类型之间有一定的关系。</p>
</li>
<li>
<p><strong><code>const_cast&lt;&gt;</code></strong>：用于移除或添加 <code>const</code> 或 <code>volatile</code> 限定符，不能改变类型本身。</p>
</li>
<li>
<p><strong><code>reinterpret_cast&lt;&gt;</code></strong>：是最危险的转换操作符，允许你几乎将任何类型强制转换为任何其他类型，但它不会检查类型是否兼容，因此可能导致严重的未定义行为。</p>
</li>
<li>
<p><code>reinterpret_cast&lt;&gt;</code> 不能用于类型之间的跨越式转换，例如从浮点数转换为整数。要做到这种转换，需要使用 <code>static_cast&lt;&gt;</code> 或者先进行其他转换操作。</p>
</li>
<li>
<p>它的效果取决于底层平台和编译器的实现，因此在不同的系统中表现可能不一致，特别是在跨平台开发中。</p>
</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li><strong><code>reinterpret_cast&lt;&gt;</code></strong> 是 C++ 中用于强制类型转换的工具，允许你将一个类型重新解释为另一种不相关的类型，但它不会进行类型安全检查。</li>
<li>它最常用于指针之间的转换，或在需要与底层内存直接交互时使用（如设备驱动程序、操作系统开发等场景）。</li>
<li><strong>使用时需格外小心</strong>，因为错误的使用会导致未定义行为，破坏内存，或者导致程序崩溃。</li>
</ul>
<h3 id="案例-2">案例</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241009144538021.png" class="" title="image-20241009144538021">
<p><strong>右上方</strong></p>
<p>这个好理解，不赘述了</p>
<p><strong>右下方</strong></p>
<p>这里通过<code>const&lt;cast&gt;</code>去掉了c的const属性，通过*q修改了<code>const int c</code>的值，是UB行为。</p>
<p><strong>结果分析：</strong></p>
<ul>
<li>在内存中，<code>c</code> 的值被修改为 111（通过 <code>q</code> 指针），但直接访问 <code>c</code> 时，仍然显示原来的 128。这种行为是由于编译器对 <code>const</code> 对象的优化导致的未定义行为。尽管通过 <code>q</code> 可以修改 <code>c</code> 的值，但从 <code>c</code> 本身来访问时可能无法看到修改结果。</li>
<li><strong>为什么 <code>*q</code> 是 111？</strong>：<code>*q</code> 是 111，因为我们通过 <code>const_cast&lt;&gt;</code> 修改了 <code>c</code> 的值。然而，这种操作在标准中是未定义行为，不能保证所有平台都表现一致。</li>
</ul>
<h1>C3</h1>
<h2 id="dynamic-cast">dynamic_cast</h2>
<p><code>dynamic_cast</code> 是 C++ 中的一种类型转换操作符，专门用于在继承体系中进行 <strong>安全的向下转换（downcasting）</strong>。与 <code>static_cast</code> 相比，<code>dynamic_cast</code> 会在运行时检查类型的转换是否安全，确保类型之间的转换是合法的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic_cast</span>&lt;new_type&gt;(expression)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>new_type</code></strong>：目标类型，通常是指针类型或者引用类型，必须是从某个基类到派生类的转换。</li>
<li><strong><code>expression</code></strong>：要进行转换的表达式，通常是一个指向基类对象的指针或者引用。</li>
</ul>
<p><strong>1.2 使用场景</strong></p>
<p><code>dynamic_cast</code> 主要用于 <strong>多态类型</strong>，即在<strong>有虚函数</strong>的类体系中，用于从基类指针或引用<strong>向下转换</strong>到派生类指针或引用。它会在运行时检查类型是否正确。</p>
<p><strong>1.3 示例：向下转换</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello from Derived!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();  <span class="comment">// 基类指针指向派生类对象</span></span><br><span class="line">    Derived* derivedPtr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);  <span class="comment">// 向下转换</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (derivedPtr) &#123;</span><br><span class="line">        derivedPtr-&gt;<span class="built_in">sayHello</span>();  <span class="comment">// 安全调用派生类方法</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Conversion failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<ul>
<li><strong><code>Base* basePtr = new Derived();</code></strong>：一个基类指针指向派生类对象。这是一个 <strong>向上转换（upcasting）</strong>，总是安全的。</li>
<li><strong><code>Derived* derivedPtr = dynamic_cast&lt;Derived*&gt;(basePtr);</code></strong>：尝试将基类指针转换为派生类指针。这个操作只有在运行时确认 <code>basePtr</code> 实际上指向的是 <code>Derived</code> 类型的对象时才成功，否则会返回 <code>nullptr</code>。</li>
<li><strong>运行时类型检查</strong>：如果转换成功，可以安全地使用 <code>derivedPtr</code> 调用派生类特有的方法。如果转换失败，<code>derivedPtr</code> 将为 <code>nullptr</code>，以避免访问无效对象。</li>
</ul>
<p><strong>1.4 动态转换失败</strong></p>
<p>当使用 <code>dynamic_cast</code> 进行向下转换时，如果对象的实际类型与目标类型不匹配，<code>dynamic_cast</code> 将返回 <code>nullptr</code>（对于指针类型）或抛出 <code>std::bad_cast</code> 异常（对于引用类型）。</p>
<p><strong>1.5 需要虚函数</strong></p>
<p>为了能够使用 <code>dynamic_cast</code> 进行向下转换，<strong>基类中必须包含至少一个 虚函数（<code>virtual</code></strong>）。这是因为 <code>dynamic_cast</code> <strong>依赖于运行时类型信息（RTTI），而 RTTI 只有在类包含虚函数时才会生成。</strong></p>
<p><code>virtual</code> 是 C++ 中用于定义 <strong>虚函数</strong> 的关键字，它是实现 <strong>多态性</strong> 的核心机制之一。虚函数允许派生类<strong>重写</strong>基类的方法，并通过基类指针或引用调用派生类的方法。</p>
<h2 id="virtual">virtual</h2>
<p><strong>2.1 虚函数的作用</strong></p>
<p>当一个基类中的方法被声明为虚函数时，即使使用基类指针或引用调用该方法，C++ 仍然会根据对象的实际类型决定调用哪个版本的方法。这种行为称为 <strong>动态绑定</strong>，是多态性的一种体现。</p>
<p><strong>2.2 基本语法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;  <span class="comment">// 重写虚函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>2.3 使用虚函数实现多态性</strong></p>
<p>当基类的函数被声明为虚函数时，派生类可以重写该函数。即使通过基类指针调用该函数，实际运行时将会调用派生类中重写的函数，这就是 <strong>多态性</strong> 的核心。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">basePtr-&gt;<span class="built_in">show</span>();  <span class="comment">// 输出: &quot;Derived class&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<ul>
<li><code>show()</code> 被声明为虚函数，因此当 <code>basePtr</code> 指向派生类对象时，即使使用基类指针调用 <code>show()</code>，它仍然会调用 <code>Derived</code> 类中的 <code>show()</code> 函数。</li>
</ul>
<p><strong>2.4 纯虚函数（抽象类）</strong></p>
<p>你可以将虚函数声明为 <strong>纯虚函数</strong>，这会使得类变为<strong>抽象类</strong>，无法实例化。纯虚函数的作用是强制派生类提供自己的实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>2.5 虚析构函数</strong></p>
<p><strong>如果一个类中包含虚函数，那么它的析构函数也应该是虚的</strong>。这是为了确保通过基类指针删除对象时能够正确调用派生类的析构函数，防止内存泄漏。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() <span class="keyword">override</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"><span class="keyword">delete</span> basePtr;  <span class="comment">// 调用Derived和Base的析构函数</span></span><br></pre></td></tr></table></figure>
<p><strong>3. <code>dynamic_cast</code> 和 <code>virtual</code> 的关系</strong></p>
<ul>
<li><code>dynamic_cast</code> 依赖于虚函数表（vtable）和运行时类型信息（RTTI），而这些信息只有在类中存在虚函数时才会生成。</li>
<li><strong>没有虚函数的类不能使用 <code>dynamic_cast</code> 进行安全的向下转换。</strong></li>
<li><code>virtual</code> 关键字定义了虚函数，使得派生类能够重写基类的函数，<code>dynamic_cast</code> 则用于在运行时安全地判断对象的实际类型，并进行转换。</li>
</ul>
<p><strong>4. <code>dynamic_cast</code> 和 <code>static_cast</code> 的对比</strong></p>
<ul>
<li><strong><code>dynamic_cast&lt;&gt;</code></strong>：只能用于有虚函数的多态类型，用于在运行时安全地进行向下转换。如果转换失败，返回 <code>nullptr</code>（指针）或抛出异常（引用）。</li>
<li><strong><code>static_cast&lt;&gt;</code></strong>：用于编译时的类型转换，不进行运行时类型检查，适用于父类和子类之间的转换。如果类型不匹配，转换结果可能会出错或导致未定义行为。</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li><strong><code>virtual</code> 关键字</strong> 用于声明虚函数，是实现多态性和动态绑定的核心机制。</li>
<li><strong><code>dynamic_cast</code></strong> 是用于运行时安全类型转换的操作符，依赖于虚函数表（vtable）和运行时类型信息（RTTI），用于基类和派生类之间的向下转换。</li>
<li>虚函数使得派生类可以重写基类的方法，而通过基类指针或引用调用虚函数时，会根据对象的实际类型来决定调用哪个函数。这使得 <code>dynamic_cast</code> 在判断类型时能够安全地进行转换。</li>
</ul>
<h3 id="案例-3">案例</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241009151028768.png" class="" title="image-20241009151028768">
<ul>
<li>注意，这里PPT是有误解的</li>
</ul>
<p><strong>对于左侧，都是F都是没有virtual修饰的</strong></p>
<p><strong>左1代码father：</strong></p>
<p>注意：此时父类F是没有virtual修饰的，即不是虚函数，virtual是后面动画加上去的</p>
<ul>
<li>在这段代码中，<strong><code>foo()</code> 不是虚函数</strong>，所以它的调用是<strong>静态绑定</strong>的。</li>
<li>在 <code>F* obj = new S1();</code> 这行代码中，<code>obj</code> 是一个指向 <code>F</code> 类的指针，尽管它指向 <code>S1</code> 的对象，<strong>但由于 <code>foo()</code> 是 <code>F</code> 类中的非虚函数，编译器在编译时就决定了调用 <code>F::foo()</code>，输出的是 <code>&quot;father&quot;</code>。</strong></li>
</ul>
<p><strong>左2代码son1</strong></p>
<p><strong>左3代码unsafe</strong></p>
<p>会导致UB</p>
<p><strong>左4代码compile error</strong></p>
<p><code>F* obj = new S1;</code></p>
<ul>
<li>这里，<code>obj</code> 是一个指向 <code>S1</code> 类型对象的基类指针 <code>F*</code>。它实际上指向的是 <code>S1</code> 类的实例。</li>
</ul>
<p><code>dynamic_cast&lt;S1*&gt;(obj)</code></p>
<ul>
<li>使用 <code>dynamic_cast&lt;&gt;</code> 进行类型转换。与 <code>static_cast&lt;&gt;</code> 不同，<code>dynamic_cast&lt;&gt;</code> 会在运行时进行类型检查，以确保类型转换的安全性。</li>
<li>由于 <code>dynamic_cast&lt;&gt;</code> 是针对 <strong>多态类型</strong> 设计的（即有虚函数的类），所以它依赖于虚函数表（vtable）来判断对象的实际类型。</li>
<li>如果 <code>F</code> 中没有虚函数，使用 <code>dynamic_cast&lt;&gt;</code> 进行类型转换会<strong>导致编译错误</strong>。也就是说，<strong><code>dynamic_cast&lt;&gt;</code> 只能应用于具有虚函数的类</strong>。如果基类没有虚函数，编译器无法判断派生类的类型，转换会失败。</li>
</ul>
<p><strong>3. 编译错误的原因</strong></p>
<ul>
<li>如果 <code>F</code> 类中<strong>没有声明任何虚函数，那么 <code>dynamic_cast&lt;&gt;</code> 将无法使用</strong>，因为没有虚函数表可以供 <code>dynamic_cast&lt;&gt;</code> 在运行时检查类型。编译器会直接报错，提示无法进行转换。</li>
</ul>
<p><strong>总结：</strong></p>
<p>注意，对于左4的compile error，错误原因不是因为调用的foo函数没有加virtual，本质原因是F中没有声明虚函数。比如如下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">F</span></span><br><span class="line">&#123;  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;father&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">F</span>()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F* obj = <span class="keyword">new</span> S1;</span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;S1*&gt;(obj)-&gt;<span class="built_in">foo</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>此时输出Son1，就是正确的</li>
</ul>
<p><strong>对于右侧，与PPT一样，都是有virtual修饰的</strong></p>
<p><strong>右2代码</strong></p>
<p><code>F* obj = new F; dynamic_cast&lt;S1*&gt;(obj)-&gt;foo();</code></p>
<ul>
<li>在这个例子中，<code>obj</code> 实际上指向的是一个 <code>F</code> 对象，而我们尝试将其转换为 <code>S1*</code>。</li>
<li>由于 <code>obj</code> 并不是 <code>S1</code> 类型的对象，<code>dynamic_cast&lt;&gt;</code> 会失败，并返回 <code>nullptr</code>。因此，调用 <code>-&gt;foo()</code> 会抛出异常或导致程序崩溃。</li>
<li><strong>这表明 <code>dynamic_cast&lt;&gt;</code> 提供了运行时的安全检查，避免了像 <code>static_cast&lt;&gt;</code> 那样的未定义行为。</strong></li>
</ul>
<h2 id="auto">auto</h2>
<ul>
<li>自动推导类型，根据表达式进行推导，即auto x = 10，那么根据10，推导x的类型为int</li>
</ul>
<h2 id="decltype">decltype</h2>
<p><strong>基本语法：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(expression)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>expression</code></strong>：这是一个有效的C++表达式，**<code>decltype</code> 将根据这个表达式的类型（即expression的类型）**来推导出返回值的类型。</li>
</ul>
<p><strong>示例 1：基本使用</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x) y = <span class="number">20</span>;  <span class="comment">// y 的类型是 int，因为 x 的类型是 int</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中：</p>
<ul>
<li><code>x</code> 是 <code>int</code> 类型的变量，<code>decltype(x)</code> 也返回 <code>int</code>，所以 <code>y</code> 也被推导为 <code>int</code> 类型。</li>
</ul>
<p><strong>示例 2：推导引用类型</strong></p>
<p>如果表达式是一个引用，<code>decltype</code> 会推导出引用类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = x;</span><br><span class="line"><span class="keyword">decltype</span>(ref) y = x;  <span class="comment">// y 的类型是 int&amp;（引用类型），因为 ref 是 int&amp;</span></span><br><span class="line">y = <span class="number">20</span>;</span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; std::endl;  <span class="comment">// 输出 20，y 实际上是 x 的引用</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中：</p>
<ul>
<li><code>ref</code> 是 <code>int&amp;</code> 类型（对 <code>x</code> 的引用）。</li>
<li><code>decltype(ref)</code> 返回 <code>int&amp;</code>，因此 <code>y</code> 也是 <code>int&amp;</code> 类型，即 <code>y</code> 成为 <code>x</code> 的引用。</li>
</ul>
<p><strong>示例 3：推导复杂表达式的类型</strong></p>
<p><code>decltype</code> 的强大之处在于它可以<strong>推导出复杂表达式的类型</strong>，而不仅仅是变量的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x + y) z = <span class="number">30</span>;  <span class="comment">// z 的类型是 int，推导自 x + y 的类型</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>x + y</code> 是 <code>int</code> 类型的加法运算结果，因此 <code>decltype(x + y)</code> 的类型是 <code>int</code>，推导出的 <code>z</code> 也是 <code>int</code> 类型。</p>
<p><strong><code>decltype</code> 与 <code>auto</code> 的区别：</strong></p>
<ul>
<li><strong><code>auto</code></strong> 关键字用来根据初始化表达式来推导变量的类型。</li>
<li><strong><code>decltype</code></strong> 关键字用来推导一个表达式的类型，而不进行任何赋值或初始化操作。<code>decltype</code> 能保留变量的引用性、常量性等属性。</li>
</ul>
<h2 id="Range-for">Range-for</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : vec) &#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要避免元素拷贝，或是想修改容器中的元素，可以使用<strong>引用 int&amp;</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : vec) &#123;</span><br><span class="line">    i += <span class="number">1</span>;  <span class="comment">// 修改容器内的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Uniform-Initialization">Uniform Initialization</h2>
<p>统一初始化是 C++11 引入的新特性，允许我们使用大括号 <code>&#123;&#125;</code> 来初始化变量。它适用于<strong>内置类型</strong>和<strong>用户定义类型</strong>，提供了更加一致的初始化语法，解决了传统构造函数初始化和 <code>=</code> 初始化的混淆。</p>
<p><strong>传统初始化：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">7</span>, <span class="number">8</span>&#125;;    <span class="comment">// OK</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">7</span>, <span class="number">8</span>&#125;; <span class="comment">// 编译失败（旧版本中不支持）</span></span><br></pre></td></tr></table></figure>
<p><strong>统一初始化：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">7</span>, <span class="number">8</span>&#125;;    <span class="comment">// OK</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">7</span>, <span class="number">8</span>&#125;;   <span class="comment">// OK，在C++11中可以使用大括号进行初始化</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>统一初始化的好处</strong>：不仅可以用于内置类型，也可以用于类对象的初始化。它使初始化更加直观且不易出错。</li>
<li>这种方式避免了传统C++中使用构造函数、拷贝初始化等不同初始化方式带来的歧义。</li>
</ul>
<h3 id="案例-4">案例</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241009184655638.png" class="" title="image-20241009184655638">
<p>对于其中的Uniform Intialization部分的vector初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">7</span>, <span class="number">8</span>&#125;;                <span class="comment">// OK</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">7</span>, <span class="number">8</span>&#125;;          <span class="comment">// should work (obviously, but it did not)</span></span><br></pre></td></tr></table></figure>
<p>这段代码的注释中提到：这看起来应该是可行的（“should work”），但却没有工作。问题是，为什么 <code>vector&lt;int&gt; v = &#123;7, 8&#125;;</code> 不像数组那样成功初始化呢？</p>
<p>在 <strong>C++11 之前</strong>，使用 <code>&#123;&#125;</code> 大括号直接初始化 <code>std::vector</code> 会引发问题，甚至会导致编译错误。这是因为：</p>
<ul>
<li>在早期的 C++ 标准中，<strong>容器类如 <code>std::vector</code> 的初始化主要依赖于构造函数</strong>，而大括号 <code>&#123;&#125;</code> 初始化并未用于用户定义类型。</li>
<li><code>std::vector</code> 的初始化方式依赖于构造函数，<strong>例如 <code>vector&lt;int&gt; v(2, 10);</code> 会初始化一个大小为2，所有元素值为10的 <code>vector</code></strong>。使用 <code>&#123;&#125;</code> 初始化的语法是新标准引入的特性，而非传统的构造函数调用。</li>
</ul>
<p>在 <strong>C++11 中，引入了统一初始化规则</strong>，使得大括号 <code>&#123;&#125;</code> 可以用于初始化标准库中的容器，如 <code>std::vector</code>。实际上，<code>vector&lt;int&gt; v = &#123;7, 8&#125;;</code> 是合法的，它使用了 <code>std::initializer_list</code> 特性来初始化 <code>std::vector</code>。</p>
<p><code>std::initializer_list</code> 是 C++11 引入的一个模板类，允许你通过大括号 <code>&#123;&#125;</code> 初始化容器，如 <code>std::vector</code> 和 <code>std::array</code>。这使得初始化容器的方式与初始化内置数组的方式更加一致。</p>
<p>注释 “should work (obviously, but it did not)” 表达了旧版本编译器可能不支持此特性的情况。在支持 C++11 的现代编译器中，这种初始化是完全合法的。</p>
<p>其中<code>vector&lt;int&gt; a&#123;1,2&#125;</code>和<code>vector&lt;int&gt; a = &#123;1,2&#125;</code>是等价的，都可以，数组也是</p>
<h2 id="Union">Union</h2>
<p><code>union</code> 是C++中一种特殊的结构，它<strong>允许多个成员变量共享同一块内存</strong>。<code>union</code> 中的所有成员都占用同一个内存空间，但<strong>一次只能保存一个成员的值</strong>。也就是说，<strong>在一个 <code>union</code> 中，当一个成员被赋值时，其他成员的值都会被覆盖，因为它们共享相同的内存空间。</strong></p>
<p><code>union</code> 占用的内存大小等于其所有成员中<strong>占用内存最大的成员</strong>的大小。因此，在任何时刻，<code>union</code> 只能存储其中的一个成员。</p>
<h3 id="案例-5">案例</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241009190014846.png" class="" title="image-20241009190014846">
<p>上半部分代码：尝试将浮点数 <code>f</code> 的位表示转换为二进制字符串。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">float2B</span><span class="params">(<span class="type">float</span> f)</span> </span>&#123;</span><br><span class="line">    std::string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        s += (f &amp; (<span class="number">1</span> &lt;&lt; i)) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码标红色问号的地方是有问题的， <code>f &amp; (1 &lt;&lt; i)</code> 处会报错：<code>error: invalid operands of types 'float' and 'int' to binary 'operator&amp;'</code></p>
<ul>
<li><strong><code>float</code> 类型的位运算问题</strong>：<code>float</code> 是一种浮点数，而位运算符（如 <code>&amp;</code> 和 <code>&lt;&lt;</code>）通常只适用于整型数据（如 <code>int</code>、<code>long</code> 等）。<strong>直接对浮点数 <code>f</code> 执行位运算是非法的</strong>，因为 <code>float</code> 类型不是按位存储整数值，而是遵循 IEEE 754 标准存储二进制浮点数（即包括符号位、指数位和尾数位）。</li>
<li><strong>如何解决这个问题？</strong> 为了对浮点数进行位操作，我们需要找到一种方法，将浮点数的<strong>位表示</strong>解释为整型，然后才能进行按位操作。</li>
</ul>
<p><strong>下半部分代码（使用 <code>union</code>）：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">float2B</span><span class="params">(<span class="type">float</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">float</span> f;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">    &#125; u;</span><br><span class="line">    </span><br><span class="line">    u.f = f;</span><br><span class="line">    std::string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        s += (u.i &amp; (<span class="number">1</span> &lt;&lt; i)) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>union</code> 来解决浮点数和整型之间的类型转换问题。</p>
<p><strong><code>union</code> 的作用</strong>：<code>union</code> 定义了两个成员：<code>float f</code> 和 <code>int i</code>，它们共享同一块内存。这意味着当你对 <code>u.f</code> 赋值时，<code>u.i</code> 也能反映这块内存的二进制表示，但以 <code>int</code> 类型来解释。也就是说，当我们给 <code>u.f</code> 赋值一个浮点数 <code>f</code> 时，<strong><code>u.i</code> 会包含 <code>f</code> 的位级表示（即浮点数在内存中的 32 位表示，但解释为整数）。</strong></p>
<p><code>u.f=f</code>：由于 <code>f</code> 和 <code>i</code> 共用内存，现在 <code>u.i</code> 实际上包含了 <code>f</code> 的 32 位二进制表示</p>
<p>现在即可用u.i来进行按位运算了</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241009191109053.png" class="" title="image-20241009191109053">
<p><strong>内存共享</strong>：在 <code>union</code> 中，多个成员共用同一段内存。在这个例子中，无论你通过结构体的方式（<code>_a11</code>, <code>_a12</code>, 等）还是通过数组的方式（<code>_element[0][0]</code>, <code>_element[1][1]</code>，等）来访问数据，访问的都是同一段内存。</p>
<p>因此，当你对 <code>m._a11</code> 赋值时，实际上也影响了 <code>m._element[0][0]</code>，因为它们指向的是同一块内存。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241009191315771.png" class="" title="image-20241009191315771">
<ul>
<li>FIGURE_TYPE，Line，Rectangle，Ellipse共享同一个union</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241009195029523.png" class="" title="image-20241009195029523">
<ul>
<li>最上方的绿色图的每一行即为union相同的空间内存放的变量</li>
<li>比如<strong>line.t</strong>, <strong>rect.t</strong>, <strong>ellipse.t</strong>, 和 <strong>t</strong> 占据的是同一块内存空间。这表示 <strong><code>line.t</code>、<code>rect.t</code>、<code>ellipse.t</code> 和 <code>union FIGURE</code> 中的 <code>t</code> 共享同一个 4 字节的存储位置</strong>。无论是 <code>line</code> 的类型字段、<code>rect</code> 的类型字段，还是 <code>ellipse</code> 的类型字段，它们都映射到 <code>union</code> 中的 <code>t</code>。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241009195403085.png" class="" title="image-20241009195403085">
<ul>
<li>
<p>这张PPT的重点是通过 <strong><code>union</code></strong> 实现的简单 <strong>“多态性”（polymorphism）</strong>，</p>
</li>
<li>
<p><strong>多态性</strong>：尽管这不是传统的面向对象编程中的多态（通过虚函数实现的动态绑定），但这也是一种简单的“多态性”，即程序可以根据图形的类型 <code>t</code> 来决定调用哪个绘制函数。这种方式依赖于 <code>switch</code> 语句和枚举类型。<strong>图形的类型判断</strong>：程序通过检查 <code>figure.t</code> 来知道 <code>union</code> 中当前存储的是什么类型的图形（直线、矩形或圆形）。</p>
</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241009195944336.png" class="" title="image-20241009195944336">
<ul>
<li>类似的延伸，把color和width也作为共享的部分。即在设置FIGURE figure; figure.line = {xxx}后，figure本身的t，color和width也被设定</li>
</ul>
<h1>C4</h1>
<h2 id="struct">struct</h2>
<h3 id="alignment">alignment</h3>
<p><strong>对齐（alignment）</strong> 是指数据在内存中的存储地址必须是某个类型的对齐要求的倍数。不同的数据类型有不同的对齐要求。例如：</p>
<ul>
<li><code>char</code> 通常对齐到 1 字节（因为 <code>char</code> 通常只占 1 字节）。</li>
<li><code>short</code> 通常对齐到 2 字节。</li>
<li><code>int</code> 和 <code>float</code> 通常对齐到 4 字节。</li>
</ul>
<p>现代处理器通常要求数据以某种对齐方式存储，以提高读取内存的效率。如果数据没有正确对齐，处理器可能需要执行多次内存访问，导致性能下降。因此，<strong>编译器会在必要时在数据之间插入填充字节（padding）以确保数据对齐到正确的内存地址。</strong></p>
<p><strong>结构体的对齐规则</strong></p>
<p><strong>规则1：每个成员的地址必须是该成员类型的对齐要求的倍数</strong></p>
<ul>
<li>例如，如果一个 <code>int</code> 类型的成员需要 4 字节对齐，它的起始地址必须是 4 的倍数。如果它前面是一个占 1 字节的 <code>char</code> 类型成员，编译器会插入 3 个填充字节来确保 <code>int</code> 成员的地址是 4 的倍数。</li>
</ul>
<p><strong>规则2：结构体的整体大小必须是其最大对齐要求的倍数</strong></p>
<ul>
<li>例如，如果结构体中最大的对齐需求是 4 字节，那么整个结构体的大小也必须是 4 的倍数。如果结构体的总大小不能被 4 整除，编译器会在结构体的末尾插入填充字节，使其大小符合要求。</li>
</ul>
<p><strong>规则3：成员顺序影响结构体的对齐和大小</strong></p>
<ul>
<li>如果结构体中的小类型（如 <code>char</code>）放在大类型（如 <code>int</code>）前面，可能会导致大量的填充字节，从而增加结构体的整体大小。</li>
</ul>
<p><strong>示例：有填充的结构体</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">char</span> c;    <span class="comment">// 1字节，1字节对齐</span></span><br><span class="line">    <span class="type">short</span> s;   <span class="comment">// 2字节，2字节对齐</span></span><br><span class="line">    <span class="type">int</span> i;     <span class="comment">// 4字节，4字节对齐</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>char</code> 占 1 字节，需要 1 字节对齐。</li>
<li><code>short</code> 占 2 字节，需要 2 字节对齐，但在 <code>char</code> 后需要 1 字节的填充。</li>
<li><code>int</code> 需要 4 字节对齐，紧跟在 <code>short</code> 之后。</li>
</ul>
<p>内存布局如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| c (1字节) | padding (1字节) | s (2字节) | i (4字节) |</span><br></pre></td></tr></table></figure>
<h3 id="Padding">Padding</h3>
<ul>
<li>为了确保结构体成员按对齐要求存储在内存中，编译器插入的填充字节</li>
</ul>
<h3 id="Little-Endian">Little Endian</h3>
<p>Little Endian （小端序）是一种内存存储方式，在这种方式下，数据的<strong>低字节存储在低地址，而高字节存储在高地址。</strong></p>
<h3 id="案例-6">案例</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241009200900213.png" class="" title="image-20241009200900213">
<p>其中红框标记的地方即为padding</p>
<p>虽然结构体A,B存储的数据一样，但是因为成员顺序不同，B中添加了更多的padding，同时占的内存空间也变大了</p>
<p>其中数据的存储使用little endian小端序，数据的低字节存储在低地址，而高字节存储在高地址。（即反着排）</p>
<p>比如<code>B</code> 的 <code>int i = 259</code>，其二进制表示为：<code>00000000 00000000 00000001 00000011</code></p>
<p>在小端序系统中，低位字节（00000011）存储在内存的低地址，而高位字节（00000001）存储在高地址。因此在PPT中结构体B的第二行，可以看到以小端序方式存储的数据。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241009205748950.png" class="" title="image-20241009205748950">
<p><strong>用于打印q的前n个字节</strong></p>
<p>比如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">259</span>;</span><br><span class="line"><span class="built_in">showBytes</span>(&amp;x, <span class="built_in">sizeof</span>(x));</span><br></pre></td></tr></table></figure>
<p><strong>绿色记框中的扩展功能</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; hex &lt;&lt; (<span class="type">int</span>)*(p + i) &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line"><span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">4</span> == <span class="number">0</span>) cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p><strong>功能：</strong></p>
<ul>
<li>这个扩展功能将内存中的字节值输出为 <strong>十六进制</strong> 格式，并且每四个字节换行输出。</li>
</ul>
<p><strong>工作原理：</strong></p>
<ol>
<li><strong><code>cout &lt;&lt; setw(2) &lt;&lt; hex &lt;&lt; (int)*(p + i)</code></strong>：
<ul>
<li><code>setw(2)</code>：设置输出的宽度为 2 个字符（用于保持输出整齐）。</li>
<li><code>hex</code>：将数值按十六进制格式输出。</li>
<li><code>(int)*(p + i)</code>：将当前字节的值转换为整型，然后以十六进制格式输出。</li>
</ul>
</li>
<li><strong><code>if ((i + 1) % 4 == 0)</code></strong>：每 4 个字节换行输出。这个条件确保我们按 4 字节分组显示数据，以更好地查看内存布局。</li>
</ol>
<h2 id="tuple-Structed-Binding">tuple &amp; Structed Binding</h2>
<h3 id="案例-7">案例</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241009210311939.png" class="" title="image-20241009210311939">
<p>该PPT演示了三种方式来让<strong>函数实现多输出参数</strong>（即多个“返回值”）</p>
<p>M1：引用传参，直接修改</p>
<p>M2：结构体返回</p>
<p>M3：使用<strong>tuple和结构化绑定</strong></p>
<p><strong>函数定义：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tuple&lt;<span class="type">int</span>, <span class="type">float</span>&gt; <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="number">1</span>, <span class="number">3.0f</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>调用方式：</strong></p>
<ul>
<li>
<p><strong>方法 1</strong>：使用 <code>std::get&lt;&gt;</code> 访问元组中的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> r = <span class="built_in">foo</span>();</span><br><span class="line">cout &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(r) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(r);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>方法 2</strong>：使用**结构化绑定（Structured Binding）**直接解构元组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> r = <span class="built_in">foo</span>();</span><br><span class="line"><span class="keyword">auto</span> [i,f] = r;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; f;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>方法 3</strong>：结构化绑定和引用结合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto r = foo();</span><br><span class="line">auto&amp; [i,f] = r;</span><br><span class="line">i = 1;</span><br><span class="line">f = 2.3;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>重点即为这里<strong>结构化绑定的表达方式</strong>，即元组如何<strong>构建与访问</strong></p>
<p><strong>解释：</strong></p>
<ul>
<li><strong><code>std::tuple</code></strong>：<code>tuple</code> 是 C++ 标准库提供的工具，用于打包多个不同类型的值并作为一个整体返回。这里的 <code>tuple&lt;int, float&gt;</code> 表示一个包含 <code>int</code> 和 <code>float</code> 的元组。</li>
<li><strong><code>get&lt;&gt;</code> 函数</strong>：<code>get&lt;0&gt;(r)</code> 用于访问元组的第一个值，<code>get&lt;1&gt;(r)</code> 用于访问元组的第二个值。元组是基于索引的，因此通过 <code>get&lt;索引&gt;(元组)</code> 来获取对应的值。</li>
<li><strong>结构化绑定（Structured Binding）</strong>：C++17 引入了结构化绑定，使得我们可以轻松地将<strong>元组中的值解包为多个独立的变量</strong>。<code>auto [i, f] = foo();</code> 直接将元组中的第一个值赋给 <code>i</code>，第二个值赋给 <code>f</code>，然后可以像普通变量一样使用 <code>i</code> 和 <code>f</code>。</li>
</ul>
<h2 id="optional">optional</h2>
<p>在 C++ 中，<code>std::optional</code> 是 C++17 引入的标准库类型，<strong>用于表示一个可能存在或者不存在的值</strong>。它是一个非常有用的工具，<strong>尤其是在函数返回值的场景下</strong>，可以避免使用指针或其他形式来表示“无效值”或“空值”。</p>
<p><strong>1. <code>std::optional</code> 的定义和作用</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><code>std::optional&lt;T&gt;</code> 是一个模板类，它可以存储一个类型为 <code>T</code> 的值，或者表示没有值。<strong>这个类的主要作用是让你能够在一个变量中安全地表达“有值”或“无值”的状态</strong>，而无需使用指针或特殊的返回值。</p>
<p><strong>主要功能：</strong></p>
<ul>
<li><strong>有值状态</strong>：<code>optional&lt;T&gt;</code> 包含一个类型为 <code>T</code> 的值。</li>
<li><strong>无值状态</strong>：<code>optional</code> 是“空”的，表示不包含任何值。</li>
</ul>
<p><strong>2. 使用场景</strong></p>
<p><code>std::optional</code> 常用于以下场景：</p>
<ul>
<li><strong>函数的返回值</strong>：当函数可能无法返回有效的结果时，<code>optional</code> 可以用来表示“没有值”而不是返回一个无效的值（如返回 <code>nullptr</code> 或 <code>-1</code>）。</li>
<li><strong>替代指针</strong>：它可以用来替代指针，表示一个对象要么有效，要么无效，但不会像裸指针那样产生悬空指针的风险。</li>
</ul>
<p><strong>3. <code>std::optional</code> 的基本使用</strong></p>
<p><strong>例子：可能返回值的函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">findName</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="literal">nullopt</span>;  <span class="comment">// 返回 &quot;无值&quot; 的状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> name = <span class="built_in">findName</span>(<span class="number">1</span>);  <span class="comment">// id 为 1 时有值</span></span><br><span class="line">    <span class="keyword">if</span> (name) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; *name &lt;&lt; std::endl;  <span class="comment">// 通过解引用访问值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No name found&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> noName = <span class="built_in">findName</span>(<span class="number">3</span>);  <span class="comment">// id 为 3 时无值</span></span><br><span class="line">    <span class="keyword">if</span> (noName) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; *noName &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No name found&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<ul>
<li><strong><code>std::nullopt</code></strong>：这是一个常量，用来表示 <code>optional</code> 处于“无值”的状态。在 <code>findName</code> 函数中，如果传入的 <code>id</code> 无法匹配到有效的名字，<strong>返回 <code>std::nullopt</code></strong>，表示没有找到名字。</li>
<li><strong><code>name</code> 的检查</strong>：使用 <code>if (name)</code> 来检查 <code>optional</code> 是否有值。<code>optional</code> 类支持类似于布尔值的转换操作，如果它包含值，则为 <code>true</code>，否则为 <code>false</code>。</li>
<li><strong>解引用访问值</strong>：如果 <code>optional</code> 包含值，可以使用 <code>*name</code> 解引用访问它内部的值。</li>
</ul>
<p><strong>4. <code>std::optional</code> 的成员函数</strong></p>
<p><code>std::optional</code> 提供了多个有用的成员函数来检查和操作内部的值：</p>
<p><strong>1. <code>has_value()</code> 或 <code>operator bool()</code></strong></p>
<ul>
<li>用于检查 <code>optional</code> 是否包含值。</li>
<li><code>bool hasValue = opt.has_value();</code> 或者直接用 <code>if (opt)</code> 来检查是否有值。</li>
</ul>
<p><strong>2. <code>value()</code></strong></p>
<ul>
<li>返回存储的值。如果 <code>optional</code> 没有值，调用这个方法会抛出异常 <code>std::bad_optional_access</code>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> name = <span class="built_in">findName</span>(<span class="number">1</span>);</span><br><span class="line">std::cout &lt;&lt; name.<span class="built_in">value</span>() &lt;&lt; std::endl;  <span class="comment">// 直接获取值</span></span><br></pre></td></tr></table></figure>
<ul>
<li>为了避免异常，可以使用 <code>value_or()</code> 方法。</li>
</ul>
<p><strong>3. <code>value_or()</code></strong></p>
<ul>
<li>如果 <code>optional</code> 有值，返回该值；如果没有值，返回一个默认值。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> name = <span class="built_in">findName</span>(<span class="number">3</span>);</span><br><span class="line">std::cout &lt;&lt; name.<span class="built_in">value_or</span>(<span class="string">&quot;Unknown&quot;</span>) &lt;&lt; std::endl;  <span class="comment">// 没有值时返回 &quot;Unknown&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>4. <code>emplace()</code></strong></p>
<ul>
<li><code>emplace()</code> 方法可以在 <code>optional</code> 中直接构造一个新的值，避免不必要的拷贝或赋值。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::optional&lt;<span class="type">int</span>&gt; opt;</span><br><span class="line">opt.<span class="built_in">emplace</span>(<span class="number">42</span>);  <span class="comment">// 直接在 optional 中构造 42</span></span><br></pre></td></tr></table></figure>
<p><strong>5. <code>reset()</code></strong></p>
<ul>
<li><code>reset()</code> 会将 <code>optional</code> 重置为无值状态。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opt.<span class="built_in">reset</span>();  <span class="comment">// opt 现在是无值的</span></span><br></pre></td></tr></table></figure>
<h3 id="案例-8">案例</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241009211053083.png" class="" title="image-20241009211053083">
<p><strong>右上角：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">getNameByID</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::vector&lt;std::pair&lt;<span class="type">int</span>, std::string&gt;&gt;&amp; v, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> id)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : v) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.first == id) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong><code>std::nullopt</code></strong>：这是一个特殊的值，表示 <code>optional</code> 处于“无值”的状态。它在这里用于表明找不到对应的学生时返回“无值”。</p>
</li>
<li>
<p>相比传统的指针或特殊的返回值，<code>std::optional</code> 提供了一种更加安全、直观的方式来表示“<strong>值的存在或不存在</strong>”。调用者可以通过 <code>optional</code> 检查返回值是否存在。</p>
</li>
</ul>
<p><strong>左下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::pair&lt;<span class="type">int</span>, std::string&gt;&gt; students&#123;&#123;<span class="number">1</span>, <span class="string">&quot;AAA&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;BBB&quot;</span>&#125;, &#123;<span class="number">3</span>, <span class="string">&quot;CC&quot;</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> student_id;</span><br><span class="line">std::cin &gt;&gt; student_id;</span><br><span class="line"><span class="keyword">auto</span> id = <span class="built_in">getNameByID</span>(students, student_id);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>id</code> 的类型是 <code>std::optional&lt;std::string&gt;</code>，表示查找结果可以有值，也可以没有值。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id.<span class="built_in">has_value</span>() ? cout &lt;&lt; id.<span class="built_in">value</span>() : cout &lt;&lt; <span class="string">&quot;Not Found&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; id.<span class="built_in">value_or</span>(<span class="string">&quot;Not Found&quot;</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<ul>
<li><strong><code>id.has_value()</code></strong>：用于检查 <code>optional</code> 是否包含有效值。如果 <code>optional</code> 有值，则返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li><strong><code>id.value()</code></strong>：如果 <code>optional</code> 有值，<code>value()</code> 返回存储的值。在这里，如果找到了学生名字，它会返回这个名字。</li>
<li><strong><code>value_or(&quot;Not Found&quot;)</code></strong>：这是一个更简洁的方式，如果 <code>optional</code> 有值，则返回该值；如果没有值，则返回 <code>value_or()</code> 中的默认值 <code>&quot;Not Found&quot;</code>。这减少了手动检查和输出“无值”的情况。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> op1 = std::make_optional&lt;std::vector&lt;<span class="type">char</span>&gt;&gt;(&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : *op1) </span><br><span class="line">    cout &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// optional set construction</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>std::make_optional</code></strong>：它是一个简化构造 <code>optional</code> 对象的函数，可以方便地构造 <code>optional</code> 包含的值。</li>
<li><strong>解引用 <code>optional</code></strong>：<code>optional</code> 可以像指针一样被解引用，<code>*op1</code> 会返回存储在 <code>optional</code> 中的值。</li>
</ul>
<h2 id="varient">varient</h2>
<p><strong>1. 定义</strong></p>
<p><code>std::variant</code> 是一个可以<strong>存储多个不同类型的对象的容器，但每次只能存储其中的一种类型</strong>。与 C++ 的 <code>union</code> 不同，<code>std::variant</code> 是类型安全的，这意味着你可以知道当前存储的值的类型，并安全地获取它。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::variant&lt;<span class="type">int</span>, <span class="type">float</span>, std::string&gt; var;</span><br></pre></td></tr></table></figure>
<p>上面的代码定义了一个 <code>std::variant</code>，它可以存储 <code>int</code>、<code>float</code> 或 <code>std::string</code> 类型的值。每次只能存储其中一个类型。</p>
<p><strong>2. 如何使用 <code>std::variant**</code></strong></p>
<p><strong>2.1 创建 <code>std::variant</code> 对象</strong></p>
<p>你可以通过直接赋值或者构造函数来初始化 <code>std::variant</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 variant，存储一个 int 类型的值</span></span><br><span class="line">    std::variant&lt;<span class="type">int</span>, <span class="type">float</span>, std::string&gt; var = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 现在 var 存储了 int 类型的值 10</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(var) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改 var 的值，存储一个 float</span></span><br><span class="line">    var = <span class="number">3.14f</span>;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">float</span>&gt;(var) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改 var 的值，存储一个 std::string</span></span><br><span class="line">    var = std::<span class="built_in">string</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;std::string&gt;(var) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<ul>
<li><strong><code>std::get&lt;T&gt;(variant)</code></strong>：使用 <code>std::get&lt;T&gt;</code> 来获取存储在 <code>variant</code> 中的值，<code>T</code> 是当前存储的类型。如果你尝试获取与当前存储类型不符的值，会抛出 <code>std::bad_variant_access</code> 异常。</li>
<li><strong>类型安全</strong>：与 C++ 中的 <code>union</code> 不同，<code>std::variant</code> 可以安全地检测并返回当前存储的类型。</li>
</ul>
<p><strong>2.2 索引访问</strong></p>
<p>除了使用 <code>std::get&lt;T&gt;</code> 访问 <code>variant</code> 中存储的值，你还可以使用 <code>std::get&lt;index&gt;</code> 通过索引来访问它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::variant&lt;<span class="type">int</span>, <span class="type">float</span>, std::string&gt; var = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过索引 0 获取 int 类型的值</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(var) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过索引 1 存储 float 类型的值</span></span><br><span class="line">    var = <span class="number">3.14f</span>;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(var) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过索引 2 存储 string 类型的值</span></span><br><span class="line">    var = std::<span class="built_in">string</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(var) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<ul>
<li><code>std::get&lt;index&gt;(variant)</code>：索引从 0 开始，<code>std::get&lt;0&gt;(var)</code> 表示 <code>variant</code> 的第一个类型（在这个例子中是 <code>int</code>）。</li>
</ul>
<p><strong>3. 检测当前存储的类型</strong></p>
<p>在使用 <code>std::variant</code> 时，你可以使用 <code>std::holds_alternative&lt;T&gt;</code> 来检查 <code>variant</code> 当前是否存储了某种类型的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::variant&lt;<span class="type">int</span>, <span class="type">float</span>, std::string&gt; var = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (std::<span class="built_in">holds_alternative</span>&lt;<span class="type">int</span>&gt;(var)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;variant contains an int.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::holds_alternative&lt;T&gt;(variant)</code> 检查 <code>variant</code> 是否包含类型 <code>T</code>，如果包含，返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p><strong>4. 访问错误处理</strong></p>
<p>如果你试图获取的类型与 <code>variant</code> 当前存储的类型不符，<code>std::get</code> 会抛出 <code>std::bad_variant_access</code> 异常：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    std::variant&lt;<span class="type">int</span>, std::string&gt; var = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;std::string&gt;(var);  <span class="comment">// 这里会抛出异常，因为当前是 int 类型</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_variant_access&amp; e) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5. <code>std::visit</code>：处理 <code>variant</code> 的类型</strong></p>
<p>在很多情况下，你可能需要根据 <code>variant</code> 的类型来执行不同的操作。<code>std::visit</code> 可以帮你做这件事：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::variant&lt;<span class="type">int</span>, <span class="type">float</span>, std::string&gt; var = std::<span class="built_in">string</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> visitor = [](<span class="type">const</span> <span class="keyword">auto</span>&amp; value) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">visit</span>(visitor, var);  <span class="comment">// 根据 var 的当前类型调用合适的 lambda</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<ul>
<li><strong><code>std::visit</code></strong>：它用于访问 <code>variant</code> 中存储的值，并根据存储的类型执行相应的操作。它的参数是一个函数对象或 lambda 表达式，以及一个或多个 <code>variant</code>。</li>
<li><strong>通用 lambda 表达式</strong>：使用 <code>auto</code> 作为参数类型，意味着 lambda 表达式可以接受任意类型的参数。在上面的例子中，无论 <code>variant</code> 是 <code>int</code>、<code>float</code> 还是 <code>std::string</code>，这个 lambda 都可以处理。</li>
</ul>
<p><strong>6. <code>std::monostate</code>：表示空状态</strong></p>
<p>有时，可能需要 <code>variant</code> 有一个“无效”状态。<code>std::monostate</code> 提供了这样一个工具，它通常用作 <code>variant</code> 的第一个类型，表示一个“无值”状态：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::variant&lt;std::monostate, <span class="type">int</span>, std::string&gt; var;</span><br><span class="line"><span class="keyword">if</span> (std::<span class="built_in">holds_alternative</span>&lt;std::monostate&gt;(var)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;variant is empty.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<ul>
<li><strong><code>std::monostate</code></strong>：这是一个没有任何成员的类型，通常用作 <code>variant</code> 的占位类型，表示一种默认的空状态。</li>
<li>当 <code>variant</code> 被默认构造时，如果它包含 <code>std::monostate</code>，就相当于处于一种空状态。</li>
</ul>
<h3 id="案例-9">案例</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241010210228947.png" class="" title="image-20241010210228947">
<p><strong>上方：</strong></p>
<p><strong>1. <code>std::variant</code> 基本介绍</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::variant&lt;<span class="type">int</span>, <span class="type">float</span>, std::string&gt; v;</span><br></pre></td></tr></table></figure>
<p>这是一个声明了 <code>std::variant</code> 类型的变量 <code>v</code>，它可以存储三种类型中的一种：<code>int</code>、<code>float</code>、或者 <code>std::string</code>。</p>
<p><strong>2. 为 <code>variant</code> 赋值和使用 <code>std::get</code> 进行访问</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">cout &lt;&lt; v.<span class="built_in">index</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;std::string&gt;(v) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>v.index()</code></strong>：<code>index()</code> 方法返回当前 <code>variant</code> 存储的类型对应的索引（按类型在模板列表中的顺序）。<code>std::string</code> 是第三个类型，因此 <code>index()</code> 会返回 <code>2</code>。</li>
<li><strong><code>std::get&lt;std::string&gt;(v)</code></strong>：使用 <code>std::get&lt;T&gt;</code> 提取 <code>variant</code> 中存储的值。此处 <code>T</code> 是 <code>std::string</code>，因为当前 <code>v</code> 存储的是一个字符串。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; v.<span class="built_in">index</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(v) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>v = 100;</code></strong>：现在我们将一个 <code>int</code> 类型的值 <code>100</code> 赋给 <code>v</code>，此时 <code>v</code> 存储的是 <code>int</code> 类型。</li>
<li><strong><code>std::get&lt;0&gt;(v)</code></strong>：这里使用索引 <code>0</code> 来获取 <code>int</code> 类型的值，因为 <code>int</code> 是 <code>variant</code> 中的第一个类型。</li>
</ul>
<p><strong>3. <code>std::variant</code> 中异常和错误处理</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// v = 2.3f;  // 如果取消注释，发生了什么？</span></span><br><span class="line">cout &lt;&lt; v.<span class="built_in">index</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">float</span>&gt;(v) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里 <code>v</code> 被赋值为 <code>100</code>，即 <code>int</code> 类型。<code>std::get&lt;float&gt;(v)</code> 试图获取 <code>float</code> 类型的值，但当前 <code>v</code> 中存储的是 <code>int</code> 类型，因此会抛出 <code>std::bad_variant_access</code> 异常。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">double</span>&gt;(v);  <span class="comment">// 会发生什么？</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>variant</code> 中并没有声明可以存储 <code>double</code> 类型，<code>std::get&lt;double&gt;</code> 会导致**编译错误。**这是因为 <code>double</code> 不是 <code>variant</code> 中的合法类型。</li>
</ul>
<p><strong>错误：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Compile Error</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><strong>检查当前存储的类型：<code>std::get_if</code> 和 <code>std::holds_alternative</code></strong></li>
</ol>
<p>PPT 还展示了两种方法来安全地检查 <code>variant</code> 是否存储了某种类型，并提取存储的值。</p>
<p><strong>方法1：使用 <code>std::get_if</code></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span>* pf = std::<span class="built_in">get_if</span>&lt;<span class="type">float</span>&gt;(&amp;v);</span><br><span class="line"><span class="keyword">if</span> (pf != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">index</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *pf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Invalid&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>std::get_if&lt;T&gt;(variant)</code></strong>：这是一个更安全的获取方式，它返回指向 <code>variant</code> 中存储的 <code>T</code> 类型的指针。如果 <code>variant</code> 当前存储的是 <code>T</code> 类型的值，返回该值的指针；否则，返回 <code>nullptr</code>。</li>
<li>如果 <code>pf != nullptr</code>，则表示当前 <code>v</code> 中存储的是 <code>float</code> 类型，输出 <code>float</code> 值；否则输出 <code>Invalid</code>。</li>
</ul>
<p><strong>方法2：使用 <code>std::holds_alternative</code></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (std::<span class="built_in">holds_alternative</span>&lt;<span class="type">float</span>&gt;(v)) &#123;</span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">index</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">float</span>&gt;(v) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>std::holds_alternative&lt;T&gt;(variant)</code></strong>：用于检查 <code>variant</code> 当前是否存储了类型 <code>T</code> 的值。如果存储的是 <code>T</code>，返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li>如果 <code>variant</code> 中确实存储了 <code>float</code>，则可以安全地使用 <code>std::get&lt;float&gt;(v)</code> 提取值。</li>
</ul>
<h2 id="any">any</h2>
<p><code>std::any</code> 是一个类型安全的通用容器，它可以<strong>存储任意类型的对象</strong>。和 <code>void*</code> 不同，<code>std::any</code> 提供了类型信息检查的功能，因此在取出存储的对象时，可以确保类型安全。</p>
<ol>
<li><strong>存储任意类型的值</strong>：<code>std::any</code> 能够存储任何类型的值，它提供了一种类型无关的方式来处理数据。</li>
<li><strong>类型安全的访问</strong>：<code>std::any</code> 能够通过 <code>std::any_cast</code> 安全地获取存储值的类型。</li>
<li><strong>动态类型识别</strong>：你可以在运行时检查 <code>std::any</code> 存储的值的类型，这为程序提供了高度的灵活性。</li>
</ol>
<p><strong>1. 创建与存储值</strong></p>
<p>你可以通过直接赋值或构造函数将任何类型的值存储到 <code>std::any</code> 中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::any a = <span class="number">10</span>;  <span class="comment">// 存储一个整数</span></span><br><span class="line">    std::any b = std::<span class="built_in">string</span>(<span class="string">&quot;Hello, World!&quot;</span>);  <span class="comment">// 存储一个字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 访问存储的值</strong></p>
<p>要访问存储在 <code>std::any</code> 中的值，你需要使用 <code>std::any_cast</code>，它允许你提取存储的特定类型值。如果类型不匹配，则会抛出异常 <code>std::bad_any_cast</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::any a = <span class="number">42</span>;  <span class="comment">// 存储一个整数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> value = std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(a);  <span class="comment">// 获取存储的整数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_any_cast&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bad any_cast: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::string str = std::<span class="built_in">any_cast</span>&lt;std::string&gt;(a);  <span class="comment">// 尝试获取字符串，类型不匹配</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_any_cast&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;  <span class="comment">// 会抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>std::any_cast&lt;int&gt;</code> 能够成功提取出整数，但 <code>std::any_cast&lt;std::string&gt;</code> 会抛出 <code>std::bad_any_cast</code> 异常，因为存储的类型并不是字符串。</p>
<p><strong>3. 检查存储的类型</strong></p>
<p><code>std::any</code> 提供了 <code>type()</code> 方法，可以获取当前存储对象的类型信息（通过 <code>std::type_info</code>）。这允许你在运行时进行类型检查。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::any a = <span class="number">42</span>;  <span class="comment">// 存储一个整数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Stored type: &quot;</span> &lt;&lt; a.<span class="built_in">type</span>().<span class="built_in">name</span>() &lt;&lt; std::endl;  <span class="comment">// 输出类型名</span></span><br><span class="line"></span><br><span class="line">    a = std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Stored type: &quot;</span> &lt;&lt; a.<span class="built_in">type</span>().<span class="built_in">name</span>() &lt;&lt; std::endl;  <span class="comment">// 输出新类型名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子使用了 <code>type().name()</code> 来获取 <code>std::any</code> 中存储值的类型信息。输出将显示存储的对象的具体类型（例如 <code>int</code> 或 <code>std::string</code>）。</p>
<p><strong>4. 检查是否为空</strong></p>
<p><code>std::any</code> 对象可以存储一个空值（即无任何内容）。你可以通过 <code>has_value()</code> 方法来检查它是否存储了有效的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::any a;  <span class="comment">// a 为空</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Has value: &quot;</span> &lt;&lt; a.<span class="built_in">has_value</span>() &lt;&lt; std::endl;  <span class="comment">// 输出: false</span></span><br><span class="line"></span><br><span class="line">    a = <span class="number">10</span>;  <span class="comment">// 存储一个值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Has value: &quot;</span> &lt;&lt; a.<span class="built_in">has_value</span>() &lt;&lt; std::endl;  <span class="comment">// 输出: true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5. 重置 <code>std::any</code></strong></p>
<p><code>std::any</code> 的 <code>reset()</code> 方法可以清空其存储的值，将其状态重置为“空”：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::any a = <span class="number">42</span>;  <span class="comment">// 存储一个整数</span></span><br><span class="line">    a.<span class="built_in">reset</span>();  <span class="comment">// 重置</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Has value after reset: &quot;</span> &lt;&lt; a.<span class="built_in">has_value</span>() &lt;&lt; std::endl;  <span class="comment">// 输出: false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>std::any</code> 和其他多态机制的对比</strong></p>
<ol>
<li><strong>与 <code>void*</code> 对比</strong>：<code>std::any</code> 提供了类型安全的类型擦除，而 <code>void*</code> 是完全不安全的。使用 <code>void*</code> 你无法知道存储的具体类型，而且在解引用时需要非常小心以防止类型错误。而 <code>std::any</code> 可以通过 <code>std::any_cast</code> 和 <code>type()</code> 提供运行时的类型信息和安全类型转换。</li>
<li><strong>与 <code>std::variant</code> 对比</strong>：<code>std::variant</code> 也是C++17引入的多态类型，但 <code>std::variant</code> 是静态类型安全的，它只能存储在编译时定义的特定类型集合中的一种类型。而 <code>std::any</code> 则更加灵活，它能够存储任何类型，甚至是运行时动态决定的类型，但缺乏 <code>std::variant</code> 的编译时检查。</li>
</ol>
<h3 id="案例-10">案例</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241011090334329.png" class="" title="image-20241011090334329">
<p><strong>1. any基本用法：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span>  <span class="comment">// 引入头文件</span></span></span><br></pre></td></tr></table></figure>
<p><strong>代码 1：<code>input()</code> 函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">any <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i; </span><br><span class="line">    cin &gt;&gt; i; </span><br><span class="line">    <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> <span class="number">11</span>;         <span class="comment">// 返回 int</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="number">3.14</span>;       <span class="comment">// 返回 double</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// 返回 string</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>any</code> 类型返回值</strong>：<code>input()</code> 函数的返回类型为 <code>std::any</code>，因此它可以返回不同类型的值。</li>
</ul>
<p><strong>代码 2：存储 <code>std::any</code> 的值</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">any aa; </span><br><span class="line">aa = <span class="built_in">input</span>();</span><br></pre></td></tr></table></figure>
<p><strong>代码 3：类型判断与提取值</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (aa.<span class="built_in">type</span>() == <span class="built_in">typeid</span>(<span class="type">int</span>)) &#123;</span><br><span class="line">    cout &lt;&lt; aa.<span class="built_in">type</span>().<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(aa);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (aa.<span class="built_in">type</span>() == <span class="built_in">typeid</span>(<span class="type">double</span>)) &#123;</span><br><span class="line">    cout &lt;&lt; aa.<span class="built_in">type</span>().<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">any_cast</span>&lt;<span class="type">double</span>&gt;(aa);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; aa.<span class="built_in">type</span>().<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">any_cast</span>&lt;string&gt;(aa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>aa.type()</code></strong>：<code>std::any::type()</code> 返回存储在 <code>std::any</code> 中的类型信息（<code>std::type_info</code> 对象）。你可以将它与 <strong><code>typeid</code> 进行比较</strong>，判断 <code>std::any</code> 中的实际类型。</li>
<li><strong>输出类型名称</strong>：
<ul>
<li><strong><code>aa.type().name()</code></strong>：输出存储值的类型名称（由编译器定义的名字，通常类型是经过编码的字符串）。</li>
</ul>
</li>
<li><strong>提取值</strong>：
<ul>
<li><strong><code>any_cast&lt;T&gt;(aa)</code></strong>：<code>std::any_cast&lt;T&gt;(aa)</code> 用于将 <code>std::any</code> 类型的值转换为 <code>T</code> 类型的值。此处 <code>T</code> 是我们判断出来的实际存储的类型。如果类型不匹配，<code>any_cast</code> 会抛出 <code>std::bad_any_cast</code> 异常。</li>
</ul>
</li>
</ul>
<p><strong>3. PPT 中的其他重要知识点</strong></p>
<p><strong>3.1 类型安全</strong></p>
<p><strong><em>“type safe void”</em>：</strong></p>
<ul>
<li><code>std::any</code> 可以被看作是“类型安全的 <code>void*</code>”。<code>void*</code> 在C++中可以指向任何类型，但并不具有类型安全性。<code>std::any</code> 的出现弥补了这一缺陷，它允许存储不同类型的值，同时在需要时能安全地提取出正确的类型。通过 <code>std::any::type()</code> 和 <code>typeid()</code>，你可以在运行时检查存储的类型，并通过 <code>std::any_cast&lt;T&gt;</code> 安全地提取值。</li>
</ul>
<p><strong>“size-free basket”</strong>：</p>
<ul>
<li>这个术语是用来比喻 <code>std::any</code> 的。<code>basket</code>（篮子）意指 <code>std::any</code> 可以容纳任意类型的值。而“size-free” 表示 <code>std::any</code> 没有大小限制，可以容纳任何类型，无论它是基本类型如 <code>int</code> 或者是更大的复杂类型如 <code>std::vector</code>。这是因为 <strong><code>std::any</code> 会根据存储对象的大小动态分配所需的内存，而不是像数组那样有固定大小</strong>。</li>
</ul>
<h2 id="array">array</h2>
<h3 id="案例-11">案例</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241011091150794.png" class="" title="image-20241011091150794">
<p><strong><code>typeid(a).name()</code></strong></p>
<p><code>typeid(a).name()</code> 用于获取数组变量 <code>a</code> 的类型信息。在C++中，<code>typeid</code> 操作符可以返回一个 <code>std::type_info</code> 对象，<code>name()</code> 方法则返回类型的名称。<strong>数组作为参数传递时会退化为指针，所以 <code>typeid(a).name()</code> 返回的将是指针类型的名称。</strong></p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(a).<span class="built_in">name</span>() &lt;&lt; std::endl;  <span class="comment">// 输出int*</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当数组作为参数传递时，<code>typeid(a)</code> 会输出 <code>int*</code>，因为<strong>数组名在传递时已经退化为指针</strong>。</p>
<p><strong><code>sizeof</code> 问题</strong></p>
<p><code>sizeof</code> 操作符用于获取变量或类型的字节大小。在数组的上下文中，<code>sizeof</code> 有一些特殊表现：</p>
<ul>
<li>如果在数组定义的地方使用 <code>sizeof(arr)</code>，它会返回整个数组的字节大小。例如，<code>int arr[5]</code> 的 <code>sizeof(arr)</code> 是 <code>5 * sizeof(int)</code>，即 20 字节（在 32 位系统中）。</li>
<li>但是当数组作为参数传递给函数时，<strong>数组退化为指针</strong>，所以在<strong>函数内部对数组使用 <code>sizeof</code> 只会返回指针的大小</strong>（通常是 <strong>4</strong> 或 8 字节，具体取决于系统）。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; std::endl;  <span class="comment">// 输出指针大小，而不是数组大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，<strong>如果你想在函数中知道数组的长度，需要传递数组的大小（如 <code>n</code>），而不能依赖 <code>sizeof</code> 操作符。</strong></p>
<p><strong>Use debug info (使用调试信息)</strong></p>
<p><strong>1. <code>/RTC1</code></strong></p>
<p>这是微软Visual Studio中的一个编译器选项，代表“运行时检查”。启用 <code>/RTC1</code> 可以捕捉一些运行时错误，比如<strong>数组越界和未初始化变量的使用等</strong>。它对调试和提高程序的健壮性非常有帮助。</p>
<p><strong>2. <code>mallopt</code></strong></p>
<p><code>mallopt</code> 是一个内存分配优化函数，它允许用户修改 <code>malloc</code>、<code>calloc</code> 和 <code>realloc</code> 的行为，以控制内存管理的细节。这在处理大量<strong>动态分配内存</strong>时有帮助，但在数组的上下文中，主要是提醒开发者注意<strong>内存分配和优化</strong>。</p>
<p><strong>3. <code>valgrind</code></strong></p>
<p><code>valgrind</code> 是一个用于检测内存问题的调试工具，广泛应用于Linux环境中。它可以帮助开发者检测诸如内存泄漏、无效的内存访问（如数组越界）、未初始化的内存使用等问题。使用 <code>valgrind</code> 可以有效防止数组的非法访问和内存泄漏等问题。</p>
<p>例如，在 Linux 中，你可以用以下命令通过 <code>valgrind</code> 来运行你的程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind ./my_program</span><br></pre></td></tr></table></figure>
<p><code>valgrind</code> 会报告程序中的<strong>内存错误</strong>，帮助你快速定位和修复问题。</p>
<h2 id="pointer">pointer</h2>
<h3 id="案例-12">案例</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241011092004712.png" class="" title="image-20241011092004712">
<p><strong>Pointer Literal（指针字面量）</strong></p>
<p>指针字面量指的是用于表示“空指针”（null pointer）的一种符号，专门表示指针不指向任何有效的内存地址。</p>
<p>PPT在这一部分讨论了 <strong><code>NULL</code> 和 <code>nullptr</code> 这两种特殊的指针字面量</strong>，以及它们在 C 和 C++ 中的定义和用法。</p>
<p><strong>1. <code>NULL</code> 在 ANSI C 中的定义</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void*)0)</span></span><br></pre></td></tr></table></figure>
<p>在ANSI C中，<strong><code>NULL</code> 通常被定义为 <code>(void*)0</code>，即空指针</strong>（指向空地址的指针），这是为了表示一个指针不指向任何有效的内存位置。对于像 <code>char*</code> 这样的指针，<code>NULL</code> 可以用于指示空指针。</p>
<p><strong>2. <code>NULL</code> 在 C++ 中的定义</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br></pre></td></tr></table></figure>
<p>在C++中，<code>NULL</code> 通常被定义为 <code>0</code>，用于表示空指针。不过这种定义在C++中可能会导致一些歧义，因为整数 <code>0</code> 在某些上下文中也可以代表整型常量。<strong>为了避免这种歧义，C++11引入了 <code>nullptr</code>。</strong></p>
<p><strong>3. <code>nullptr</code></strong></p>
<p><code>nullptr</code> 是C++11中引入的一种<strong>专门用于表示空指针的类型安全的指针字面量。它取代了C++中的 <code>NULL</code></strong>，并避免了 <code>NULL</code> 与整数 <code>0</code> 之间的混淆。</p>
<p><strong>代码示例中的歧义：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(<span class="literal">NULL</span>);  <span class="comment">// 这是调用哪个函数？</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，如果 <code>NULL</code> 被定义为 <code>0</code>，那么 <code>func(NULL)</code> 将变得模糊不清，因为 <code>NULL</code> 是一个整数 <code>0</code>，它可能匹配 <code>func(int)</code>，也可能匹配 <code>func(char*)</code>。这种模糊会带来不确定性。</p>
<p>使用 <code>nullptr</code> 可以消除这个歧义，因为 <code>nullptr</code> 是一个类型安全的指针字面量，专门用于指针类型，因此 <code>func(nullptr)</code> 只能匹配 <code>void func(char*)</code> 函数。</p>
<h2 id="Dynamic-variables">Dynamic variables</h2>
<h3 id="案例-13">案例</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241011093714534.png" class="" title="image-20241011093714534">
<p><strong>1. Dynamic Variables（动态变量）</strong></p>
<p>动态变量指的是在程序运行时<strong>通过动态内存分配（如 <code>malloc</code>、<code>new</code>）创建</strong>的变量。<strong>与静态分配的变量不同，动态变量不在编译时决定大小，而是在运行时动态分配，并且必须手动释放内存</strong>。否则，可能会引发内存泄漏。</p>
<p><strong>内存分配和释放相关的函数</strong></p>
<ul>
<li>
<p><code>malloc</code> 和 <code>free</code></p>
<p>：这些是C语言中的标准库函数，用于动态分配和释放内存。</p>
<ul>
<li><strong><code>malloc</code></strong>：分配一块指定大小的内存，返回指向这块内存的指针。</li>
<li><strong><code>free</code></strong>：释放先前通过 <code>malloc</code> 分配的内存，避免内存泄漏。</li>
</ul>
</li>
<li>
<p><code>new</code> 和 <code>delete</code></p>
<p>：这是C++中用于动态分配和释放内存的操作符。</p>
<ul>
<li><strong><code>new</code></strong>：在C++中，用于为某种类型分配内存并返回该类型的指针。与 <code>malloc</code> 不同，<code>new</code> 同时调用构造函数。</li>
<li><strong><code>delete</code></strong>：用于释放通过 <code>new</code> 分配的内存，防止内存泄漏。</li>
<li><strong><code>delete[]</code></strong>：当通过 <code>new[]</code> 分配一个数组时，使用 <code>delete[]</code> 释放内存。</li>
</ul>
</li>
</ul>
<p><strong>2. 内存泄漏（Memory Leak）与闲置指针（Idle Pointer）</strong></p>
<ul>
<li><strong>Memory Leak（内存泄漏）</strong>：如果分配了内存但没有释放，那么这些内存将无法再被使用，导致系统资源逐渐耗尽，这种情况称为内存泄漏。比如通过 <code>new</code> 分配内存后，如果没有使用 <code>delete</code> 来释放内存，就会发生内存泄漏。</li>
<li><strong>Idle Pointer（闲置指针）</strong>：指针如果没有及时释放或者没有正确指向有效的内存地址，可能会变成悬空指针（即指向已经被释放或不再有效的内存地址）。使用闲置指针可能导致程序崩溃或者不可预测的行为。</li>
</ul>
<p><strong>3. 堆（Heap）内存结构</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/C++高级程序设计/image-20241011094553926.png"  alt="image-20241011094553926" style="zoom: 50%;" />
<p>在PPT的右上角，有一个堆内存结构的图示，展示了堆是如何在内存中的不同区域中分配的。</p>
<ul>
<li><strong>Kernel Space（内核空间）</strong>：用户代码无法直接访问这部分内存。</li>
<li><strong>Stack（栈）</strong>：栈用于存储函数调用时的<strong>局部变量</strong>，栈的内存从<strong>高地址向低地址</strong>增长。</li>
<li><strong>Heap（堆）</strong>：堆用于<strong>动态分配内存</strong>，内存从<strong>低地址向高地址</strong>增长。通过 <code>malloc</code> 或 <code>new</code> 分配的内存位于这里。堆的起始位置由 <code>brk</code> 或 <code>mmap</code> 进行管理（这是Linux系统中的内存管理方式）。</li>
</ul>
<p><strong>4. C++中动态内存分配的示例</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">2</span>] &#123; <span class="number">7</span>, <span class="number">15</span> &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>int* p = new int[2]</code></strong>：在<strong>堆</strong>上为两个整型元素动态分配内存，返回指向该内存块的指针 <code>p</code>。该内存块包含两个整型值：<code>7</code> 和 <code>15</code>。</li>
<li><strong><code>&#123;7, 15&#125;</code></strong>：表示通过初始化列表，将两个元素的值分别设为 <code>7</code> 和 <code>15</code>。</li>
</ul>
<p><strong>5. 内存调试信息</strong></p>
<p>PPT中的数据表示了通过某种调试工具（例如 <code>valgrind</code> 或类似工具）获取的内存地址和内存中的值，展示了动态分配的内存的布局。</p>
<ul>
<li>内存地址和数据：
<ul>
<li>你可以看到分配的内存从地址 <code>0x206334937D0</code> 开始，每个地址对应一组二进制数据，展示了<strong>堆上的内存内容</strong>。</li>
<li>内存地址的后面显示了该地址处存储的值。例如，地址 <code>0x206334937B0</code> 对应的值是 <code>00001000</code>。</li>
</ul>
</li>
</ul>
<p>这些数据展示了动态分配内存块中的内容。通常调试工具会显示类似的信息，以帮助开发者了解程序的内存使用情况。</p>
<p><strong>6. “cookie”</strong></p>
<ul>
<li><strong>Cookie（堆检查标记）</strong>：通常在<strong>堆分配器</strong>中，会在<strong>内存块的前后添加一些标记位或特殊的“cookie”值</strong>，用于检测是否存在<strong>内存越界写入或者非法内存访问</strong>。当程序对动态内存进行越界操作时，可能会破坏这些“cookie”值，从而触发内存错误的警告或检测。</li>
</ul>
<p>在这张PPT中，<code>cookie</code> 表示在内存分配或释放时用于检测非法访问或保护内存的机制。</p>
<p><strong>7. 内存管理方式：<code>brk</code> 和 <code>mmap</code></strong></p>
<ul>
<li><code>brk</code> 和 <code>mmap</code>是 Linux 操作系统中两种不同的内存管理方式：
<ul>
<li><strong><code>brk</code></strong>：是通过调整堆的顶部（<code>program break</code>）来动态分配内存的方式。通过增加 <code>brk</code> 值，程序可以从操作系统请求更多的堆内存。</li>
<li><strong><code>mmap</code></strong>：是一种通过内存映射机制直接从操作系统分配内存块的方式，通常用于分配较大的内存块或者在某些情况下更高效的内存管理。</li>
</ul>
</li>
</ul>
<p>这两种机制都是Linux系统中常用的内存分配方式，它们被用来管理程序的堆内存。</p>
<ul>
<li>图示中的<code>fd fd fd fd</code> 是调试工具自动填充的字节模式，表示这些内存区域曾经被释放或标记为不再有效。如果在程序运行中不小心访问这些内存区域，通常意味着你正在使用已经释放的内存，这可能会导致程序崩溃或产生不可预期的行为。</li>
</ul>
<h2 id="RAII">RAII</h2>
<p>在C++中，RAII（Resource Acquisition Is Initialization，<strong>资源获取即初始化</strong>）是一种管理资源（如内存、文件句柄、网络连接等）的编程惯用法。RAII的核心思想是将**资源的生命周期与对象的生命周期绑定在一起，通过对象的构造函数获取资源，通过析构函数释放资源。**这样一来，当对象的作用域结束时（无论是正常退出还是异常退出），资源都会自动得到释放，避免资源泄露和重复释放的问题。</p>
<p><strong>具体机制</strong></p>
<ol>
<li><strong>构造函数负责获取资源</strong>：当一个对象被创建时，构造函数会同时分配资源。这些资源可能是动态内存、文件句柄、互斥锁等。</li>
<li><strong>析构函数负责释放资源</strong>：当对象的生命周期结束（对象超出作用域或被显式销毁）时，析构函数会被<strong>自动调用，释放对象持有的资源</strong>。这样，不需要手动管理资源的释放。</li>
</ol>
<p><strong>RAII的优点</strong></p>
<ol>
<li><strong>异常安全</strong>：如果在代码执行过程中发生异常，RAII保证了所有资源会在对象析构时自动释放，而不会因为异常的传播导致资源泄露。</li>
<li><strong>易于使用</strong>：RAII隐藏了资源管理的复杂性，开发者不需要显式地管理资源的释放，减少了手动释放资源的风险（如忘记释放、释放多次等）。</li>
</ol>
<p><strong>常见的RAII实现</strong></p>
<ul>
<li><strong><code>std::unique_ptr</code> 和 <code>std::shared_ptr</code></strong>：用于管理动态内存，自动释放内存等，见后续说明</li>
</ul>
<h3 id="RAII实现1-unique-ptr">RAII实现1 unique_ptr</h3>
<p><strong>1. <code>unique_ptr</code> 是什么？</strong></p>
<p><code>unique_ptr</code> 是C++标准库中的智能指针之一，它有如下特点：</p>
<ul>
<li><strong>唯一拥有</strong>：<code>unique_ptr</code> 拥有它所指向的对象，意味着<strong>同一时刻只能有一个 <code>unique_ptr</code> 指针管理某块内存</strong>。当 <code>unique_ptr</code> 被销毁、重置或指向另一对象时，它<strong>管理的内存会被自动释放</strong>。</li>
<li><strong>不可复制</strong>：<code>unique_ptr</code> 不允许被复制（拷贝语义被禁用），所以它不能被赋值给另一个 <code>unique_ptr</code>。但是可以通过 <strong>转移所有权</strong>（move semantics）将 <code>unique_ptr</code> 的所有权转移到另一个 <code>unique_ptr</code>。</li>
</ul>
<p><strong>2. <code>unique_ptr</code> 的特点</strong></p>
<ul>
<li><strong>自动管理内存</strong>：<code>unique_ptr</code> 在其生命周期结束时会自动释放内存，不需要手动调用 <code>delete</code>。</li>
<li><strong>不可复制，但可以移动</strong>：<code>unique_ptr</code> 遵循独占所有权原则，因此不允许多个指针同时管理同一块内存。如果你想将所有权转移给另一个 <code>unique_ptr</code>，需要使用 <strong>移动语义</strong>（<code>std::move</code>）。</li>
<li><strong>资源安全释放</strong>：即使在异常情况下（如抛出异常时），<code>unique_ptr</code> 也能确保其所管理的内存被安全释放。</li>
</ul>
<p><strong>3. 如何使用 <code>unique_ptr</code></strong></p>
<p><strong>3.1 基本用法</strong></p>
<p><code>unique_ptr</code> 用于替代传统的手动内存管理。下面是基本的使用示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>  <span class="comment">// 包含unique_ptr的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;  <span class="comment">// 使用unique_ptr管理动态分配的int</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; *p1 &lt;&lt; std::endl;         <span class="comment">// 通过解引用访问p1管理的内存</span></span><br><span class="line">    <span class="comment">// 不需要手动delete，p1超出作用域时会自动释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>p1</code> 是一个 <code>unique_ptr</code>，它管理着通过 <code>new int(10)</code> 动态分配的内存。<code>unique_ptr</code> 确保在 <code>main()</code> 函数结束时自动释放内存，不需要手动调用 <code>delete</code>。</p>
<p><strong>3.2 使用工厂函数 <code>std::make_unique</code></strong></p>
<p>C++14 之后引入了 <code>std::make_unique</code> 工厂函数来简化创建 <code>unique_ptr</code> 的过程，避免直接使用 <code>new</code>。推荐使用这种方式来分配和初始化 <code>unique_ptr</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p2 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>);  <span class="comment">// 使用std::make_unique创建unique_ptr</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; *p2 &lt;&lt; std::endl;        <span class="comment">// 输出20</span></span><br><span class="line">    <span class="comment">// 不需要手动delete</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>std::make_unique</code> 的好处是它避免了直接使用 <code>new</code>，从而减少了代码中可能的错误（如内存泄漏）。</p>
<p><strong>3.3 传递和返回 <code>unique_ptr</code></strong></p>
<p>由于 <code>unique_ptr</code> 不能复制，所以如果要将 <code>unique_ptr</code> <strong>作为参数传递或从函数返回时</strong>，应该使用 <strong>移动语义</strong>。</p>
<p><strong>传递 <code>unique_ptr</code> 到函数：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void process(std::unique_ptr&lt;int&gt; ptr) &#123;</span><br><span class="line">    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    auto p3 = std::make_unique&lt;int&gt;(30);</span><br><span class="line">    process(std::move(p3));  // 使用std::move将所有权转移给process函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>std::move(p3)</code> 将 <code>p3</code> 的所有权转移到 <code>process()</code> 函数内，<code>p3</code> 在 <code>main()</code> 函数中不再拥有这块内存。</p>
<p><strong>函数返回 <code>unique_ptr</code>：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">40</span>);  <span class="comment">// 返回一个unique_ptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p4 = <span class="built_in">create</span>();  <span class="comment">// 从create函数接收unique_ptr</span></span><br><span class="line">    std::cout &lt;&lt; *p4 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数 <code>create()</code> 中，返回一个 <code>unique_ptr</code>，然后在 <code>main()</code> 函数中接收该智能指针。</p>
<p><strong>3.4 转移所有权</strong></p>
<p>由于 <code>unique_ptr</code> 的不可复制性，它可以 <strong>转移所有权</strong>（所有权从一个 <code>unique_ptr</code> 移交到另一个 <code>unique_ptr</code>）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; p5 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">50</span>);</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; p6 = std::<span class="built_in">move</span>(p5);  <span class="comment">// 将p5的所有权转移给p6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!p5) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;p5 is null&quot;</span> &lt;&lt; std::endl;  <span class="comment">// p5不再拥有这块内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; *p6 &lt;&lt; std::endl;               <span class="comment">// p6拥有这块内存，输出50</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，<code>std::move(p5)</code> 将 <code>p5</code> 的所有权转移给了 <code>p6</code>，此时 <code>p5</code> 不再指向有效内存，而 <code>p6</code> 拥有该动态分配的内存。</p>
<p><strong>4. <code>unique_ptr</code> 的析构函数</strong></p>
<p><code>unique_ptr</code> 的析构函数非常重要，它会在 <code>unique_ptr</code> 超出作用域时自动释放其管理的内存。这是 <code>RAII</code> 的核心概念之一。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; p7 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">70</span>);</span><br><span class="line">    <span class="comment">// p7 的生命周期结束时，内存会自动释放</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里 p7 已经被销毁，内存被释放</span></span><br></pre></td></tr></table></figure>
<p>一旦 <code>p7</code> 超出它的作用域，<code>unique_ptr</code> 会自动调用 <code>delete</code> 释放所管理的资源，避免了手动释放的麻烦和潜在的内存泄漏问题。</p>
<h3 id="案例-14">案例</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241011104009441-17286146129221.png" class="" title="image-20241011104009441">
<p><strong>PPT左侧代码</strong></p>
<p><strong>1. 传统动态内存管理中的问题</strong></p>
<p><strong><code>old_use(Args a)</code>：手动管理内存的方式</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">old_use</span><span class="params">(Args a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> q = <span class="keyword">new</span> <span class="built_in">Blob</span>(a);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (foo) <span class="keyword">throw</span> <span class="built_in">Bad</span>();  <span class="comment">// 会泄漏</span></span><br><span class="line">    <span class="keyword">if</span> (bar) <span class="keyword">return</span>;       <span class="comment">// 会泄漏</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">delete</span> q;              <span class="comment">// 容易忘</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中：</p>
<ul>
<li><code>auto q = new Blob(a);</code>：通过 <code>new</code> 分配动态内存，<code>q</code> 指向类型为 <code>Blob</code> 的对象。</li>
<li><strong>潜在的问题</strong>：如果在函数执行过程中发生异常（如 <code>throw Bad()</code>）或提早返回（<code>if (bar) return;</code>），将会导致 <code>q</code> 所指向的内存永远无法被释放，造成 <strong>内存泄漏</strong>。</li>
<li><strong><code>delete</code> 操作</strong>：手动释放通过 <code>new</code> 分配的内存，需要调用 <code>delete q;</code>。但是这种手动内存管理极其容易出错，特别是在复杂的控制流中，程序员可能忘记释放内存，导致内存泄漏。</li>
</ul>
<p><strong>2. <code>unique_ptr</code> 和 RAII 的引入</strong></p>
<p>为了避免手动管理内存带来的问题，C++引入了<strong>智能指针</strong>，特别是 <code>unique_ptr</code>。<code>unique_ptr</code> 遵循 <strong>RAII</strong> 原则，确保<strong>当对象生命周期结束时，资源自动被释放</strong>。</p>
<p><strong><code>newer_use(Args a)</code>：使用 <code>unique_ptr</code> 管理内存</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">newer_use</span><span class="params">(Args a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = <span class="built_in">unique_ptr</span>&lt;Blob&gt;(<span class="keyword">new</span> <span class="built_in">Blob</span>(a));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (foo) <span class="keyword">throw</span> <span class="built_in">Bad</span>();  <span class="comment">// 不会泄漏</span></span><br><span class="line">    <span class="keyword">if</span> (bar) <span class="keyword">return</span>;       <span class="comment">// 不会泄漏</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>unique_ptr</code> 的使用</strong>：使用 <code>unique_ptr&lt;Blob&gt;(new Blob(a))</code> 分配动态内存，并将其管理权交给 <code>unique_ptr</code>。当 <code>unique_ptr</code> 超出作用域（如函数结束时）时，<strong>智能指针会自动调用 <code>delete</code> 来释放内存</strong>，避免了手动释放内存的错误。</li>
<li><strong>RAII 原则</strong>：RAII 表示资源获取时绑定其生命周期，即当对象创建时分配资源，当对象销毁时自动释放资源。<strong><code>unique_ptr</code> 符合这一原则，当 <code>unique_ptr</code> 被销毁时，它所管理的内存也会自动释放。</strong></li>
<li><strong>避免内存泄漏</strong>：如果 <code>foo</code> 导致抛出异常或者 <code>bar</code> 提前返回，智能指针 <code>p</code> 的析构函数会自动释放</li>
</ul>
<p><strong>PPT右侧代码</strong></p>
<p>这张PPT右侧的两个类展示了一个<strong>简单的智能指针实现</strong>——<code>auto_ptr</code> 和 <code>int_ptr</code>。</p>
<p><strong>1. <code>auto_ptr</code> 类模板</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Template &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">auto_ptr</span>(T *p=<span class="number">0</span>):<span class="built_in">ptr</span>(p) &#123;&#125;   <span class="comment">// 构造函数，初始化ptr</span></span><br><span class="line">    ~<span class="built_in">auto_ptr</span>() &#123; <span class="keyword">delete</span> ptr; &#125;   <span class="comment">// 析构函数，释放ptr所指向的资源</span></span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> ptr; &#125;    <span class="comment">// 重载 -&gt; 操作符，返回ptr</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr; &#125;    <span class="comment">// 重载 * 操作符，解引用ptr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;   <span class="comment">// 指向动态分配内存的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<ul>
<li><strong>类模板 <code>auto_ptr&lt;T&gt;</code></strong>：这是一个用于管理动态分配对象的智能指针类。它接受任意类型 <code>T</code>，并管理指向 <code>T</code> 类型对象的指针。</li>
<li><strong>构造函数</strong>：<code>auto_ptr(T* p=0)</code>，构造函数接受一个指向类型 <code>T</code> 的指针 <code>p</code>，默认值为 <code>0</code>（空指针）。它将 <code>ptr</code> 初始化为传入的指针 <code>p</code>。</li>
<li><strong>析构函数</strong>：<code>~auto_ptr()</code>，在 <code>auto_ptr</code> 的生命周期结束时，析构函数会自动调用 <code>delete</code> 来释放 <code>ptr</code> 所指向的动态内存，防止内存泄漏。</li>
<li><code>operator-&gt;</code>：重载箭头操作符 <code>-&gt;</code>，允许通过智能指针直接访问它所指向的对象的成员。
<ul>
<li>示例：<code>auto_ptr-&gt;成员函数()</code> 等同于 <code>ptr-&gt;成员函数()</code>。</li>
</ul>
</li>
<li><code>operator*</code>：重载解引用操作符 <code>*</code>，允许通过智能指针解引用获取指向的对象。
<ul>
<li>示例：<code>*auto_ptr</code> 等同于 <code>*ptr</code>。</li>
</ul>
</li>
</ul>
<p>这个 <code>auto_ptr</code> 类类似于C++98标准库中的 <code>std::auto_ptr</code>，但由于 <code>std::auto_ptr</code> 存在所有权管理问题（不安全的复制行为），它在C++11中被弃用了。<code>unique_ptr</code> 是其更安全的替代品。</p>
<p><strong>2. <code>int_ptr</code> 类</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">int_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int_ptr</span>(<span class="type">int</span> *p=<span class="number">0</span>):<span class="built_in">ptr</span>(p) &#123;&#125;  <span class="comment">// 构造函数，初始化ptr</span></span><br><span class="line">    ~<span class="built_in">int_ptr</span>() &#123; <span class="keyword">delete</span> ptr; &#125;   <span class="comment">// 析构函数，释放ptr所指向的资源</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> ptr; &#125;  <span class="comment">// 重载 -&gt; 操作符，返回ptr</span></span><br><span class="line">    <span class="type">int</span>&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr; &#125;  <span class="comment">// 重载 * 操作符，解引用ptr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* ptr;   <span class="comment">// 指向动态分配int类型的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<ul>
<li><strong><code>int_ptr</code> 类</strong>：这是一个特化用于管理 <code>int</code> 类型指针的类，与 <code>auto_ptr&lt;T&gt;</code> 类似，但它只用于管理 <code>int*</code> 类型的指针。</li>
<li><strong>构造函数</strong>：<code>int_ptr(int *p=0)</code>，接受一个 <code>int*</code> 类型的指针，并将其赋值给 <code>ptr</code>。同样，默认值是空指针 <code>0</code>。</li>
<li><strong>析构函数</strong>：在对象的生命周期结束时，<code>~int_ptr()</code> 会调用 <code>delete</code>，释放 <code>ptr</code> 所指向的 <code>int</code> 类型的内存。</li>
<li><strong><code>operator-&gt;</code></strong>：重载箭头操作符 <code>-&gt;</code>，允许通过 <code>int_ptr</code> 对象访问 <code>int</code> 类型指针的内容。虽然 <code>int</code> 类型没有成员函数，但为了与其他类一致，提供了该操作符。</li>
<li><strong><code>operator\*</code></strong>：重载解引用操作符 <code>*</code>，允许通过 <code>int_ptr</code> 访问 <code>ptr</code> 所指向的 <code>int</code> 值。</li>
</ul>
<p><strong>3. 这两个类的设计意图</strong></p>
<p>这两个类展示了智能指针的基本思想：</p>
<ul>
<li>自动管理动态分配的内存，通过析构函数确保资源的释放。</li>
<li>通过重载 <code>-&gt;</code> 和 <code>*</code> 操作符，使智能指针的使用方式与原生指针一致。</li>
</ul>
<p>两者的不同之处在于：</p>
<ul>
<li><strong><code>auto_ptr</code></strong> 是一个模板类，可以管理任意类型 <code>T</code> 的动态内存，具有通用性。</li>
<li><strong><code>int_ptr</code></strong> 则是特化的类，只用于管理 <code>int*</code> 类型的指针。</li>
</ul>
<p><strong>4. 与现代智能指针（如 <code>unique_ptr</code>）的对比</strong></p>
<p>与现代C++中的 <code>unique_ptr</code> 相比，这两个类存在一些不足：</p>
<ul>
<li><strong>所有权问题</strong>：<code>auto_ptr</code> 和 <code>int_ptr</code> 都没有处理指针所有权的转移，存在指针所有权的不安全复制问题。如果尝试拷贝 <code>auto_ptr</code>，会导致多次释放同一块内存（<code>double delete</code>），从而导致程序崩溃。</li>
<li><strong>移动语义</strong>：现代C++的智能指针如 <code>unique_ptr</code> 提供了 <strong>移动语义</strong>，即可以通过 <code>std::move</code> 安全地转移指针的所有权，而不会发生拷贝。</li>
<li><strong>线程安全</strong>：<code>auto_ptr</code> 在多线程环境下也不安全。现代智能指针如 <code>shared_ptr</code> 提供了更好的并发管理。</li>
</ul>
<h3 id="RAII实现2-shared-ptr">RAII实现2 shared_ptr</h3>
<p><strong>1. <code>shared_ptr</code> 是什么？</strong></p>
<p>多个 <code>shared_ptr</code> 可以同时指向同一个对象，并且通过 <strong>引用计数机制</strong> 来管理对象的生命周期。</p>
<p>当多个对象需要共享同一资源时，使用 <code>shared_ptr</code> 可以确保<strong>资源在最后一个使用者销毁时自动释放</strong>。</p>
<p><code>shared_ptr</code> 是 <strong>引用计数智能指针</strong>，它的主要特点是：</p>
<ul>
<li><strong>共享所有权</strong>：多个 <code>shared_ptr</code> 可以同时指向同一个对象，共享该对象的所有权。每一个 <code>shared_ptr</code> 指向该对象时，引用计数会递增；当 <code>shared_ptr</code> 被销毁或重置时，引用计数会递减。当引用计数变为 0 时，指向的对象会被销毁。</li>
<li><strong>自动管理内存</strong>：当引用计数归零时，<code>shared_ptr</code> 会自动释放内存，无需手动调用 <code>delete</code>。</li>
<li><strong>线程安全</strong>：<code>shared_ptr</code> 的引用计数是线程安全的，意味着可以在多个线程中共享同一个对象，引用计数的增加和减少不会引起数据竞争问题。</li>
</ul>
<p><strong>2. 如何使用 <code>shared_ptr</code></strong></p>
<p><strong>2.1 创建 <code>shared_ptr</code></strong></p>
<p>使用 <code>shared_ptr</code> 可以通过 <code>std::make_shared</code> 进行动态内存分配，或者通过直接构造 <code>shared_ptr</code> 对象。</p>
<p><strong>使用 <code>std::make_shared</code></strong>（推荐做法）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; p1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);  <span class="comment">// 创建shared_ptr，指向整数42</span></span><br><span class="line">    std::cout &lt;&lt; *p1 &lt;&lt; std::endl;  <span class="comment">// 输出42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::make_shared</code> 是推荐的方式，它不仅提供了更简洁的语法，还能减少内存分配的开销，因为它在分配对象和控制块（用于引用计数）时可以一次性完成。</p>
<p><strong>直接构造 <code>shared_ptr</code></strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;  <span class="comment">// 不推荐，手动使用new</span></span><br><span class="line">    std::cout &lt;&lt; *p1 &lt;&lt; std::endl;  <span class="comment">// 输出42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然可以直接通过 <code>new</code> 创建 <code>shared_ptr</code>，但不推荐，因为 <code>std::make_shared</code> 更高效且更安全。</p>
<p><strong>2.2 引用计数的管理</strong></p>
<p><code>shared_ptr</code> 通过引用计数来管理对象的生命周期。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; p1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);  <span class="comment">// 创建shared_ptr，引用计数为1</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;<span class="type">int</span>&gt; p2 = p1;  <span class="comment">// p2与p1共享对象，引用计数为2</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;use count: &quot;</span> &lt;&lt; p<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;  <span class="comment">// 输出2</span></span><br><span class="line">    &#125;  <span class="comment">// p2离开作用域，引用计数减为1</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;use count: &quot;</span> &lt;&lt; p<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;  <span class="comment">// 输出1</span></span><br><span class="line">&#125;  <span class="comment">// p1离开作用域，引用计数为0，内存被释放</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中：</p>
<ul>
<li>当 <code>p1</code> 创建时，引用计数为 1。</li>
<li>当 <code>p2</code> 复制了 <code>p1</code>，它们共享同一块内存，引用计数增加为 2。</li>
<li>当 <code>p2</code> 离开作用域，引用计数减少为 1。</li>
<li>当 <code>p1</code> 离开作用域时，引用计数为 0，动态内存自动释放。</li>
</ul>
<p><strong>2.3 传递和返回 <code>shared_ptr</code></strong></p>
<p>可以安全地传递 <code>shared_ptr</code> 给函数或从函数返回，因为它支持拷贝语义，传递或返回时会增加引用计数。</p>
<p><strong>作为函数参数传递</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(std::shared_ptr&lt;<span class="type">int</span>&gt; sp)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; *sp &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; p = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    <span class="built_in">process</span>(p);  <span class="comment">// 引用计数增加</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;use count: &quot;</span> &lt;&lt; p.<span class="built_in">use_count</span>() &lt;&lt; std::endl;  <span class="comment">// 输出1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>从函数返回 <code>shared_ptr</code></strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">99</span>);  <span class="comment">// 返回shared_ptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; p = <span class="built_in">create</span>();  <span class="comment">// 获取函数返回的shared_ptr</span></span><br><span class="line">    std::cout &lt;&lt; *p &lt;&lt; std::endl;  <span class="comment">// 输出99</span></span><br><span class="line">&#125;</span><br><span class="line">**<span class="number">2.4</span> `shared_ptr` 的移动语义**</span><br></pre></td></tr></table></figure>
<p>虽然 <code>shared_ptr</code> 是可拷贝的，但在某些情况下使用移动语义更高效。例如，<strong>如果你不需要共享对象，只是想转移所有权，可以使用 <code>std::move</code>。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; p1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; p2 = std::<span class="built_in">move</span>(p1);  <span class="comment">// p1的所有权转移给p2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!p1) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;p1 is null&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p2: &quot;</span> &lt;&lt; *p2 &lt;&lt; std::endl;  <span class="comment">// 输出100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>p1</code> 的所有权通过 <code>std::move</code> 被转移给 <code>p2</code>，此时 <code>p1</code> 为空指针，只有 <code>p2</code> 继续持有该对象的所有权。</p>
<ol start="3">
<li><strong><code>shared_ptr</code> 与 <code>unique_ptr</code> 的区别</strong></li>
</ol>
<ul>
<li><strong><code>shared_ptr</code> 共享所有权</strong>：<code>shared_ptr</code> 支持多个指针同时指向同一个对象，并通过引用计数管理对象的生命周期。多个 <code>shared_ptr</code> 共享同一对象时，它们的引用计数会递增，当引用计数归零时，内存会自动释放。</li>
<li><strong><code>unique_ptr</code> 独占所有权</strong>：<code>unique_ptr</code> 实现了独占所有权，同一时刻只有一个 <code>unique_ptr</code> 指向一个对象。它不支持拷贝操作，必须通过移动语义来转移所有权。</li>
</ul>
<p><strong>4. 循环引用问题</strong></p>
<p>如果两个对象相互引用对方，且都使用 <code>shared_ptr</code>，就会导致循环引用问题，即两个对象的引用计数都无法归零，造成内存泄漏。</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; next;</span><br><span class="line">    ~<span class="built_in">Node</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Node destroyed&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; n1 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line">    std::shared_ptr&lt;Node&gt; n2 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line">    n1-&gt;next = n2;</span><br><span class="line">    n2-&gt;next = n1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 由于循环引用，n1和n2都不会被销毁，导致内存泄漏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>n1</code> 和 <code>n2</code> 相互引用对方，导致它们的引用计数都不会归零，内存不会被释放。</p>
<p><strong>5. 解决循环引用：<code>weak_ptr</code></strong>**</p>
<p>为了解决循环引用问题，可以使用 <strong><code>weak_ptr</code></strong> 来打破循环引用。<code>weak_ptr</code> 是一种<strong>不增加引用计数的智能指针，它只能观察对象，而不会拥有对象。</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::weak_ptr&lt;Node&gt; next;  <span class="comment">// 使用weak_ptr打破循环引用</span></span><br><span class="line">    ~<span class="built_in">Node</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Node destroyed&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; n1 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line">    std::shared_ptr&lt;Node&gt; n2 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line">    n1-&gt;next = n2;</span><br><span class="line">    n2-&gt;next = n1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 由于weak_ptr的使用，n1和n2会被正确销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>weak_ptr</code> 不会增加引用计数，因此即使 <code>n1</code> 和 <code>n2</code> 相互引用，它们也能在引用计数归零时被正确销毁。</p>
<h3 id="RAII应该不包括-weak-ptr">RAII应该不包括 weak_ptr</h3>
<p><code>weak_ptr</code> 是 C++ 标准库中的一种智能指针，它提供了一种对对象的<strong>非拥有（non-owning）弱引用</strong>。<code>weak_ptr</code> 的主要作用是配合 <code>shared_ptr</code> 一起使用，解决**循环引用（circular reference）**的问题。它不会增加 <code>shared_ptr</code> 所指对象的引用计数，因此不会干扰对象的生命周期管理。</p>
<p><strong>1. <code>weak_ptr</code> 的基本概念</strong></p>
<ul>
<li><strong>弱引用</strong>：<strong><code>weak_ptr</code> 并不拥有对象的所有权，它只是指向一个 <code>shared_ptr</code> 管理的对象</strong>。因此，<code>weak_ptr</code> 不会影响 <code>shared_ptr</code> 的引用计数。即使存在多个 <code>weak_ptr</code> 指向同一个对象，也不会阻止该对象的销毁。</li>
<li><strong>避免循环引用</strong>：<code>weak_ptr</code> 的主要设计目的是打破循环引用的问题。当两个或多个对象互相通过 <code>shared_ptr</code> 引用对方时，会形成一个循环，导致这些对象的引用计数永远不会归零，进而无法被正确释放。<strong>通过使用 <code>weak_ptr</code>，可以打破这种循环引用。</strong></li>
</ul>
<p><strong>2. 如何使用 <code>weak_ptr</code></strong></p>
<p><code>weak_ptr</code> <strong>不能直接解引用访问对象</strong>（因为它不保证对象的存在），需要通过 <code>lock()</code> 方法将 <code>weak_ptr</code> 转换为 <code>shared_ptr</code>，然后才能安全地访问对象。</p>
<p><strong>2.1 创建 <code>weak_ptr</code></strong></p>
<p><code>weak_ptr</code> 通常从 <code>shared_ptr</code> 创建。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sp = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);  <span class="comment">// 创建shared_ptr</span></span><br><span class="line">    std::weak_ptr&lt;<span class="type">int</span>&gt; wp = sp;  <span class="comment">// 从shared_ptr创建weak_ptr</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Shared_ptr use count: &quot;</span> &lt;&lt; sp.<span class="built_in">use_count</span>() &lt;&lt; std::endl;  <span class="comment">// 输出1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>wp</code> 是一个指向 <code>sp</code> 管理的对象的弱引用。虽然 <code>wp</code> 指向同一个对象，但它<strong>不会增加引用计数</strong>，所以 <code>sp.use_count()</code> 输出仍为 1。</p>
<p><strong>2.2 访问 <code>weak_ptr</code> 指向的对象</strong></p>
<p>要从 <code>weak_ptr</code> 中访问对象，必须使用 <code>lock()</code> 方法将其转换为 <code>shared_ptr</code>。如果对象仍然存在，<code>lock()</code> 会返回一个指向该对象的 <code>shared_ptr</code>；如果对象已被销毁，<code>lock()</code> 返回一个空的 <code>shared_ptr</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sp = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">200</span>);  <span class="comment">// 创建shared_ptr</span></span><br><span class="line">    std::weak_ptr&lt;<span class="type">int</span>&gt; wp = sp;  <span class="comment">// 创建weak_ptr</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> spt = wp.<span class="built_in">lock</span>()) &#123;  <span class="comment">// 使用lock()获取shared_ptr</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Weak_ptr is valid, value: &quot;</span> &lt;&lt; *spt &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Weak_ptr is expired&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp.<span class="built_in">reset</span>();  <span class="comment">// 手动释放shared_ptr</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> spt = wp.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Weak_ptr is valid, value: &quot;</span> &lt;&lt; *spt &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Weak_ptr is expired&quot;</span> &lt;&lt; std::endl;  <span class="comment">// 现在对象已经被释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Weak_ptr is valid, value: 200</span><br><span class="line">Weak_ptr is expired</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li>使用 <code>lock()</code> 检查 <code>weak_ptr</code> 指向的对象是否有效。如果有效，<code>lock()</code> 返回一个 <code>shared_ptr</code>，可以正常解引用访问对象。</li>
<li>当 <code>shared_ptr</code> 释放其所管理的对象（通过 <code>sp.reset()</code>），<code>weak_ptr</code> 会失效（即变为 expired），<code>lock()</code> 返回空的 <code>shared_ptr</code>。</li>
</ul>
<p><strong>2.3 检查 <code>weak_ptr</code> 是否失效</strong></p>
<p>可以通过 <code>expired()</code> 方法检查 <code>weak_ptr</code> 是否失效：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (wp.<span class="built_in">expired</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Weak_ptr has expired&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Weak_ptr is still valid&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>expired()</code> 返回 <code>true</code>，表示对象已被销毁，<code>weak_ptr</code> 变得无效。</li>
<li><code>expired()</code> 返回 <code>false</code>，表示对象仍然存在。</li>
</ul>
<ol start="3">
<li><strong>打破循环引用问题</strong></li>
</ol>
<p>循环引用是指多个对象互相持有 <code>shared_ptr</code>，导致它们的引用计数无法归零，从而无法释放内存。这是 <code>shared_ptr</code> 的一个常见问题，但可以通过 <code>weak_ptr</code> 来解决。</p>
<p><strong>循环引用示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; next;</span><br><span class="line">    ~<span class="built_in">Node</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Node destroyed&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; n1 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line">    std::shared_ptr&lt;Node&gt; n2 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line">    n1-&gt;next = n2;  <span class="comment">// n1指向n2</span></span><br><span class="line">    n2-&gt;next = n1;  <span class="comment">// n2指向n1，形成循环引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// n1和n2不会被销毁，内存泄漏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>n1</code> 和 <code>n2</code> 互相持有对方的 <code>shared_ptr</code>，这导致它们的引用计数永远不会降为 0，最终内存泄漏。</p>
<p><strong>使用 <code>weak_ptr</code> 打破循环引用：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">struct Node &#123;</span><br><span class="line">    std::weak_ptr&lt;Node&gt; next;  // 使用weak_ptr避免循环引用</span><br><span class="line">    ~Node() &#123; std::cout &lt;&lt; &quot;Node destroyed&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; n1 = std::make_shared&lt;Node&gt;();</span><br><span class="line">    std::shared_ptr&lt;Node&gt; n2 = std::make_shared&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line">    n1-&gt;next = n2;  // n1指向n2</span><br><span class="line">    n2-&gt;next = n1;  // n2通过weak_ptr指向n1，打破循环引用</span><br><span class="line"></span><br><span class="line">    return 0;  // n1和n2会被正确销毁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>n2</code> 持有对 <code>n1</code> 的弱引用，这样即使 <code>n1</code> 和 <code>n2</code> 互相引用，当 <code>n1</code> 和 <code>n2</code> 离开作用域时，它们的引用计数都会降为 0，最终正确释放内存。</p>
<p><strong>4. <code>weak_ptr</code> 的生命周期管理</strong></p>
<ul>
<li><strong>不会延长对象的生命周期</strong>：<code>weak_ptr</code> 不增加引用计数，因此它不会阻止对象的销毁。对象的生命周期完全由 <code>shared_ptr</code> 管理。</li>
<li><strong>不会直接访问对象</strong>：<code>weak_ptr</code> 不能像 <code>shared_ptr</code> 那样直接解引用访问对象，因为它不能保证对象仍然存在。要访问对象，需要调用 <code>lock()</code>。</li>
<li><strong>避免悬空指针</strong>：当 <code>shared_ptr</code> 被销毁时，所有指向同一个对象的 <code>weak_ptr</code> 会自动失效。调用 <code>lock()</code> 时，如果对象已销毁，<code>lock()</code> 会返回空的 <code>shared_ptr</code>，从而避免悬空指针。</li>
</ul>
<h3 id="案例-15">案例</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20241011105509353.png" class="" title="image-20241011105509353">
<p><strong>1. 创建 <code>shared_ptr</code> 对象</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; shared_p&#123; <span class="keyword">new</span> <span class="type">int</span>&#123;<span class="number">1</span>&#125; &#125;;  <span class="comment">// = make_shared&lt;int&gt;(1);</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;shared_p: &quot;</span> &lt;&lt; *shared_p &lt;&lt; <span class="string">&quot; count: &quot;</span> &lt;&lt; shared_p.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建 <code>shared_ptr</code>：<code>shared_p</code>指向一个动态分配的整数1
<ul>
<li>这里可以使用 <code>new</code> 直接初始化，但<strong>推荐使用 <code>make_shared</code></strong>，因为它更高效且减少了潜在的内存分配错误。</li>
</ul>
</li>
<li><strong><code>use_count()</code> 输出</strong>：<code>shared_ptr</code> 的引用计数会初始化为 <strong>1</strong>，表示当前有一个 <code>shared_ptr</code> 拥有该资源。</li>
</ul>
<p><strong>2. 复制 <code>shared_ptr</code> 增加引用计数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; shared_p_ref = shared_p;</span><br><span class="line">*shared_p_ref = <span class="number">11</span>;  <span class="comment">// 修改 shared_p_ref 所指向的对象</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;add a ref :&quot;</span> &lt;&lt; endl</span><br><span class="line">     &lt;&lt; <span class="string">&quot;shared_p :&quot;</span> &lt;&lt; *shared_p &lt;&lt; <span class="string">&quot; count:&quot;</span> &lt;&lt; shared_p.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>shared_ptr</code> 拷贝</strong>：<code>shared_p_ref</code> 是 <code>shared_p</code> 的副本。它们共享同一个对象，并且<strong>引用计数增加到 2</strong>。</li>
<li><strong>修改对象</strong>：修改 <code>shared_p_ref</code> 中的值会同步反映在 <code>shared_p</code> 上。</li>
</ul>
<p><strong>3. 创建 <code>weak_ptr</code> 指向 <code>shared_ptr</code></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">weak_ptr&lt;<span class="type">int</span>&gt; weak_p&#123; shared_p &#125;;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;add a weak :&quot;</span> &lt;&lt; endl</span><br><span class="line">     &lt;&lt; <span class="string">&quot; shared_p: &quot;</span> &lt;&lt; *shared_p &lt;&lt; <span class="string">&quot; count: &quot;</span> &lt;&lt; shared_p.<span class="built_in">use_count</span>() &lt;&lt; endl</span><br><span class="line">     &lt;&lt; <span class="string">&quot; weak_p: &quot;</span> &lt;&lt; weak_p.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>weak_ptr</code></strong>：<code>weak_p</code> 是指向 <code>shared_p</code> 的<strong>弱引用</strong>，它不会增加引用计数。</li>
<li><strong><code>use_count()</code> 输出</strong>：虽然 <code>weak_ptr</code> 存在，但 <code>shared_ptr</code> 的引用计数仍为 <strong>2</strong>。<code>weak_p.use_count()</code> 返回 <code>2</code>，代表当前有两个 <code>shared_ptr</code> 拥有该资源。</li>
</ul>
<p><strong>4. 使用 <code>lock()</code> 从 <code>weak_ptr</code> 获取 <code>shared_ptr</code></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> temp = weak_p.<span class="built_in">lock</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;after lock :&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">nullptr</span> == temp)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;shared resource expired&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    *temp = <span class="number">111</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;shared_p: &quot;</span> &lt;&lt; *shared_p &lt;&lt; <span class="string">&quot; count:&quot;</span> &lt;&lt; shared_p.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>lock()</code></strong>：将 <code>weak_ptr</code> 转换为 <code>shared_ptr</code>，如果资源存在，则成功获取一个新的 <code>shared_ptr</code>，否则返回 <code>nullptr</code>。</li>
<li><strong>检查是否成功</strong>：如果 <code>temp</code> 不是空指针，则修改其值，并打印引用计数。</li>
</ul>
<p><strong>输出：</strong></p>
<ul>
<li>此时 <code>shared_p</code> 的引用计数为 <strong>3</strong>，因为 <strong><code>temp</code> 也是一个 <code>shared_ptr</code>。</strong></li>
</ul>
<p><strong>5. 重置 <code>shared_ptr</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shared_p.reset(new int&#123;2&#125;);  // 重新指向一个新对象</span><br><span class="line">cout &lt;&lt; &quot;shared_p moved &quot; &lt;&lt; endl</span><br><span class="line">     &lt;&lt; &quot;shared_p &quot; &lt;&lt; *shared_p &lt;&lt; &quot; count: &quot; &lt;&lt; shared_p.use_count() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;shared_p_ref: &quot; &lt;&lt; *shared_p_ref &lt;&lt; &quot; count: &quot; &lt;&lt; shared_p_ref.use_count() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>reset()</code></strong>：<code>shared_p</code> 被重置，指向一个新的整数 <code>2</code>。旧的资源引用计数减少，此时<strong>旧资源只有 <code>shared_p_ref</code> 拥有</strong>，引用计数为 1。</li>
<li><strong>新对象</strong>：<code>shared_p</code> 现在指向一个新分配的整数 <code>2</code>（因为还有temp），其引用计数为 2。</li>
</ul>
<p><strong>6. 总结：<code>shared_ptr</code> 和 <code>weak_ptr</code> 的关系</strong></p>
<ul>
<li><strong><code>shared_ptr</code></strong>：管理对象的所有权，通过引用计数管理其生命周期。多个 <code>shared_ptr</code> 可以共享同一个对象。</li>
<li><strong><code>weak_ptr</code></strong>：不会增加引用计数，只用于观察对象，避免循环引用问题。需要通过 <code>lock()</code> 方法访问资源。</li>
</ul>
<p><strong>引用计数的变化：</strong></p>
<ol>
<li><code>shared_p</code> 创建时，计数为 1。</li>
<li>复制给 <code>shared_p_ref</code>，计数变为 2。</li>
<li>创建 <code>weak_p</code> 后，引用计数保持为 2。</li>
<li>使用 <code>lock()</code> 获取 <code>temp</code> 后，计数变为 3。</li>
<li>重置 <code>shared_p</code> 后，新对象计数为 1，旧对象只剩下 <code>shared_p_ref</code>和<code>temp</code>，计数为2。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Liu Kai-Qi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">http://example.com/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">ChocStar🍫</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">C++高级程序设计</a></div><div class="post-share"><div class="social-share" data-image="/img/C++.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="next-post pull-full" href="/2025/01/25/C7/" title="C++高级程序设计笔记（C7）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++高级程序设计笔记（C7）</div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a href="/2025/01/25/C7/" title="C++高级程序设计笔记（C7）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-25</div><div class="title">C++高级程序设计笔记（C7）</div></div></a><a href="/2025/01/25/C8/" title="C++高级程序设计笔记（C8）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-25</div><div class="title">C++高级程序设计笔记（C8）</div></div></a><a href="/2025/01/25/C5/" title="C++高级程序设计笔记（C5）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-25</div><div class="title">C++高级程序设计笔记（C5）</div></div></a><a href="/2025/01/25/C6/" title="C++高级程序设计笔记（C6）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-25</div><div class="title">C++高级程序设计笔记（C6）</div></div></a><a href="/2025/01/25/CPP-2-1/" title="C++高级程序设计笔记（C2-1）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-25</div><div class="title">C++高级程序设计笔记（C2-1）</div></div></a><a href="/2025/01/25/CPP-2-4/" title="C++高级程序设计笔记（C2-4）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-25</div><div class="title">C++高级程序设计笔记（C2-4）</div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Liu Kai-Qi</div><div class="author-info-description">Sometimes you have to go for it</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/liukqchoco"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/liukqchoco" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">C++高级程序设计（C1-C4)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">C1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#introduction"><span class="toc-number">2.1.</span> <span class="toc-text">introduction</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">C2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#static-cast"><span class="toc-number">3.1.</span> <span class="toc-text">static_cast</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">3.1.1.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const-cast"><span class="toc-number">3.2.</span> <span class="toc-text">const_cast</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reinterpret-cast"><span class="toc-number">3.3.</span> <span class="toc-text">reinterpret_cast</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-2"><span class="toc-number">3.3.1.</span> <span class="toc-text">案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">C3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#dynamic-cast"><span class="toc-number">4.1.</span> <span class="toc-text">dynamic_cast</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#virtual"><span class="toc-number">4.2.</span> <span class="toc-text">virtual</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-3"><span class="toc-number">4.2.1.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#auto"><span class="toc-number">4.3.</span> <span class="toc-text">auto</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#decltype"><span class="toc-number">4.4.</span> <span class="toc-text">decltype</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Range-for"><span class="toc-number">4.5.</span> <span class="toc-text">Range-for</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Uniform-Initialization"><span class="toc-number">4.6.</span> <span class="toc-text">Uniform Initialization</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-4"><span class="toc-number">4.6.1.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Union"><span class="toc-number">4.7.</span> <span class="toc-text">Union</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-5"><span class="toc-number">4.7.1.</span> <span class="toc-text">案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">C4</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#struct"><span class="toc-number">5.1.</span> <span class="toc-text">struct</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#alignment"><span class="toc-number">5.1.1.</span> <span class="toc-text">alignment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Padding"><span class="toc-number">5.1.2.</span> <span class="toc-text">Padding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Little-Endian"><span class="toc-number">5.1.3.</span> <span class="toc-text">Little Endian</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-6"><span class="toc-number">5.1.4.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tuple-Structed-Binding"><span class="toc-number">5.2.</span> <span class="toc-text">tuple &amp; Structed Binding</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-7"><span class="toc-number">5.2.1.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#optional"><span class="toc-number">5.3.</span> <span class="toc-text">optional</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-8"><span class="toc-number">5.3.1.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#varient"><span class="toc-number">5.4.</span> <span class="toc-text">varient</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-9"><span class="toc-number">5.4.1.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#any"><span class="toc-number">5.5.</span> <span class="toc-text">any</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-10"><span class="toc-number">5.5.1.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#array"><span class="toc-number">5.6.</span> <span class="toc-text">array</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-11"><span class="toc-number">5.6.1.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pointer"><span class="toc-number">5.7.</span> <span class="toc-text">pointer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-12"><span class="toc-number">5.7.1.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dynamic-variables"><span class="toc-number">5.8.</span> <span class="toc-text">Dynamic variables</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-13"><span class="toc-number">5.8.1.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RAII"><span class="toc-number">5.9.</span> <span class="toc-text">RAII</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RAII%E5%AE%9E%E7%8E%B01-unique-ptr"><span class="toc-number">5.9.1.</span> <span class="toc-text">RAII实现1 unique_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-14"><span class="toc-number">5.9.2.</span> <span class="toc-text">案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAII%E5%AE%9E%E7%8E%B02-shared-ptr"><span class="toc-number">5.9.3.</span> <span class="toc-text">RAII实现2 shared_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAII%E5%BA%94%E8%AF%A5%E4%B8%8D%E5%8C%85%E6%8B%AC-weak-ptr"><span class="toc-number">5.9.4.</span> <span class="toc-text">RAII应该不包括 weak_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-15"><span class="toc-number">5.9.5.</span> <span class="toc-text">案例</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" title="C++高级程序设计笔记（C1-C4）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++高级程序设计笔记（C1-C4）"/></a><div class="content"><a class="title" href="/2025/01/25/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" title="C++高级程序设计笔记（C1-C4）">C++高级程序设计笔记（C1-C4）</a><time datetime="2025-01-25T14:10:32.000Z" title="发表于 2025-01-25 22:10:32">2025-01-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/25/C7/" title="C++高级程序设计笔记（C7）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++高级程序设计笔记（C7）"/></a><div class="content"><a class="title" href="/2025/01/25/C7/" title="C++高级程序设计笔记（C7）">C++高级程序设计笔记（C7）</a><time datetime="2025-01-25T14:10:32.000Z" title="发表于 2025-01-25 22:10:32">2025-01-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/25/C8/" title="C++高级程序设计笔记（C8）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++高级程序设计笔记（C8）"/></a><div class="content"><a class="title" href="/2025/01/25/C8/" title="C++高级程序设计笔记（C8）">C++高级程序设计笔记（C8）</a><time datetime="2025-01-25T14:10:32.000Z" title="发表于 2025-01-25 22:10:32">2025-01-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/25/C5/" title="C++高级程序设计笔记（C5）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++高级程序设计笔记（C5）"/></a><div class="content"><a class="title" href="/2025/01/25/C5/" title="C++高级程序设计笔记（C5）">C++高级程序设计笔记（C5）</a><time datetime="2025-01-25T14:10:32.000Z" title="发表于 2025-01-25 22:10:32">2025-01-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/25/C6/" title="C++高级程序设计笔记（C6）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/C++.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++高级程序设计笔记（C6）"/></a><div class="content"><a class="title" href="/2025/01/25/C6/" title="C++高级程序设计笔记（C6）">C++高级程序设计笔记（C6）</a><time datetime="2025-01-25T14:10:32.000Z" title="发表于 2025-01-25 22:10:32">2025-01-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Liu Kai-Qi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>(() => {
  const panguFn = () => {
    if (typeof pangu === 'object') pangu.autoSpacingPage()
    else {
      btf.getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
        .then(() => {
          pangu.autoSpacingPage()
        })
    }
  }

  const panguInit = () => {
    if (false){
      GLOBAL_CONFIG_SITE.isPost && panguFn()
    } else {
      panguFn()
    }
  }

  btf.addGlobalFn('pjaxComplete', panguInit, 'pangu')
  document.addEventListener('DOMContentLoaded', panguInit)
})()</script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="你要找什么呀" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>